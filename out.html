 <style>pre{white-space:pre-wrap;background:#f7f9fa;padding:10px 15px;color:#263238;line-height:1.6;font-size:13px;border-radius:3px margin-top: 0;margin-bottom:1em;overflow:auto}b,strong{font-weight:bolder}#title{font-size:16px;color:#212121;font-weight:600;margin-bottom:10px}hr{height:10px;border:0;box-shadow:0 10px 10px -10px #8c8b8b inset}</style>******************************<div id="title">4. Median of Two Sorted Arrays</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums1 = [1,3], nums2 = [2]
<strong>输出：</strong>2.00000
<strong>解释：</strong>合并数组 = [1,2,3] ，中位数 2
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums1 = [1,2], nums2 = [3,4]
<strong>输出：</strong>2.50000
<strong>解释：</strong>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
</pre>
<p> </p>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m &lt;= 1000</code></li>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= m + n &lt;= 2000</code></li>
<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">10. Regular Expression Matching</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p>
<ul>
<li><code>'.'</code> 匹配任意单个字符</li>
<li><code>'*'</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个 </strong>字符串 <code>s</code>的，而不是部分字符串。</p>
 

<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "aa", p = "a"
<strong>输出：</strong>false
<strong>解释：</strong>"a" 无法匹配 "aa" 整个字符串。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入：</strong>s = "aa", p = "a*"
<strong>输出：</strong>true
<strong>解释：</strong>因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "ab", p = ".*"
<strong>输出：</strong>true
<strong>解释：</strong>".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>1 &lt;= p.length &lt;= 30</code></li>
<li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
<li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">23. Merge k Sorted Lists</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>lists = [[1,4,5],[1,3,4],[2,6]]
<strong>输出：</strong>[1,1,2,3,4,4,5,6]
<strong>解释：</strong>链表数组如下：
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
将它们合并到一个有序链表中得到。
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>lists = []
<strong>输出：</strong>[]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>lists = [[]]
<strong>输出：</strong>[]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>k == lists.length</code></li>
<li><code>0 &lt;= k &lt;= 10^4</code></li>
<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>
<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>
<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>
<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************<div id="title">25. Reverse Nodes in k-Group</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你链表的头节点 <code>head</code> ，每 <code>k</code><em> </em>个节点一组进行翻转，请你返回修改后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code><em> </em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" style="width: 542px; height: 222px;"/>
<pre><strong>输入：</strong>head = [1,2,3,4,5], k = 2
<strong>输出：</strong>[2,1,4,3,5]
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" style="width: 542px; height: 222px;"/></p>
<pre><strong>输入：</strong>head = [1,2,3,4,5], k = 3
<strong>输出：</strong>[3,2,1,4,5]
</pre>
<p> </p>
<strong>提示：</strong>
<ul>
<li>链表中的节点数目为 <code>n</code></li>
<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p> </p>
<p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p>
<ul>
</ul>
</div></div></div><br><br><hr><br>*********************************************<div id="title">30. Substring with Concatenation of All Words</div>
*********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串 <code>s</code><strong> </strong>和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p>
<p> <code>s</code><strong> </strong>中的 <strong>串联子串</strong> 是指一个包含  <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p>
<ul>
<li>例如，如果 <code>words = ["ab","cd","ef"]</code>， 那么 <code>"abcdef"</code>， <code>"abefcd"</code>，<code>"cdabef"</code>， <code>"cdefab"</code>，<code>"efabcd"</code>， 和 <code>"efcdab"</code> 都是串联子串。 <code>"acdbef"</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li>
</ul>
<p>返回所有串联字串在 <code>s</code><strong> </strong>中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "barfoothefoobarman", words = ["foo","bar"]
<strong>输出：</strong><code>[0,9]</code>
<strong>解释：</strong>因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
<code><strong>输出：</strong>[]</code>
<strong>解释：</strong>因为<strong> </strong>words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。
s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。
所以我们返回一个空数组。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
<strong>输出：</strong>[6,9,12]
<strong>解释：</strong>因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。
子串 "foobarthe" 开始位置是 6。它是 words 中以 ["foo","bar","the"] 顺序排列的连接。
子串 "barthefoo" 开始位置是 9。它是 words 中以 ["bar","the","foo"] 顺序排列的连接。
子串 "thefoobar" 开始位置是 12。它是 words 中以 ["the","foo","bar"] 顺序排列的连接。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
<li><code>1 &lt;= words.length &lt;= 5000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 30</code></li>
<li><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">32. Longest Valid Parentheses</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p> </p>
<div class="original__bRMd">
<div>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "(()"
<strong>输出：</strong>2
<strong>解释：</strong>最长有效括号子串是 "()"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = ")()())"
<strong>输出：</strong>4
<strong>解释：</strong>最长有效括号子串是 "()()"
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = ""
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>
<li><code>s[i]</code> 为 <code>'('</code> 或 <code>')'</code></li>
</ul>
</div>
</div>
</div></div></div><br><br><hr><br>*****************<div id="title">37. Sudoku Solver</div>
*****************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需<strong> 遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p>
<p> </p>
<div class="top-view__1vxA">
<div class="original__bRMd">
<div>
<p><strong>示例 1：</strong></p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" style="height:250px; width:250px"/>
<pre><strong>输入：</strong>board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
<strong>输出：</strong>[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
<strong>解释：</strong>输入的数独如上图所示，唯一有效的解决方案如下所示：

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png" style="height:250px; width:250px"/>
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>board.length == 9</code></li>
<li><code>board[i].length == 9</code></li>
<li><code>board[i][j]</code> 是一位数字或者 <code>'.'</code></li>
<li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li>
</ul>
</div>
</div>
</div>
</div></div></div><br><br><hr><br>**************************<div id="title">41. First Missing Positive</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。

<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,0]
<strong>输出：</strong>3
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [3,4,-1,1]
<strong>输出：</strong>2
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [7,8,9,11,12]
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>5</sup></code></li>
<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div></div></div><br><br><hr><br>***********************<div id="title">42. Trapping Rain Water</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" style="height: 161px; width: 412px;"/></p>
<pre><strong>输入：</strong>height = [0,1,0,2,1,0,1,3,2,1,2,1]
<strong>输出：</strong>6
<strong>解释：</strong>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>height = [4,2,0,3,2,5]
<strong>输出：</strong>9
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*********************<div id="title">44. Wildcard Matching</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>'?'</code> 和 <code>'*'</code> 的通配符匹配。</p>
<pre>'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
</pre>
<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
s = "aa"
p = "a"
<strong>输出:</strong> false
<strong>解释:</strong> "a" 无法匹配 "aa" 整个字符串。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
s = "aa"
p = "*"
<strong>输出:</strong> true
<strong>解释:</strong> '*' 可以匹配任意字符串。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong>
s = "cb"
p = "?a"
<strong>输出:</strong> false
<strong>解释:</strong> '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong>
s = "adceb"
p = "*a*b"
<strong>输出:</strong> true
<strong>解释:</strong> 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong>
s = "acdcb"
p = "a*c?b"
<strong>输出:</strong> false</pre>
</div></div></div><br><br><hr><br>************<div id="title">51. N-Queens</div>
************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n<em> </em>皇后问题</strong> 的解决方案。</p>
<div class="original__bRMd">
<div>
<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" style="width: 600px; height: 268px;"/>
<pre><strong>输入：</strong>n = 4
<strong>输出：</strong>[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
<strong>解释：</strong>如上图所示，4 皇后问题存在两个不同的解法。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>[["Q"]]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 9</code></li>
</ul>
</div>
</div>
</div></div></div><br><br><hr><br>***************<div id="title">52. N-Queens II</div>
***************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n × n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p>
<p> </p>
<div class="original__bRMd">
<div>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" style="width: 600px; height: 268px;"/>
<pre><strong>输入：</strong>n = 4
<strong>输出：</strong>2
<strong>解释：</strong>如上图所示，4 皇后问题存在两个不同的解法。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 9</code></li>
</ul>
</div>
</div>
</div></div></div><br><br><hr><br>************************<div id="title">60. Permutation Sequence</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给出集合 <code>[1,2,3,...,n]</code>，其所有元素共有 <code>n!</code> 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p>
<ol>
<li><code>"123"</code></li>
<li><code>"132"</code></li>
<li><code>"213"</code></li>
<li><code>"231"</code></li>
<li><code>"312"</code></li>
<li><code>"321"</code></li>
</ol>
<p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 3, k = 3
<strong>输出：</strong>"213"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 4, k = 9
<strong>输出：</strong>"2314"
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 3, k = 1
<strong>输出：</strong>"123"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 9</code></li>
<li><code>1 &lt;= k &lt;= n!</code></li>
</ul>
</div></div></div><br><br><hr><br>****************<div id="title">65. Valid Number</div>
****************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>
<li>（可选）一个 <code>'e'</code> 或 <code>'E'</code> ，后面跟着一个 <strong>整数</strong></li>
</ol>
<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>
<li>下述格式之一：
	<ol>
<li>至少一位数字，后面跟着一个点 <code>'.'</code></li>
<li>至少一位数字，后面跟着一个点 <code>'.'</code> ，后面再跟着至少一位数字</li>
<li>一个点 <code>'.'</code> ，后面跟着至少一位数字</li>
</ol>
</li>
</ol>
<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>
<li>至少一位数字</li>
</ol>
<p>部分有效数字列举如下：<code>["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]</code></p>
<p>部分无效数字列举如下：<code>["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]</code></p>
<p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>有效数字</strong> ，请返回 <code>true</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "0"
<strong>输出：</strong>true
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "e"
<strong>输出：</strong>false
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "."
<strong>输出：</strong>false
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>'+'</code> ，减号 <code>'-'</code> ，或者点 <code>'.'</code> 。</li>
</ul>
</div></div></div><br><br><hr><br>**********************<div id="title">68. Text Justification</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个单词数组 <code>words</code> 和一个长度 <code>maxWidth</code> ，重新排版单词，使其成为每行恰好有 <code>maxWidth</code> 个字符，且左右两端对齐的文本。</p>
<p>你应该使用 “<strong>贪心算法</strong>” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>' '</code> 填充，使得每行恰好有 <em>maxWidth</em> 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p>
<p><strong>注意:</strong></p>
<ul>
<li>单词是指由非空格字符组成的字符序列。</li>
<li>每个单词的长度大于 0，小于等于 <em>maxWidth</em>。</li>
<li>输入单词数组 <code>words</code> 至少包含一个单词。</li>
</ul>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16
<strong>输出:</strong>
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16
<strong>输出:</strong>
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
<strong>解释: </strong>注意最后一行的格式应为 "shall be    " 而不是 "shall     be",
     因为最后一行应为左对齐，而不是左右两端对齐。       
     第二行同样为左对齐，这是因为这行只包含一个单词。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong>words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"]，maxWidth = 20
<strong>输出:</strong>
[
  "Science  is  what we",
  "understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 300</code></li>
<li><code>1 &lt;= words[i].length &lt;= 20</code></li>
<li><code>words[i]</code> 由小写英文字母和符号组成</li>
<li><code>1 &lt;= maxWidth &lt;= 100</code></li>
<li><code>words[i].length &lt;= maxWidth</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************<div id="title">72. Edit Distance</div>
*****************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em>  。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>word1 = "horse", word2 = "ros"
<strong>输出：</strong>3
<strong>解释：</strong>
horse -&gt; rorse (将 'h' 替换为 'r')
rorse -&gt; rose (删除 'r')
rose -&gt; ros (删除 'e')
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>word1 = "intention", word2 = "execution"
<strong>输出：</strong>5
<strong>解释：</strong>
intention -&gt; inention (删除 't')
inention -&gt; enention (将 'i' 替换为 'e')
enention -&gt; exention (将 'n' 替换为 'x')
exention -&gt; exection (将 'n' 替换为 'c')
exection -&gt; execution (插入 'u')
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>****************************<div id="title">76. Minimum Window Substring</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>""</code> 。</p>
<p> </p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "ADOBECODEBANC", t = "ABC"
<strong>输出：</strong>"BANC"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "a", t = "a"
<strong>输出：</strong>"a"
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> s = "a", t = "aa"
<strong>输出:</strong> ""
<strong>解释:</strong> t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<p> </p>
<strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</div></div></div><br><br><hr><br>**********************************<div id="title">84. Largest Rectangle in Histogram</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"/></p>
<pre><strong>输入：</strong>heights = [2,1,5,6,2,3]
<strong>输出：</strong>10
<strong>解释：</strong>最大的矩形为图中红色区域，面积为 10
</pre>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg"/></p>
<pre><strong>输入：</strong> heights = [2,4]
<b>输出：</b> 4</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= heights.length &lt;=10<sup>5</sup></code></li>
<li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*********************<div id="title">85. Maximal Rectangle</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" style="width: 402px; height: 322px;"/>
<pre><strong>输入：</strong>matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
<strong>输出：</strong>6
<strong>解释：</strong>最大矩形如上图所示。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>matrix = []
<strong>输出：</strong>0
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>matrix = [["0"]]
<strong>输出：</strong>0
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>matrix = [["1"]]
<strong>输出：</strong>1
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>matrix = [["0","0"]]
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>rows == matrix.length</code></li>
<li><code>cols == matrix[0].length</code></li>
<li><code>1 &lt;= row, cols &lt;= 200</code></li>
<li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************<div id="title">87. Scramble String</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate">使用下面描述的算法可以扰乱字符串 <code>s</code> 得到字符串 <code>t</code> ：
<ol>
<li>如果字符串的长度为 1 ，算法停止</li>
<li>如果字符串的长度 &gt; 1 ，执行下述步骤：
	<ul>
<li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 <code>s</code> ，则可以将其分成两个子字符串 <code>x</code> 和 <code>y</code> ，且满足 <code>s = x + y</code> 。</li>
<li><strong>随机</strong> 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，<code>s</code> 可能是 <code>s = x + y</code> 或者 <code>s = y + x</code> 。</li>
<li>在 <code>x</code> 和 <code>y</code> 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li>
</ul>
</li>
</ol>
<p>给你两个 <strong>长度相等</strong> 的字符串 <code>s1</code><em> </em>和 <code>s2</code>，判断 <code>s2</code><em> </em>是否是 <code>s1</code><em> </em>的扰乱字符串。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s1 = "great", s2 = "rgeat"
<strong>输出：</strong>true
<strong>解释：</strong>s1 上可能发生的一种情形是：
"great" --&gt; "gr/eat" // 在一个随机下标处分割得到两个子字符串
"gr/eat" --&gt; "gr/eat" // 随机决定：「保持这两个子字符串的顺序不变」
"gr/eat" --&gt; "g/r / e/at" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割
"g/r / e/at" --&gt; "r/g / e/at" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」
"r/g / e/at" --&gt; "r/g / e/ a/t" // 继续递归执行此算法，将 "at" 分割得到 "a/t"
"r/g / e/ a/t" --&gt; "r/g / e/ a/t" // 随机决定：「保持这两个子字符串的顺序不变」
算法终止，结果字符串和 s2 相同，都是 "rgeat"
这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s1 = "abcde", s2 = "caebd"
<strong>输出：</strong>false
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s1 = "a", s2 = "a"
<strong>输出：</strong>true
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>s1.length == s2.length</code></li>
<li><code>1 &lt;= s1.length &lt;= 30</code></li>
<li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">115. Distinct Subsequences</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串 <code>s</code><strong> </strong>和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p>
<p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>"ACE"</code> 是 <code>"ABCDE"</code> 的一个子序列，而 <code>"AEC"</code> 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "rabbbit", t = "rabbit"<code>
<strong>输出</strong></code><strong>：</strong><code>3
</code><strong>解释：</strong>
如下图所示, 有 3 种可以从 s 中得到 <code>"rabbit" 的方案</code>。
<code><strong><u>rabb</u></strong>b<strong><u>it</u></strong></code>
<code><strong><u>ra</u></strong>b<strong><u>bbit</u></strong></code>
<code><strong><u>rab</u></strong>b<strong><u>bit</u></strong></code></pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "babgbag", t = "bag"
<code><strong>输出</strong></code><strong>：</strong><code>5
</code><strong>解释：</strong>
如下图所示, 有 5 种可以从 s 中得到 <code>"bag" 的方案</code>。 
<code><strong><u>ba</u></strong>b<u><strong>g</strong></u>bag</code>
<code><strong><u>ba</u></strong>bgba<strong><u>g</u></strong></code>
<code><u><strong>b</strong></u>abgb<strong><u>ag</u></strong></code>
<code>ba<u><strong>b</strong></u>gb<u><strong>ag</strong></u></code>
<code>babg<strong><u>bag</u></strong></code>
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">123. Best Time to Buy and Sell Stock III</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个数组，它的第<em> </em><code>i</code> 个元素是一支给定的股票在第 <code>i</code><em> </em>天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔 </strong>交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入：</strong>prices = [3,3,5,0,0,3,1,4]
<strong>输出：</strong>6
<strong>解释：</strong>在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>prices = [1,2,3,4,5]
<strong>输出：</strong>4
<strong>解释：</strong>在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>prices = [7,6,4,3,1] 
<strong>输出：</strong>0 
<strong>解释：</strong>在这个情况下, 没有交易完成, 所以最大利润为 0。</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>prices = [1]
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">124. Binary Tree Maximum Path Sum</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径<strong> 至少包含一个 </strong>节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" style="width: 322px; height: 182px;"/>
<pre><strong>输入：</strong>root = [1,2,3]
<strong>输出：</strong>6
<strong>解释：</strong>最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg"/>
<pre><strong>输入：</strong>root = [-10,9,20,null,null,15,7]
<strong>输出：</strong>42
<strong>解释：</strong>最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 10<sup>4</sup>]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************<div id="title">126. Word Ladder II</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>按字典 <code>wordList</code> 完成从单词 <code>beginWord</code> 到单词 <code>endWord</code> 转化，一个表示此过程的 <strong>转换序列</strong> 是形式上像 <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> 这样的单词序列，并满足：</p>
<div class="original__bRMd">
<div>
<ul>
<li>每对相邻的单词之间仅有单个字母不同。</li>
<li>转换过程中的每个单词 <code>s<sub>i</sub></code>（<code>1 &lt;= i &lt;= k</code>）必须是字典 <code>wordList</code> 中的单词。注意，<code>beginWord</code> 不必是字典 <code>wordList</code> 中的单词。</li>
<li><code>s<sub>k</sub> == endWord</code></li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> ，以及一个字典 <code>wordList</code> 。请你找出并返回所有从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表<em> </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code> 的形式返回。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
<strong>输出：</strong>[["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
<strong>解释：</strong>存在 2 种最短的转换序列：
"hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog"
"hit" -&gt; "hot" -&gt; "lot" -&gt; "log" -&gt; "cog"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
<strong>输出：</strong>[]
<strong>解释：</strong>endWord "cog" 不在字典 wordList 中，所以不存在符合要求的转换序列。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>
<li><code>endWord.length == beginWord.length</code></li>
<li><code>1 &lt;= wordList.length &lt;= 500</code></li>
<li><code>wordList[i].length == beginWord.length</code></li>
<li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li>
<li><code>beginWord != endWord</code></li>
<li><code>wordList</code> 中的所有单词 <strong>互不相同</strong></li>
</ul>
</div>
</div>
</div></div></div><br><br><hr><br>****************<div id="title">127. Word Ladder</div>
****************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code><em> </em>和 <code>endWord</code> 的 <strong>转换序列 </strong>是一个按下述规格形成的序列 <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code>：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li> 对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>s<sub>i</sub></code> 都在 <code>wordList</code> 中。注意， <code>beginWord</code><em> </em>不需要在 <code>wordList</code> 中。</li>
<li><code>s<sub>k</sub> == endWord</code></li>
</ul>
<p>给你两个单词<em> </em><code>beginWord</code><em> </em>和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p>
 

<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
<strong>输出：</strong>5
<strong>解释：</strong>一个最短转换序列是 "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog", 返回它的长度 5。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
<strong>输出：</strong>0
<strong>解释：</strong>endWord "cog" 不在字典中，所以无法进行转换。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>
<li><code>endWord.length == beginWord.length</code></li>
<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>
<li><code>wordList[i].length == beginWord.length</code></li>
<li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li>
<li><code>beginWord != endWord</code></li>
<li><code>wordList</code> 中的所有字符串 <strong>互不相同</strong></li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">132. Palindrome Partitioning II</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>
<div class="original__bRMd">
<div>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "aab"
<strong>输出：</strong>1
<strong>解释：</strong>只需一次分割就可将 <em>s </em>分割成 ["aa","b"] 这样两个回文子串。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "a"
<strong>输出：</strong>0
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "ab"
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
</div>
</div>
</div></div></div><br><br><hr><br>**********<div id="title">135. Candy</div>
**********<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>ratings = [1,0,2]
<strong>输出：</strong>5
<strong>解释：</strong>你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>ratings = [1,2,2]
<strong>输出：</strong>4
<strong>解释：</strong>你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == ratings.length</code></li>
<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>0 &lt;= ratings[i] &lt;= 2 * 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">140. Word Break II</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串 <code>s</code> 和一个字符串字典 <code>wordDict</code> ，在字符串 <code>s</code> 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。<strong>以任意顺序</strong> 返回所有这些可能的句子。</p>
<p><strong>注意：</strong>词典中的同一个单词可能在分段中被重复使用多次。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入:</strong>s = "<code>catsanddog</code>", wordDict = <code>["cat","cats","and","sand","dog"]</code>
<strong>输出:</strong><code>["cats and dog","cat sand dog"]</code>
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入:</strong>s = "pineapplepenapple", wordDict = ["apple","pen","applepen","pine","pineapple"]
<strong>输出:</strong>["pine apple pen apple","pineapple pen apple","pine applepen apple"]
<strong>解释:</strong> 注意你可以重复使用字典中的单词。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入:</strong>s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
<strong>输出:</strong>[]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<p></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>
<li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li>
<li><code>wordDict</code> 中所有字符串都 <strong>不同</strong></li>
</ul>
</div></div></div><br><br><hr><br>*************************<div id="title">149. Max Points on a Line</div>
*************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg" style="width: 300px; height: 294px;"/>
<pre><strong>输入：</strong>points = [[1,1],[2,2],[3,3]]
<strong>输出：</strong>3
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg" style="width: 300px; height: 294px;"/>
<pre><strong>输入：</strong>points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
<strong>输出：</strong>4
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= points.length &lt;= 300</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
<li><code>points</code> 中的所有点 <strong>互不相同</strong></li>
</ul>
</div></div></div><br><br><hr><br>********************************************<div id="title">154. Find Minimum in Rotated Sorted Array II</div>
********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate">已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>你必须尽可能减少整个过程的操作步骤。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,3,5]
<strong>输出：</strong>1
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [2,2,2,0,1]
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>
</ul>
<p> </p>
<p><strong>进阶：</strong>这道题与 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a> 类似，但 <code>nums</code> 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</p>
</div></div></div><br><br><hr><br>****************<div id="title">164. Maximum Gap</div>
****************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个无序的数组 <code>nums</code>，返回 <em>数组在排序之后，相邻元素之间最大的差值</em> 。如果数组元素个数小于 2，则返回 <code>0</code> 。</p>
<p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> nums = [3,6,9,1]
<strong>输出:</strong> 3
<strong>解释:</strong> 排序后的数组是 [1,3,6,9]<strong><em>, </em></strong>其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> nums = [10]
<strong>输出:</strong> 0
<strong>解释:</strong> 数组元素个数小于 2，因此返回 0。</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************<div id="title">174. Dungeon Game</div>
*****************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一些恶魔抓住了公主（<strong>P</strong>）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（<strong>K</strong>）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为<em>负整数</em>，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 <em>0</em>），要么包含增加骑士健康点数的魔法球（若房间里的值为<em>正整数</em>，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p> </p>
<p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 <code>右 -&gt; 右 -&gt; 下 -&gt; 下</code>，则骑士的初始健康点数至少为 <strong>7</strong>。</p>
<table class="dungeon">
<tbody><tr>
<td>-2 (K)</td>
<td>-3</td>
<td>3</td>
</tr>
<tr>
<td>-5</td>
<td>-10</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>30</td>
<td>-5 (P)</td>
</tr>
</tbody></table>
<p> </p>
<p><strong>说明:</strong></p>
<ul>
<li>
<p>骑士的健康点数没有上限。</p>
</li>
<li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li>
</ul></div></div></div><br><br><hr><br>***************************************<div id="title">188. Best Time to Buy and Sell Stock IV</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个整数数组 <code>prices</code> ，它的第<em> </em><code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code><em> </em>天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>k = 2, prices = [2,4,1]
<strong>输出：</strong>2
<strong>解释：</strong>在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>k = 2, prices = [3,2,6,5,0,3]
<strong>输出：</strong>7
<strong>解释：</strong>在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= 100</code></li>
<li><code>0 &lt;= prices.length &lt;= 1000</code></li>
<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************<div id="title">212. Word Search II</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code><strong> </strong>和一个单词（字符串）列表 <code>words</code>， <em>返回所有二维网格上的单词</em> 。</p>
<p>单词必须按照字母顺序，通过 <strong>相邻的单元格</strong> 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg"/>
<pre><strong>输入：</strong>board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
<strong>输出：</strong>["eat","oath"]
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg"/>
<pre><strong>输入：</strong>board = [["a","b"],["c","d"]], words = ["abcb"]
<strong>输出：</strong>[]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == board.length</code></li>
<li><code>n == board[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 12</code></li>
<li><code>board[i][j]</code> 是一个小写英文字母</li>
<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
<li><code>words[i]</code> 由小写英文字母组成</li>
<li><code>words</code> 中的所有字符串互不相同</li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">214. Shortest Palindrome</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串 <em><strong>s</strong></em>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "aacecaaa"
<strong>输出：</strong>"aaacecaaa"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "abcd"
<strong>输出：</strong>"dcbabcd"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">218. The Skyline Problem</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>城市的 <strong>天际线</strong> 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 <em>由这些建筑物形成的<strong> 天际线</strong></em> 。</p>
<p>每个建筑物的几何信息由数组 <code>buildings</code> 表示，其中三元组 <code>buildings[i] = [lefti, righti, heighti]</code> 表示：</p>
<ul>
<li><code>left<sub>i</sub></code> 是第 <code>i</code> 座建筑物左边缘的 <code>x</code> 坐标。</li>
<li><code>right<sub>i</sub></code> 是第 <code>i</code> 座建筑物右边缘的 <code>x</code> 坐标。</li>
<li><code>height<sub>i</sub></code> 是第 <code>i</code> 座建筑物的高度。</li>
</ul>
<p>你可以假设所有的建筑都是完美的长方形，在高度为 <code>0</code> 的绝对平坦的表面上。</p>
<p><strong>天际线</strong> 应该表示为由 “关键点” 组成的列表，格式 <code>[[x<sub>1</sub>,y<sub>1</sub>],[x<sub>2</sub>,y<sub>2</sub>],...]</code> ，并按 <strong>x 坐标 </strong>进行 <strong>排序</strong> 。<strong>关键点是水平线段的左端点</strong>。列表中最后一个点是最右侧建筑物的终点，<code>y</code> 坐标始终为 <code>0</code> ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p><strong>注意：</strong>输出天际线中不得有连续的相同高度的水平线。例如 <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：<code>[...[2 3], [4 5], [12 7], ...]</code></p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg" style="height: 331px; width: 800px;"/>
<pre><strong>输入：</strong>buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
<strong>输出：</strong>[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
<strong>解释：</strong>
图 A<strong> </strong>显示输入的所有建筑物的位置和高度，
图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>buildings = [[0,2,3],[2,5,3]]
<strong>输出：</strong>[[0,3],[5,0]]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= buildings.length &lt;= 10<sup>4</sup></code></li>
<li><code>0 &lt;= left<sub>i</sub> &lt; right<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>
<li><code>1 &lt;= height<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>
<li><code>buildings</code> 按 <code>left<sub>i</sub></code> 非递减排序</li>
</ul>
</div></div></div><br><br><hr><br>***************************<div id="title">220. Contains Duplicate III</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在 <b>两个不同下标</b> <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code><em> </em>。</p>
<p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,3,1], k<em> </em>= 3, t = 0
<strong>输出：</strong>true</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,0,1,1], k<em> </em>=<em> </em>1, t = 2
<strong>输出：</strong>true</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [1,5,9,1,5,9], k = 2, t = 3
<strong>输出：</strong>false</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>
<li><code>0 &lt;= t &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div></div></div><br><br><hr><br>*********************<div id="title">224. Basic Calculator</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "1 + 1"
<strong>输出：</strong>2
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = " 2-1 + 2 "
<strong>输出：</strong>3
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "(1+(4+5+2)-3)+(6+8)"
<strong>输出：</strong>23
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>
<li><code>s</code> 由数字、<code>'+'</code>、<code>'-'</code>、<code>'('</code>、<code>')'</code>、和 <code>' '</code> 组成</li>
<li><code>s</code> 表示一个有效的表达式</li>
<li><font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">'+'</span></span></font></font> 不能用作一元运算(例如， <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">"+1"</span></span></font></font> 和 <code>"+(2 + 3)"</code> 无效)</li>
<li><font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">'-'</span></span></font></font> 可以用作一元运算(即 <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">"-1"</span></span></font></font> 和 <code>"-(2 + 3)"</code> 是有效的)</li>
<li>输入中不存在两个连续的操作符</li>
<li>每个数字和运行的计算将适合于一个有符号的 32位 整数</li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">233. Number of Digit One</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个整数 <code>n</code>，计算所有小于等于 <code>n</code> 的非负整数中数字 <code>1</code> 出现的个数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 13
<strong>输出：</strong>6
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 0
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***************************<div id="title">239. Sliding Window Maximum</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code><em> </em>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值 </em>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [1,3,-1,-3,5,3,6,7], k = 3
<b>输出：</b>[3,3,5,5,6,7]
<b>解释：</b>
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       <strong>3</strong>
 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>
 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>
 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>
 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>
 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [1], k = 1
<b>输出：</b>[1]
</pre>
<p> </p>
<p><b>提示：</b></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">273. Integer to English Words</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>将非负整数 <code>num</code> 转换为其对应的英文表示。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>num = 123
<strong>输出：</strong>"One Hundred Twenty Three"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>num = 12345
<strong>输出：</strong>"Twelve Thousand Three Hundred Forty Five"
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>num = 1234567
<strong>输出：</strong>"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">282. Expression Add Operators</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个仅包含数字 <code>0-9</code> 的字符串 <code>num</code> 和一个目标值整数 <code>target</code> ，在 <code>num</code> 的数字之间添加 <strong>二元 </strong>运算符（不是一元）<code>+</code>、<code>-</code> 或 <code>*</code> ，返回 <strong>所有</strong> 能够得到 <code>target </code>的表达式。</p>
<p>注意，返回表达式中的操作数 <strong>不应该</strong> 包含前导零。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> <code>num = </code>"123", target = 6
<strong>输出: </strong>["1+2+3", "1*2*3"] 
<strong>解释: </strong>“1*2*3” 和 “1+2+3” 的值都是6。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> <code>num = </code>"232", target = 8
<strong>输出: </strong>["2*3+2", "2+3*2"]
<strong>解释:</strong> “2*3+2” 和 “2+3*2” 的值都是8。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> <code>num = </code>"3456237490", target = 9191
<strong>输出: </strong>[]
<strong>解释: </strong>表达式 “3456237490” 无法得到 9191 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num.length &lt;= 10</code></li>
<li><code>num</code> 仅含数字</li>
<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">295. Find Median from Data Stream</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
<p><strong>示例：</strong></p>
<pre>addNum(1)
addNum(2)
findMedian() -&gt; 1.5
addNum(3) 
findMedian() -&gt; 2</pre>
<p><strong>进阶:</strong></p>
<ol>
<li>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</li>
<li>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</li>
</ol>
</div></div></div><br><br><hr><br>******************************************<div id="title">297. Serialize and Deserialize Binary Tree</div>
******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p><strong>提示: </strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="/faq/#binary-tree">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" style="width: 442px; height: 324px;"/>
<pre><strong>输入：</strong>root = [1,2,3,null,null,4,5]
<strong>输出：</strong>[1,2,3,null,null,4,5]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>root = [1]
<strong>输出：</strong>[1]
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>root = [1,2]
<strong>输出：</strong>[1,2]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">301. Remove Invalid Parentheses</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个由若干括号和字母组成的字符串 <code>s</code> ，删除最小数量的无效括号，使得输入的字符串有效。</p>
<p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "()())()"
<strong>输出：</strong>["(())()","()()()"]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "(a)())()"
<strong>输出：</strong>["(a())()","(a)()()"]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = ")("
<strong>输出：</strong>[""]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 25</code></li>
<li><code>s</code> 由小写英文字母以及括号 <code>'('</code> 和 <code>')'</code> 组成</li>
<li><code>s</code> 中至多含 <code>20</code> 个括号</li>
</ul>
</div></div></div><br><br><hr><br>*******************<div id="title">312. Burst Balloons</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p>
<p>现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得 <code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。 这里的 <code>i - 1</code> 和 <code>i + 1</code> 代表和 <code>i</code> 相邻的两个气球的序号。如果 <code>i - 1</code>或 <code>i + 1</code> 超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p> </p>
<strong>示例 1：</strong>
<pre><strong>输入：</strong>nums = [3,1,5,8]
<strong>输出：</strong>167
<strong>解释：</strong>
nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,5]
<strong>输出：</strong>10
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 300</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">315. Count of Smaller Numbers After Self</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code><em> </em>，按要求返回一个新数组 <code>counts</code><em> </em>。数组 <code>counts</code> 有该性质： <code>counts[i]</code> 的值是  <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [5,2,6,1]
<strong>输出：</strong><code>[2,1,1,0] 
<strong>解释：</strong></code>
5 的右侧有 <strong>2 </strong>个更小的元素 (2 和 1)
2 的右侧仅有 <strong>1 </strong>个更小的元素 (1)
6 的右侧有 <strong>1 </strong>个更小的元素 (1)
1 的右侧有 <strong>0 </strong>个更小的元素
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [-1]
<strong>输出：</strong>[0]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [-1,-1]
<strong>输出：</strong>[0,0]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">321. Create Maximum Number</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定长度分别为 <code>m</code> 和 <code>n</code> 的两个数组，其元素由 <code>0-9</code> 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 <code>k (k &lt;= m + n)</code> 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p>
<p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 <code>k</code> 的数组。</p>
<p><strong>说明: </strong>请尽可能地优化你算法的时间和空间复杂度。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
nums1 = <code>[3, 4, 6, 5]</code>
nums2 = <code>[9, 1, 2, 5, 8, 3]</code>
k = <code>5</code>
<strong>输出:</strong>
<code>[9, 8, 6, 5, 3]</code></pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
nums1 = <code>[6, 7]</code>
nums2 = <code>[6, 0, 4]</code>
k = <code>5</code>
<strong>输出:</strong>
<code>[6, 7, 6, 0, 4]</code></pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong>
nums1 = <code>[3, 9]</code>
nums2 = <code>[8, 9]</code>
k = <code>3</code>
<strong>输出:</strong>
<code>[9, 8, 9]</code></pre>
</div></div></div><br><br><hr><br>***********************<div id="title">327. Count of Range Sum</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 以及两个整数 <code>lower</code> 和 <code>upper</code> 。求数组中，值位于范围 <code>[lower, upper]</code> （包含 <code>lower</code> 和 <code>upper</code>）之内的 <strong>区间和的个数</strong> 。</p>
<p><strong>区间和</strong> <code>S(i, j)</code> 表示在 <code>nums</code> 中，位置从 <code>i</code> 到 <code>j</code> 的元素之和，包含 <code>i</code> 和 <code>j</code> (<code>i</code> ≤ <code>j</code>)。</p>
<p> </p>
<strong>示例 1：</strong>
<pre><strong>输入：</strong>nums = [-2,5,-1], lower = -2, upper = 2
<strong>输出：</strong>3
<strong>解释：</strong>存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [0], lower = 0, upper = 0
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
<li><code>-10<sup>5</sup> &lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code></li>
<li>题目数据保证答案是一个 <strong>32 位</strong> 的整数</li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">329. Longest Increasing Path in a Matrix</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" style="width: 242px; height: 242px;"/>
<pre><strong>输入：</strong>matrix = [[9,9,4],[6,6,8],[2,1,1]]
<strong>输出：</strong>4 
<strong>解释：</strong>最长递增路径为 <code>[1, 2, 6, 9]</code>。</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" style="width: 253px; height: 253px;"/>
<pre><strong>输入：</strong>matrix = [[3,4,5],[3,2,6],[2,2,1]]
<strong>输出：</strong>4 
<strong>解释：</strong>最长递增路径是 <code>[3, 4, 5, 6]</code>。注意不允许在对角线方向上移动。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>matrix = [[1]]
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************<div id="title">330. Patching Array</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个已排序的正整数数组 <code>nums</code> <em>，</em>和一个正整数 <code>n</code><em> 。</em>从 <code>[1, n]</code> 区间内选取任意个数字补充到 nums 中，使得 <code>[1, n]</code> 区间内的任何数字都可以用 nums 中某几个数字的和来表示。</p>
<p>请返回 <em>满足上述要求的最少需要补充的数字个数</em> 。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>nums = <code>[1,3]</code>, n = <code>6</code>
<strong>输出: </strong>1 
<strong>解释:</strong>
根据 nums 里现有的组合 <code>[1], [3], [1,3]</code>，可以得出 <code>1, 3, 4</code>。
现在如果我们将 <code>2</code> 添加到 nums 中， 组合变为: <code>[1], [2], [3], [1,3], [2,3], [1,2,3]</code>。
其和可以表示数字 <code>1, 2, 3, 4, 5, 6</code>，能够覆盖 <code>[1, 6]</code> 区间里所有的数。
所以我们最少需要添加一个数字。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入: </strong>nums = <code>[1,5,10]</code>, n = <code>20</code>
<strong>输出:</strong> 2
<strong>解释: </strong>我们需要添加 <code>[2,4]</code>。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入: </strong>nums = <code>[1,2,2]</code>, n = <code>5</code>
<strong>输出:</strong> 0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
<li><code>nums</code> 按 <strong>升序排列</strong></li>
<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">332. Reconstruct Itinerary</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<ul>
<li>例如，行程 <code>["JFK", "LGA"]</code> 与 <code>["JFK", "LGB"]</code> 相比就更小，排序更靠前。</li>
</ul>
<p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg" style="width: 382px; height: 222px;"/>
<pre><strong>输入：</strong>tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
<strong>输出：</strong>["JFK","MUC","LHR","SFO","SJC"]
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg" style="width: 222px; height: 230px;"/>
<pre><strong>输入：</strong>tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
<strong>输出：</strong>["JFK","ATL","JFK","SFO","ATL","SFO"]
<strong>解释：</strong>另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tickets.length &lt;= 300</code></li>
<li><code>tickets[i].length == 2</code></li>
<li><code>from<sub>i</sub>.length == 3</code></li>
<li><code>to<sub>i</sub>.length == 3</code></li>
<li><code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code> 由大写英文字母组成</li>
<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">335. Self Crossing</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>distance</code><em> </em>。</p>
<p>从 <strong>X-Y</strong> 平面上的点 <code>(0,0)</code> 开始，先向北移动 <code>distance[0]</code> 米，然后向西移动 <code>distance[1]</code> 米，向南移动 <code>distance[2]</code> 米，向东移动 <code>distance[3]</code> 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。</p>
<p>判断你所经过的路径是否相交。如果相交，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/selfcross1-plane.jpg" style="width: 400px; height: 435px;"/>
<pre><strong>输入：</strong>distance = [2,1,1,2]
<strong>输出：</strong>true
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/selfcross2-plane.jpg" style="width: 400px; height: 435px;"/>
<pre><strong>输入：</strong>distance = [1,2,3,4]
<strong>输出：</strong>false
</pre>
<p><strong>示例 3：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/14/selfcross3-plane.jpg" style="width: 400px; height: 435px;"/>
<pre><strong>输入：</strong>distance = [1,1,1,1]
<strong>输出：</strong>true</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= distance.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= distance[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*********************<div id="title">336. Palindrome Pairs</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一组<strong> 互不相同</strong> 的单词， 找出所有<strong> 不同<em> </em></strong>的索引对 <code>(i, j)</code>，使得列表中的两个单词， <code>words[i] + words[j]</code> ，可拼接成回文串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>words = ["abcd","dcba","lls","s","sssll"]
<strong>输出：</strong>[[0,1],[1,0],[3,2],[2,4]] 
<strong>解释：</strong>可拼接成的回文串为 <code>["dcbaabcd","abcddcba","slls","llssssll"]</code>
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>words = ["bat","tab","cat"]
<strong>输出：</strong>[[0,1],[1,0]] 
<strong>解释：</strong>可拼接成的回文串为 <code>["battab","tabbat"]</code></pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>words = ["a",""]
<strong>输出：</strong>[[0,1],[1,0]]
</pre>
 

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 5000</code></li>
<li><code>0 &lt;= words[i].length &lt;= 300</code></li>
<li><code>words[i]</code> 由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">352. Data Stream as Disjoint Intervals</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p> 给你一个由非负整数 <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code> 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。</p>
<p>实现 <code>SummaryRanges</code> 类：</p>
<div class="original__bRMd">
<div>
<ul>
<li><code>SummaryRanges()</code> 使用一个空数据流初始化对象。</li>
<li><code>void addNum(int val)</code> 向数据流中加入整数 <code>val</code> 。</li>
<li><code>int[][] getIntervals()</code> 以不相交区间 <code>[start<sub>i</sub>, end<sub>i</sub>]</code> 的列表形式返回对数据流中整数的总结。</li>
</ul>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>
["SummaryRanges", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals", "addNum", "getIntervals"]
[[], [1], [], [3], [], [7], [], [2], [], [6], []]
<strong>输出：</strong>
[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]

<strong>解释：</strong>
SummaryRanges summaryRanges = new SummaryRanges();
summaryRanges.addNum(1);      // arr = [1]
summaryRanges.getIntervals(); // 返回 [[1, 1]]
summaryRanges.addNum(3);      // arr = [1, 3]
summaryRanges.getIntervals(); // 返回 [[1, 1], [3, 3]]
summaryRanges.addNum(7);      // arr = [1, 3, 7]
summaryRanges.getIntervals(); // 返回 [[1, 1], [3, 3], [7, 7]]
summaryRanges.addNum(2);      // arr = [1, 2, 3, 7]
summaryRanges.getIntervals(); // 返回 [[1, 3], [7, 7]]
summaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]
summaryRanges.getIntervals(); // 返回 [[1, 3], [6, 7]]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= val &lt;= 10<sup>4</sup></code></li>
<li>最多调用 <code>addNum</code> 和 <code>getIntervals</code> 方法 <code>3 * 10<sup>4</sup></code> 次</li>
</ul>
</div>
</div>
<p> </p>
<p><strong>进阶：</strong>如果存在大量合并，并且与数据流的大小相比，不相交区间的数量很小，该怎么办?</p>
</div></div></div><br><br><hr><br>***************************<div id="title">354. Russian Doll Envelopes</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个二维整数数组 <code>envelopes</code> ，其中 <code>envelopes[i] = [w<sub>i</sub>, h<sub>i</sub>]</code> ，表示第 <code>i</code> 个信封的宽度和高度。</p>
<p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<p><strong>注意</strong>：不允许旋转信封。</p>
 

<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>envelopes = [[5,4],[6,4],[6,7],[2,3]]
<strong>输出：</strong>3
<strong>解释：</strong>最多信封的个数为 <code>3, 组合为: </code>[2,3] =&gt; [5,4] =&gt; [6,7]。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>envelopes = [[1,1],[1,1],[1,1]]
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= envelopes.length &lt;= 10<sup>5</sup></code></li>
<li><code>envelopes[i].length == 2</code></li>
<li><code>1 &lt;= w<sub>i</sub>, h<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>******************************************<div id="title">363. Max Sum of Rectangle No Larger Than K</div>
******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，找出并返回矩阵内部矩形区域的不超过 <code>k</code> 的最大数值和。</p>
<p>题目数据保证总会存在一个数值和不超过 <code>k</code> 的矩形区域。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg" style="width: 255px; height: 176px;"/>
<pre><strong>输入：</strong>matrix = [[1,0,1],[0,-2,3]], k = 2
<strong>输出：</strong>2
<strong>解释：</strong>蓝色边框圈出来的矩形区域 <code>[[0, 1], [-2, 3]]</code> 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>matrix = [[2,2,-1]], k = 3
<strong>输出：</strong>3
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
<li><code>-10<sup>5</sup> &lt;= k &lt;= 10<sup>5</sup></code></li>
</ul>
<p> </p>
<p><strong>进阶：</strong>如果行数远大于列数，该如何设计解决方案？</p>
</div></div></div><br><br><hr><br>******************************************************<div id="title">381. Insert Delete GetRandom O(1) - Duplicates allowed</div>
******************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><code>RandomizedCollection</code> 是一种包含数字集合(可能是重复的)的数据结构。它应该支持插入和删除特定元素，以及删除随机元素。</p>
<p>实现 <code>RandomizedCollection</code> 类:</p>
<ul>
<li><code>RandomizedCollection()</code>初始化空的 <code>RandomizedCollection</code> 对象。</li>
<li><code>bool insert(int val)</code> 将一个 <code>val</code> 项插入到集合中，即使该项已经存在。如果该项不存在，则返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
<li><code>bool remove(int val)</code> 如果存在，从集合中移除一个 <code>val</code> 项。如果该项存在，则返回 <code>true</code> ，否则返回 <code>false</code> 。注意，如果 <code>val</code> 在集合中出现多次，我们只删除其中一个。</li>
<li><code>int getRandom()</code> 从当前的多个元素集合中返回一个随机元素。每个元素被返回的概率与集合中包含的相同值的数量 <strong>线性相关</strong> 。</li>
</ul>
<p>您必须实现类的函数，使每个函数的 <strong>平均</strong> 时间复杂度为 <code>O(1)</code> 。</p>
<p><strong>注意：</strong>生成测试用例时，只有在 <code>RandomizedCollection</code> 中 <strong>至少有一项</strong> 时，才会调用 <code>getRandom</code> 。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入</strong>
["RandomizedCollection", "insert", "insert", "insert", "getRandom", "remove", "getRandom"]
[[], [1], [1], [2], [], [1], []]
<strong>输出</strong>
[null, true, false, true, 2, true, 1]

<strong>解释</strong>
RandomizedCollection collection = new RandomizedCollection();// 初始化一个空的集合。
collection.insert(1);// 向集合中插入 1 。返回 true 表示集合不包含 1 。
collection.insert(1);// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。
collection.insert(2);// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。
collection.getRandom();// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。
collection.remove(1);// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。
collection.getRandom();// getRandom 应有相同概率返回 1 和 2 。
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>
<li><code>insert</code>, <code>remove</code> 和 <code>getRandom</code> 最多 <strong>总共</strong> 被调用 <code>2 * 10<sup>5</sup></code> 次</li>
<li>当调用 <code>getRandom</code> 时，数据结构中 <strong>至少有一个</strong> 元素</li>
</ul>
</div></div></div><br><br><hr><br>**********************<div id="title">391. Perfect Rectangle</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub>]</code> 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> ，右上顶点是 <code>(a<sub>i</sub>, b<sub>i</sub>)</code> 。</p>
<p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
 

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/27/perectrec1-plane.jpg" style="height: 294px; width: 300px;"/>
<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]
<strong>输出：</strong>true
<strong>解释：</strong>5 个矩形一起可以精确地覆盖一个矩形区域。 
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/27/perfectrec2-plane.jpg" style="height: 294px; width: 300px;"/>
<pre><strong>输入：</strong>rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]
<strong>输出：</strong>false
<strong>解释：</strong>两个矩形之间有间隔，无法覆盖成一个矩形。</pre>
<p><strong>示例 3：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/03/27/perfecrrec4-plane.jpg" style="height: 294px; width: 300px;"/>
<pre><strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]
<strong>输出：</strong>false
<strong>解释：</strong>因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= rectangles.length &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>rectangles[i].length == 4</code></li>
<li><code>-10<sup>5</sup> &lt;= x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************<div id="title">403. Frog Jump</div>
**************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p>
<p>给你石子的位置列表 <code>stones</code>（用单元格序号 <strong>升序</strong> 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 <code>1</code> 个单位（即只能从单元格 1 跳至单元格 2 ）。</p>
<p>如果青蛙上一步跳跃了 <code>k</code><em> </em>个单位，那么它接下来的跳跃距离只能选择为 <code>k - 1</code>、<code>k</code><em> </em>或 <code>k + 1</code> 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>stones = [0,1,3,5,6,8,12,17]
<strong>输出：</strong>true
<strong>解释：</strong>青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>stones = [0,1,2,3,4,8,9,11]
<strong>输出：</strong>false
<strong>解释：</strong>这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= stones.length &lt;= 2000</code></li>
<li><code>0 &lt;= stones[i] &lt;= 2<sup>31</sup> - 1</code></li>
<li><code>stones[0] == 0</code></li>
<li><code>stones</code> 按严格升序排列</li>
</ul>
</div></div></div><br><br><hr><br>***************************<div id="title">407. Trapping Rain Water II</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m x n</code> 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg"/></p>
<pre><strong>输入:</strong> heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
<strong>输出:</strong> 4
<strong>解释:</strong> 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。
</pre>
<p><strong>示例 2:</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg"/></p>
<pre><strong>输入:</strong> heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
<strong>输出:</strong> 10
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>m == heightMap.length</code></li>
<li><code>n == heightMap[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code></li>
</ul>
<p> </p>
</div></div></div><br><br><hr><br>****************************<div id="title">410. Split Array Largest Sum</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个非负整数数组 <code>nums</code> 和一个整数 <code>m</code> ，你需要将这个数组分成 <code>m</code><em> </em>个非空的连续子数组。</p>
<p>设计一个算法使得这 <code>m</code><em> </em>个子数组各自和的最大值最小。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [7,2,5,10,8], m = 2
<strong>输出：</strong>18
<strong>解释：</strong>
一共有四种方法将 nums 分割为 2 个子数组。 
其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,3,4,5], m = 2
<strong>输出：</strong>9
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [1,4,4], m = 3
<strong>输出：</strong>4
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
<li><code>1 &lt;= m &lt;= min(50, nums.length)</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************<div id="title">420. Strong Password Checker</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p> </p>
如果一个密码满足下述所有条件，则认为这个密码是强密码：

<ul>
<li>由至少 <code>6</code> 个，至多 <code>20</code> 个字符组成。</li>
<li>至少包含 <strong>一个小写 </strong>字母，<strong>一个大写</strong> 字母，和 <strong>一个数字</strong> 。</li>
<li>同一字符 <strong>不能 </strong>连续出现三次 (比如 <code>"...aaa..."</code> 是不允许的, 但是 <code>"...aa...a..."</code> 如果满足其他条件也可以算是强密码)。</li>
</ul>
<p>给你一个字符串 <code>password</code> ，返回 <em>将 <code>password</code> 修改到满足强密码条件需要的最少修改步数。如果 <code>password</code> 已经是强密码，则返回 <code>0</code> 。</em></p>
<p>在一步修改操作中，你可以：</p>
<ul>
<li>插入一个字符到 <code>password</code> ，</li>
<li>从 <code>password</code> 中删除一个字符，或</li>
<li>用另一个字符来替换 <code>password</code> 中的某个字符。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>password = "a"
<strong>输出：</strong>5
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>password = "aA1"
<strong>输出：</strong>3
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>password = "1337C0d3"
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= password.length &lt;= 50</code></li>
<li><code>password</code> 由字母、数字、点 <code>'.'</code> 或者感叹号 <code>'!'</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">432. All O`one Data Structure</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。</p>
<p>实现 <code>AllOne</code> 类：</p>
<ul>
<li><code>AllOne()</code> 初始化数据结构的对象。</li>
<li><code>inc(String key)</code> 字符串 <code>key</code> 的计数增加 <code>1</code> 。如果数据结构中尚不存在 <code>key</code> ，那么插入计数为 <code>1</code> 的 <code>key</code> 。</li>
<li><code>dec(String key)</code> 字符串 <code>key</code> 的计数减少 <code>1</code> 。如果 <code>key</code> 的计数在减少后为 <code>0</code> ，那么需要将这个 <code>key</code> 从数据结构中删除。测试用例保证：在减少计数前，<code>key</code> 存在于数据结构中。</li>
<li><code>getMaxKey()</code> 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 <code>""</code> 。</li>
<li><code>getMinKey()</code> 返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串 <code>""</code> 。</li>
</ul>
<p><strong>注意：</strong>每个函数都应当满足 <code>O(1)</code> 平均时间复杂度。</p>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入</strong>
["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
[[], ["hello"], ["hello"], [], [], ["leet"], [], []]
<strong>输出</strong>
[null, null, null, "hello", "hello", null, "hello", "leet"]

<strong>解释</strong>
AllOne allOne = new AllOne();
allOne.inc("hello");
allOne.inc("hello");
allOne.getMaxKey(); // 返回 "hello"
allOne.getMinKey(); // 返回 "hello"
allOne.inc("leet");
allOne.getMaxKey(); // 返回 "hello"
allOne.getMinKey(); // 返回 "leet"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= key.length &lt;= 10</code></li>
<li><code>key</code> 由小写英文字母组成</li>
<li>测试用例保证：在每次调用 <code>dec</code> 时，数据结构中总存在 <code>key</code></li>
<li>最多调用 <code>inc</code>、<code>dec</code>、<code>getMaxKey</code> 和 <code>getMinKey</code> 方法 <code>5 * 10<sup>4</sup></code> 次</li>
</ul>
</div></div></div><br><br><hr><br>*******************************************<div id="title">440. K-th Smallest in Lexicographical Order</div>
*******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定整数 <code>n</code> 和 <code>k</code>，返回  <code>[1, n]</code> 中字典序第 <code>k</code> 小的数字。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>n = 13, k = 2
<strong>输出: </strong>10
<strong>解释: </strong>字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> n = 1, k = 1
<strong>输出:</strong> 1
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***************************************<div id="title">446. Arithmetic Slices II - Subsequence</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中所有 <strong>等差子序列</strong> 的数目。</p>
<p>如果一个序列中 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该序列为等差序列。</p>
<ul>
<li>例如，<code>[1, 3, 5, 7, 9]</code>、<code>[7, 7, 7, 7]</code> 和 <code>[3, -1, -5, -9]</code> 都是等差序列。</li>
<li>再例如，<code>[1, 1, 2, 5, 7]</code> 不是等差序列。</li>
</ul>
<p>数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。</p>
<ul>
<li>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,<em><strong>2</strong></em>,4,1,<strong><em>5</em></strong>,<em><strong>10</strong></em>]</code> 的一个子序列。</li>
</ul>
<p>题目数据保证答案是一个 <strong>32-bit</strong> 整数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [2,4,6,8,10]
<strong>输出：</strong>7
<strong>解释：</strong>所有的等差子序列为：
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [7,7,7,7,7]
<strong>输出：</strong>16
<strong>解释：</strong>数组中的任意子序列都是等差子序列。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1  &lt;= nums.length &lt;= 1000</code></li>
<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div></div></div><br><br><hr><br>**************<div id="title">458. Poor Pigs</div>
**************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有<code> buckets</code> 桶液体，其中 <strong>正好有一桶</strong> 含有毒药，其余装的都是水。它们从外观看起来都一样。为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，你只有 <code>minutesToTest</code> 分钟时间来确定哪桶液体是有毒的。</p>
<p>喂猪的规则如下：</p>
<ol>
<li>选择若干活猪进行喂养</li>
<li>可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。</li>
<li>小猪喝完水后，必须有 <code>minutesToDie</code> 分钟的冷却时间。在这段时间里，你只能观察，而不允许继续喂猪。</li>
<li>过了 <code>minutesToDie</code> 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。</li>
<li>重复这一过程，直到时间用完。</li>
</ol>
<p>给你桶的数目 <code>buckets</code> ，<code>minutesToDie</code> 和 <code>minutesToTest</code> ，返回 <em>在规定时间内判断哪个桶有毒所需的 <strong>最小</strong> 猪数</em> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>buckets = 1000, minutesToDie = 15, minutesToTest = 60
<strong>输出：</strong>5
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>buckets = 4, minutesToDie = 15, minutesToTest = 15
<strong>输出：</strong>2
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>buckets = 4, minutesToDie = 15, minutesToTest = 30
<strong>输出：</strong>2
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= buckets &lt;= 1000</code></li>
<li><code>1 &lt;= minutesToDie &lt;= minutesToTest &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>**************<div id="title">460. LFU Cache</div>
**************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>请你为 <a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。</p>
<p>实现 <code>LFUCache</code> 类：</p>
<ul>
<li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li>
<li><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。</li>
</ul>
<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。</p>
<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>
["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
<strong>输出：</strong>
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

<strong>解释：</strong>
// cnt(x) = 键 x 的使用计数
// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // 返回 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小
                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // 返回 -1（未找到）
lfu.get(3);      // 返回 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // 返回 -1（未找到）
lfu.get(3);      // 返回 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // 返回 4
                 // cache=[3,4], cnt(4)=2, cnt(3)=3</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= capacity &lt;= 10<sup>4</sup></code></li>
<li><code>0 &lt;= key &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>
<li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code> 方法</li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">466. Count The Repetitions</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>定义 <code>str = [s, n]</code> 表示 <code>str</code> 由 <code>n</code> 个字符串 <code>s</code> 连接构成。</p>
<ul>
<li>例如，<code>str == ["abc", 3] =="abcabcabc"</code> 。</li>
</ul>
<p>如果可以从 <code>s2</code><sub> </sub>中删除某些字符使其变为 <code>s1</code>，则称字符串 <code>s1</code><sub> </sub>可以从字符串 <code>s2</code> 获得。</p>
<ul>
<li>例如，根据定义，<code>s1 = "abc"</code> 可以从 <code>s2 = "ab<em><strong>dbe</strong></em>c"</code> 获得，仅需要删除加粗且用斜体标识的字符。</li>
</ul>
<p>现在给你两个字符串 <code>s1</code> 和 <code>s2</code> 和两个整数 <code>n1</code> 和 <code>n2</code> 。由此构造得到两个字符串，其中 <code>str1 = [s1, n1]</code>、<code>str2 = [s2, n2]</code> 。</p>
<p>请你找出一个最大整数 <code>m</code> ，以满足 <code>str = [str2, m]</code> 可以从 <code>str1</code> 获得。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s1 = "acb", n1 = 4, s2 = "ab", n2 = 2
<strong>输出：</strong>2
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s1 = "acb", n1 = 1, s2 = "acb", n2 = 1
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li>
<li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li>
<li><code>1 &lt;= n1, n2 &lt;= 10<sup>6</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***********************<div id="title">472. Concatenated Words</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <strong>不含重复 </strong>单词的字符串数组 <code>words</code> ，请你找出并返回 <code>words</code> 中的所有 <strong>连接词</strong> 。</p>
<p><strong>连接词</strong> 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
<strong>输出：</strong>["catsdogcats","dogcatsdog","ratcatdogcat"]
<strong>解释：</strong>"catsdogcats" 由 "cats", "dog" 和 "cats" 组成; 
     "dogcatsdog" 由 "dog", "cats" 和 "dog" 组成; 
     "ratcatdogcat" 由 "rat", "cat", "dog" 和 "cat" 组成。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>words = ["cat","dog","catdog"]
<strong>输出：</strong>["catdog"]</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>
<li><code>0 &lt;= words[i].length &lt;= 30</code></li>
<li><code>words[i]</code> 仅由小写字母组成</li>
<li><code>0 &lt;= sum(words[i].length) &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">479. Largest Palindrome Product</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个整数 n ，返回 <em>可表示为两个 <code>n</code> 位整数乘积的 <strong>最大回文整数</strong></em> 。因为答案可能非常大，所以返回它对 <code>1337</code> <strong>取余</strong> 。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><b>输入：</b>n = 2
<b>输出：</b>987
<strong>解释：</strong>99 x 91 = 9009, 9009 % 1337 = 987
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入：</strong> n = 1
<strong>输出：</strong> 9
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">480. Sliding Window Median</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p>
<p>例如：</p>
<ul>
<li><code>[2,3,4]</code>，中位数是 <code>3</code></li>
<li><code>[2,3]</code>，中位数是 <code>(2 + 3) / 2 = 2.5</code></li>
</ul>
<p>给你一个数组 <em>nums</em>，有一个长度为 <em>k</em> 的窗口从最左端滑动到最右端。窗口中有 <em>k</em> 个数，每次窗口向右移动 <em>1</em> 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p>
<p> </p>
<p><strong>示例：</strong></p>
<p>给出 <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>，以及 <em>k</em> = 3。</p>
<pre>窗口位置                      中位数
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
</pre>
<p> 因此，返回该滑动窗口的中位数数组 <code>[1,-1,-1,3,5,6]</code>。</p>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li>你可以假设 <code>k</code> 始终有效，即：<code>k</code> 始终小于等于输入的非空数组的元素个数。</li>
<li>与真实值误差在 <code>10 ^ -5</code> 以内的答案将被视作正确答案。</li>
</ul>
</div></div></div><br><br><hr><br>***********************<div id="title">483. Smallest Good Base</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>以字符串的形式给出 <code>n</code> , 以字符串的形式返回<em> <code>n</code> 的最小 <strong>好进制</strong> </em> 。</p>
<p>如果 <code>n</code> 的  <code>k(k&gt;=2)</code> 进制数的所有数位全为1，则称 <code>k(k&gt;=2)</code> 是 <code>n</code> 的一个 <strong>好进制 </strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = "13"
<strong>输出：</strong>"3"
<strong>解释：</strong>13 的 3 进制是 111。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = "4681"
<strong>输出：</strong>"8"
<strong>解释：</strong>4681 的 8 进制是 11111。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = "1000000000000000000"
<strong>输出：</strong>"999999999999999999"
<strong>解释：</strong>1000000000000000000 的 999999999999999999 进制是 11。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n</code> 的取值范围是 <code>[3, 10<sup>18</sup>]</code></li>
<li><code>n</code> 没有前导 0</li>
</ul>
</div></div></div><br><br><hr><br>**************<div id="title">488. Zuma Game</div>
**************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你正在参与祖玛游戏的一个变种。</p>
<p>在这个祖玛游戏变体中，桌面上有 <strong>一排</strong> 彩球，每个球的颜色可能是：红色 <code>'R'</code>、黄色 <code>'Y'</code>、蓝色 <code>'B'</code>、绿色 <code>'G'</code> 或白色 <code>'W'</code> 。你的手中也有一些彩球。</p>
<p>你的目标是 <strong>清空</strong> 桌面上所有的球。每一回合：</p>
<ul>
<li>从你手上的彩球中选出 <strong>任意一颗</strong> ，然后将其插入桌面上那一排球中：两球之间或这一排球的任一端。</li>
<li>接着，如果有出现 <strong>三个或者三个以上</strong> 且 <strong>颜色相同</strong> 的球相连的话，就把它们移除掉。
	<ul>
<li>如果这种移除操作同样导致出现三个或者三个以上且颜色相同的球相连，则可以继续移除这些球，直到不再满足移除条件。</li>
</ul>
</li>
<li>如果桌面上所有球都被移除，则认为你赢得本场游戏。</li>
<li>重复这个过程，直到你赢了游戏或者手中没有更多的球。</li>
</ul>
<p>给你一个字符串 <code>board</code> ，表示桌面上最开始的那排球。另给你一个字符串 <code>hand</code> ，表示手里的彩球。请你按上述操作步骤移除掉桌上所有球，计算并返回所需的 <strong>最少</strong> 球数。如果不能移除桌上所有的球，返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>board = "WRRBBW", hand = "RB"
<strong>输出：</strong>-1
<strong>解释：</strong>无法移除桌面上的所有球。可以得到的最好局面是：
- 插入一个 'R' ，使桌面变为 WRR<em><strong>R</strong></em>BBW 。W<em><strong>RRR</strong></em>BBW -&gt; WBBW
- 插入一个 'B' ，使桌面变为 WBB<em><strong>B</strong></em>W 。W<em><strong>BBB</strong></em>W -&gt; WW
桌面上还剩着球，没有其他球可以插入。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>board = "WWRRBBWW", hand = "WRBRW"
<strong>输出：</strong>2
<strong>解释：</strong>要想清空桌面上的球，可以按下述步骤：
- 插入一个 'R' ，使桌面变为 WWRR<strong><em>R</em></strong>BBWW 。WW<em><strong>RRR</strong></em>BBWW -&gt; WWBBWW
- 插入一个 'B' ，使桌面变为 WWBB<em><strong>B</strong></em>WW 。WW<em><strong>BBB</strong></em>WW -&gt; <em><strong>WWWW</strong></em> -&gt; empty
只需从手中出 2 个球就可以清空桌面。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>board = "G", hand = "GGGGG"
<strong>输出：</strong>2
<strong>解释：</strong>要想清空桌面上的球，可以按下述步骤：
- 插入一个 'G' ，使桌面变为 G<em><strong>G</strong></em> 。
- 插入一个 'G' ，使桌面变为 GG<em><strong>G</strong></em> 。<em><strong>GGG</strong></em> -&gt; empty
只需从手中出 2 个球就可以清空桌面。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>board = "RBYYBBRRB", hand = "YRBGB"
<strong>输出：</strong>3
<strong>解释：</strong>要想清空桌面上的球，可以按下述步骤：
- 插入一个 'Y' ，使桌面变为 RBYY<em><strong>Y</strong></em>BBRRB 。RB<em><strong>YYY</strong></em>BBRRB -&gt; R<em><strong>BBB</strong></em>RRB -&gt; <em><strong>RRR</strong></em>B -&gt; B
- 插入一个 'B' ，使桌面变为 B<em><strong>B</strong></em> 。
- 插入一个 'B' ，使桌面变为 BB<em><strong>B</strong></em> 。<em><strong>BBB</strong></em> -&gt; empty
只需从手中出 3 个球就可以清空桌面。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= board.length &lt;= 16</code></li>
<li><code>1 &lt;= hand.length &lt;= 5</code></li>
<li><code>board</code> 和 <code>hand</code> 由字符 <code>'R'</code>、<code>'Y'</code>、<code>'B'</code>、<code>'G'</code> 和 <code>'W'</code> 组成</li>
<li>桌面上一开始的球中，不会有三个及三个以上颜色相同且连着的球</li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">493. Reverse Pairs</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个数组 <code>nums</code> ，如果 <code>i &lt; j</code> 且 <code>nums[i] &gt; 2*nums[j]</code> 我们就将 <code>(i, j)</code> 称作一个<strong><em>重要翻转对</em></strong>。</p>
<p>你需要返回给定数组中的重要翻转对的数量。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入</strong>: [1,3,2,3,1]
<strong>输出</strong>: 2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入</strong>: [2,4,3,5,1]
<strong>输出</strong>: 3
</pre>
<p><strong>注意:</strong></p>
<ol>
<li>给定数组的长度不会超过<code>50000</code>。</li>
<li>输入数组中的所有数字都在32位整数的表示范围内。</li>
</ol>
</div></div></div><br><br><hr><br>********<div id="title">502. IPO</div>
********<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>假设 力扣（LeetCode）即将开始 <strong>IPO</strong> 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 <code>k</code> 个不同的项目。帮助 力扣 设计完成最多 <code>k</code> 个不同项目后得到最大总资本的方式。</p>
<p>给你 <code>n</code> 个项目。对于每个项目 <code>i</code><strong> </strong>，它都有一个纯利润 <code>profits[i]</code> ，和启动该项目需要的最小资本 <code>capital[i]</code> 。</p>
<p>最初，你的资本为 <code>w</code> 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p>
<p>总而言之，从给定项目中选择 <strong>最多</strong> <code>k</code> 个不同项目的列表，以 <strong>最大化最终资本</strong> ，并输出最终可获得的最多资本。</p>
<p>答案保证在 32 位有符号整数范围内。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
<strong>输出：</strong>4
<strong>解释：
</strong>由于你的初始资本为 0，你仅可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
<strong>输出：</strong>6
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= w &lt;= 10<sup>9</sup></code></li>
<li><code>n == profits.length</code></li>
<li><code>n == capital.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= profits[i] &lt;= 10<sup>4</sup></code></li>
<li><code>0 &lt;= capital[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">514. Freedom Trail</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>电子游戏“辐射4”中，任务 <strong>“通向自由”</strong> 要求玩家到达名为 “<strong>Freedom Trail Ring”</strong> 的金属表盘，并使用表盘拼写特定关键词才能开门。</p>
<p>给定一个字符串 <code>ring</code> ，表示刻在外环上的编码；给定另一个字符串 <code>key</code> ，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的<strong>最少</strong>步数。</p>
<p>最初，<strong>ring </strong>的第一个字符与 <code>12:00</code> 方向对齐。您需要顺时针或逆时针旋转 <code>ring</code> 以使 <strong>key </strong>的一个字符在 <code>12:00</code> 方向对齐，然后按下中心按钮，以此逐个拼写完 <strong><code>key</code> </strong>中的所有字符。</p>
<p>旋转 <code>ring</code><strong> </strong>拼出 key 字符 <code>key[i]</code><strong> </strong>的阶段中：</p>
<ol>
<li>您可以将 <strong>ring </strong>顺时针或逆时针旋转 <strong>一个位置 </strong>，计为1步。旋转的最终目的是将字符串 <strong><code>ring</code> </strong>的一个字符与 <code>12:00</code> 方向对齐，并且这个字符必须等于字符 <strong><code>key[i]</code> 。</strong></li>
<li>如果字符 <strong><code>key[i]</code> </strong>已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 <strong>1 步</strong>。按完之后，您可以开始拼写 <strong>key </strong>的下一个字符（下一阶段）, 直至完成所有拼写。</li>
</ol>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/ring.jpg" style="height: 450px; width: 450px;"/></p>
<center> </center>
<pre><strong>输入:</strong> ring = "godding", key = "gd"
<strong>输出:</strong> 4
<strong>解释:</strong>
 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 
 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring "godding" 2步使它变成 "ddinggo"。
 当然, 我们还需要1步进行拼写。
 因此最终的输出是 4。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> ring = "godding", key = "godding"
<strong>输出:</strong> 13
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= ring.length, key.length &lt;= 100</code></li>
<li><code>ring</code> 和 <code>key</code> 只包含小写英文字母</li>
<li><strong>保证</strong> 字符串 <code>key</code> 一定可以由字符串  <code>ring</code> 旋转拼出</li>
</ul>
</div></div></div><br><br><hr><br>***************************<div id="title">517. Super Washing Machines</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>假设有 <code>n</code><strong> </strong>台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。</p>
<p>在每一步操作中，你可以选择任意 <code>m</code> (<code>1 &lt;= m &lt;= n</code>) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。</p>
<p>给定一个整数数组 <code>machines</code> 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 <strong>最少的操作步数 </strong>。如果不能使每台洗衣机中衣物的数量相等，则返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>machines = [1,0,5]
<strong>输出：</strong>3
<strong>解释：</strong>
第一步:    1     0 &lt;-- 5    =&gt;    1     1     4
第二步:    1 &lt;-- 1 &lt;-- 4    =&gt;    2     1     3    
第三步:    2     1 &lt;-- 3    =&gt;    2     2     2   
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>machines = [0,3,0]
<strong>输出：</strong>2
<strong>解释：</strong>
第一步:    0 &lt;-- 3     0    =&gt;    1     2     0    
第二步:    1     2 --&gt; 0    =&gt;    1     1     1     
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>machines = [0,2,0]
<strong>输出：</strong>-1
<strong>解释：</strong>
不可能让所有三个洗衣机同时剩下相同数量的衣物。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == machines.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
<li><code>0 &lt;= machines[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************<div id="title">546. Remove Boxes</div>
*****************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给出一些不同颜色的盒子 <code>boxes</code> ，盒子的颜色由不同的正数表示。</p>
<p>你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 <code>k</code> 个盒子（<code>k &gt;= 1</code>），这样一轮之后你将得到 <code>k * k</code> 个积分。</p>
<p>返回 <em>你能获得的最大积分和</em> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>boxes = [1,3,2,2,2,3,4,3,1]
<strong>输出：</strong>23
<strong>解释：</strong>
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 分) 
----&gt; [1, 3, 3, 3, 1] (1*1=1 分) 
----&gt; [1, 1] (3*3=9 分) 
----&gt; [] (2*2=4 分)
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>boxes = [1,1,1]
<strong>输出：</strong>9
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>boxes = [1]
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= boxes.length &lt;= 100</code></li>
<li><code>1 &lt;= boxes[i] &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">552. Student Attendance Record II</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate">可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
<ul>
<li><code>'A'</code>：Absent，缺勤</li>
<li><code>'L'</code>：Late，迟到</li>
<li><code>'P'</code>：Present，到场</li>
</ul>
<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>
<ul>
<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>
<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>
</ul>
<p>给你一个整数 <code>n</code> ，表示出勤记录的长度（次数）。请你返回记录长度为 <code>n</code> 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>8
<strong>解释：
</strong>有 8 种长度为 2 的记录将被视为可奖励：
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" 
只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>3
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 10101
<strong>输出：</strong>183236316
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>********************************<div id="title">564. Find the Closest Palindrome</div>
********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个表示整数的字符串 <code>n</code> ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。</p>
<p>“最近的”定义为两个整数<strong>差的绝对值</strong>最小。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> n = "123"
<strong>输出:</strong> "121"
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> n = "1"
<strong>输出:</strong> "0"
<strong>解释:</strong> 0 和 2是最近的回文，但我们返回最小的，也就是 0。
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= n.length &lt;= 18</code></li>
<li><code>n</code> 只由数字组成</li>
<li><code>n</code> 不含前导 0</li>
<li><code>n</code> 代表在 <code>[1, 10<sup>18</sup> - 1]</code> 范围内的整数</li>
</ul>
</div></div></div><br><br><hr><br>********************<div id="title">587. Erect the Fence</div>
********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用<strong>最短</strong>的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]
<strong>输出:</strong> [[1,1],[2,0],[4,2],[3,3],[2,4]]
<strong>解释:</strong>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/erect_the_fence_1.png" style="width: 100%; max-width: 320px"/>
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [[1,2],[2,2],[4,2]]
<strong>输出:</strong> [[1,2],[2,2],[4,2]]
<strong>解释:</strong>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/erect_the_fence_2.png" style="width: 100%; max-width: 320px"/>
即使树都在一条直线上，你也需要先用绳子包围它们。
</pre>
<p> </p>
<p><strong>注意:</strong></p>
<ol>
<li>所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。</li>
<li>输入的整数在 0 到 100 之间。</li>
<li>花园至少有一棵树。</li>
<li>所有树的坐标都是不同的。</li>
<li>输入的点<strong>没有</strong>顺序。输出顺序也没有要求。</li>
</ol></div></div></div><br><br><hr><br>******************<div id="title">591. Tag Validator</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：</p>
<ol>
<li>代码必须被<strong>合法的闭合标签</strong>包围。否则，代码是无效的。</li>
<li><strong>闭合标签</strong>（不一定合法）要严格符合格式：<code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code>。其中，<code>&lt;TAG_NAME&gt;</code>是起始标签，<code>&lt;/TAG_NAME&gt;</code>是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是<strong>合法的</strong>。</li>
<li><strong>合法的</strong> <code>TAG_NAME</code> 仅含有<strong>大写字母</strong>，长度在范围 [1,9] 之间。否则，该 <code>TAG_NAME</code> 是<strong>不合法的</strong>。</li>
<li><strong>合法的</strong> <code>TAG_CONTENT</code> 可以包含其他<strong>合法的闭合标签</strong>，<strong>cdata</strong> （请参考规则7）和任意字符（注意参考规则1）<strong>除了</strong>不匹配的<code>&lt;</code>、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，<code>TAG_CONTENT</code> 是<strong>不合法的</strong>。</li>
<li>一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。</li>
<li>一个<code>&lt;</code>，如果你找不到一个后续的<code>&gt;</code>与之匹配，是不合法的。并且当你找到一个<code>&lt;</code>或<code>&lt;/</code>时，所有直到下一个<code>&gt;</code>的前的字符，都应当被解析为 TAG_NAME（不一定合法）。</li>
<li>cdata 有如下格式：<code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>。<code>CDATA_CONTENT</code> 的范围被定义成 <code>&lt;![CDATA[</code> 和<strong>后续的第一个</strong> <code>]]&gt;</code>之间的字符。</li>
<li><code>CDATA_CONTENT</code> 可以包含<strong>任意字符</strong>。cdata 的功能是阻止验证器解析<code>CDATA_CONTENT</code>，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为<strong>常规字符</strong>。</li>
</ol>
<p><strong>合法代码的例子:</strong></p>
<pre><strong>输入:</strong> "&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;"

<strong>输出:</strong> True

<strong>解释:</strong> 

代码被包含在了闭合的标签内： &lt;DIV&gt; 和 &lt;/DIV&gt; 。

TAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 

即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。

所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。


<strong>输入:</strong> "&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;"

<strong>输出:</strong> True

<strong>解释:</strong>

我们首先将代码分割为： start_tag|tag_content|end_tag 。

start_tag -&gt; <strong>"&lt;DIV&gt;"</strong>

end_tag -&gt; <strong>"&lt;/DIV&gt;"</strong>

tag_content 也可被分割为： text1|cdata|text2 。

text1 -&gt; <strong>"&gt;&gt;  ![cdata[]] "</strong>

cdata -&gt; <strong>"&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;"</strong> ，其中 CDATA_CONTENT 为 <strong>"&lt;div&gt;]&gt;"</strong>

text2 -&gt; <strong>"]]&gt;&gt;]"</strong>


start_tag <strong>不</strong>是 <strong>"&lt;DIV&gt;&gt;&gt;"</strong> 的原因参照规则 6 。
cdata <strong>不</strong>是 <strong>"&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;"</strong> 的原因参照规则 7 。
</pre>
<p><strong>不合法代码的例子:</strong></p>
<pre><strong>输入:</strong> "&lt;A&gt;  &lt;B&gt; &lt;/A&gt;   &lt;/B&gt;"
<strong>输出:</strong> False
<strong>解释:</strong> 不合法。如果 "&lt;A&gt;" 是闭合的，那么 "&lt;B&gt;" 一定是不匹配的，反之亦然。

<strong>输入:</strong> "&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;"
<strong>输出:</strong> False

<strong>输入:</strong> "&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;"
<strong>输出:</strong> False

<strong>输入:</strong> "&lt;DIV&gt; closed tags with invalid tag name  &lt;b&gt;123&lt;/b&gt; &lt;/DIV&gt;"
<strong>输出:</strong> False

<strong>输入:</strong> "&lt;DIV&gt; unmatched tags with invalid tag name  &lt;/1234567890&gt; and &lt;CDATA[[]]&gt;  &lt;/DIV&gt;"
<strong>输出:</strong> False

<strong>输入:</strong> "&lt;DIV&gt;  unmatched start tag &lt;B&gt;  and unmatched end tag &lt;/C&gt;  &lt;/DIV&gt;"
<strong>输出:</strong> False
</pre>
<p><strong>注意:</strong></p>
<ol>
<li>为简明起见，你可以假设输入的代码（包括提到的<strong>任意字符</strong>）只包含<code>数字</code>, <font color="#c7254e" face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="background-color:#f9f2f4; font-size:12.6px">字母</span></font>, <code>'&lt;'</code>,<code>'&gt;'</code>,<code>'/'</code>,<code>'!'</code>,<code>'['</code>,<code>']'</code>和<code>' '</code>。</li>
</ol>
</div></div></div><br><br><hr><br>***************************************************<div id="title">600. Non-negative Integers without Consecutive Ones</div>
***************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个正整数 <code>n</code> ，请你统计在 <code>[0, n]</code> 范围的非负整数中，有多少个整数的二进制表示中不存在 <strong>连续的 1 </strong>。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> n = 5
<strong>输出:</strong> 5
<strong>解释:</strong> 
下面列出范围在 [0, 5] 的非负整数与其对应的二进制表示：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数 3 违反规则（有两个连续的 1 ），其他 5 个满足规则。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> n = 1
<strong>输出:</strong> 2
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> n = 2
<strong>输出:</strong> 3
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">629. K Inverse Pairs Array</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给出两个整数 <code>n</code> 和 <code>k</code>，找出所有包含从 <code>1</code> 到 <code>n</code> 的数字，且恰好拥有 <code>k</code> 个逆序对的不同的数组的个数。</p>
<p>逆序对的定义如下：对于数组的第<code>i</code>个和第 <code>j</code>个元素，如果满<code>i</code> &lt; <code>j</code>且 <code>a[i]</code> &gt; <code>a[j]</code>，则其为一个逆序对；否则不是。</p>
<p>由于答案可能很大，只需要返回 答案 mod 10<sup>9</sup> + 7 的值。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> n = 3, k = 0
<strong>输出:</strong> 1
<strong>解释:</strong> 
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> n = 3, k = 1
<strong>输出:</strong> 2
<strong>解释:</strong> 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
</pre>
<p><strong>说明:</strong></p>
<ol>
<li> <code>n</code> 的范围是 [1, 1000] 并且 <code>k</code> 的范围是 [0, 1000]。</li>
</ol>
</div></div></div><br><br><hr><br>************************<div id="title">630. Course Schedule III</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>这里有 <code>n</code> 门不同的在线课程，按从 <code>1</code> 到 <code>n</code> 编号。给你一个数组 <code>courses</code> ，其中 <code>courses[i] = [duration<sub>i</sub>, lastDay<sub>i</sub>]</code> 表示第 <code>i</code> 门课将会 <strong>持续</strong> 上 <code>duration<sub>i</sub></code> 天课，并且必须在不晚于 <code>lastDay<sub>i</sub></code> 的时候完成。</p>
<p>你的学期从第 <code>1</code> 天开始。且不能同时修读两门及两门以上的课程。</p>
<p>返回你最多可以修读的课程数目。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
<strong>输出：</strong>3
<strong>解释：</strong>
这里一共有 4 门课程，但是你最多可以修 3 门：
首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。
第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。
第三，修第 2 门课，耗时 200 天，在第 1300 天完成。
第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>courses = [[1,2]]
<strong>输出：</strong>1
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>courses = [[3,2],[4,3]]
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= courses.length &lt;= 10<sup>4</sup></code></li>
<li><code>1 &lt;= duration<sub>i</sub>, lastDay<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************************<div id="title">632. Smallest Range Covering Elements from K Lists</div>
**************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你有 <code>k</code> 个 <strong>非递减排列</strong> 的整数列表。找到一个 <strong>最小 </strong>区间，使得 <code>k</code> 个列表中的每个列表至少有一个数包含在其中。</p>
<p>我们定义如果 <code>b-a &lt; d-c</code> 或者在 <code>b-a == d-c</code> 时 <code>a &lt; c</code>，则区间 <code>[a,b]</code> 比 <code>[c,d]</code> 小。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
<strong>输出：</strong>[20,24]
<strong>解释：</strong> 
列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。
列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。
列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [[1,2,3],[1,2,3],[1,2,3]]
<strong>输出：</strong>[1,1]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>nums.length == k</code></li>
<li><code>1 &lt;= k &lt;= 3500</code></li>
<li><code>1 &lt;= nums[i].length &lt;= 50</code></li>
<li><code>-10<sup>5</sup> &lt;= nums[i][j] &lt;= 10<sup>5</sup></code></li>
<li><code>nums[i]</code> 按非递减顺序排列</li>
</ul>
<p> </p>
</div></div></div><br><br><hr><br>*******************<div id="title">639. Decode Ways II</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一条包含字母 <code>A-Z</code> 的消息通过以下的方式进行了 <strong>编码</strong> ：</p>
<pre>'A' -&gt; "1"
'B' -&gt; "2"
...
'Z' -&gt; "26"</pre>
<p>要 <strong>解码</strong> 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，<code>"11106"</code> 可以映射为：</p>
<ul>
<li><code>"AAJF"</code> 对应分组 <code>(1 1 10 6)</code></li>
<li><code>"KJF"</code> 对应分组 <code>(11 10 6)</code></li>
</ul>
<p>注意，像 <code>(1 11 06)</code> 这样的分组是无效的，因为 <code>"06"</code> 不可以映射为 <code>'F'</code> ，因为 <code>"6"</code> 与 <code>"06"</code> 不同。</p>
<p><strong>除了</strong> 上面描述的数字字母映射方案，编码消息中可能包含 <code>'*'</code> 字符，可以表示从 <code>'1'</code> 到 <code>'9'</code> 的任一数字（不包括 <code>'0'</code>）。例如，编码字符串 <code>"1*"</code> 可以表示 <code>"11"</code>、<code>"12"</code>、<code>"13"</code>、<code>"14"</code>、<code>"15"</code>、<code>"16"</code>、<code>"17"</code>、<code>"18"</code> 或 <code>"19"</code> 中的任意一条消息。对 <code>"1*"</code> 进行解码，相当于解码该字符串可以表示的任何编码消息。</p>
<p>给你一个字符串 <code>s</code> ，由数字和 <code>'*'</code> 字符组成，返回 <strong>解码</strong> 该字符串的方法 <strong>数目</strong> 。</p>
<p>由于答案数目可能非常大，返回 <code>10<sup>9</sup> + 7</code> 的 <b>模</b> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "*"
<strong>输出：</strong>9
<strong>解释：</strong>这一条编码消息可以表示 "1"、"2"、"3"、"4"、"5"、"6"、"7"、"8" 或 "9" 中的任意一条。
可以分别解码成字符串 "A"、"B"、"C"、"D"、"E"、"F"、"G"、"H" 和 "I" 。
因此，"*" 总共有 9 种解码方法。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "1*"
<strong>输出：</strong>18
<strong>解释：</strong>这一条编码消息可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条。
每种消息都可以由 2 种方法解码（例如，"11" 可以解码成 "AA" 或 "K"）。
因此，"1*" 共有 9 * 2 = 18 种解码方法。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "2*"
<strong>输出：</strong>15
<strong>解释：</strong>这一条编码消息可以表示 "21"、"22"、"23"、"24"、"25"、"26"、"27"、"28" 或 "29" 中的任意一条。
"21"、"22"、"23"、"24"、"25" 和 "26" 由 2 种解码方法，但 "27"、"28" 和 "29" 仅有 1 种解码方法。
因此，"2*" 共有 (6 * 2) + (3 * 1) = 12 + 3 = 15 种解码方法。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
<li><code>s[i]</code> 是 <code>0 - 9</code> 中的一位数字或字符 <code>'*'</code></li>
</ul>
</div></div></div><br><br><hr><br>********************<div id="title">664. Strange Printer</div>
********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有台奇怪的打印机有以下两个特殊要求：</p>
<ul>
<li>打印机每次只能打印由 <strong>同一个字符</strong> 组成的序列。</li>
<li>每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。</li>
</ul>
<p>给你一个字符串 <code>s</code> ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>
 

<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "aaabbb"
<strong>输出：</strong>2
<strong>解释：</strong>首先打印 "aaa" 然后打印 "bbb"。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "aba"
<strong>输出：</strong>2
<strong>解释：</strong>首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>************************************************<div id="title">668. Kth Smallest Number in Multiplication Table</div>
************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>几乎每一个人都用 <a href="https://baike.baidu.com/item/%E4%B9%98%E6%B3%95%E8%A1%A8">乘法表</a>。但是你能在乘法表中快速找到第 <code>k</code> 小的数字吗？</p>
<p>乘法表是大小为 <code>m x n</code> 的一个整数矩阵，其中 <code>mat[i][j] == i * j</code>（下标从 <strong>1</strong> 开始）。</p>
<p>给你三个整数 <code>m</code>、<code>n</code> 和 <code>k</code>，请你在大小为 <code>m x n</code> 的乘法表中，找出并返回第 <code>k</code> 小的数字。</p>
<div class="original__bRMd">
<div>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/02/multtable1-grid.jpg" style="width: 500px; height: 254px;"/>
<pre><strong>输入：</strong>m = 3, n = 3, k = 5
<strong>输出：</strong>3
<strong>解释：</strong>第 5 小的数字是 3 。
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/02/multtable2-grid.jpg" style="width: 493px; height: 293px;"/>
<pre><strong>输入：</strong>m = 2, n = 3, k = 6
<strong>输出：</strong>6
<strong>解释：</strong>第 6 小的数字是 6 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= k &lt;= m * n</code></li>
</ul>
</div>
</div>
</div></div></div><br><br><hr><br>*********************************<div id="title">675. Cut Off Trees for Golf Event</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 <code>m x n</code> 的矩阵表示， 在这个矩阵中：</p>
<ul>
<li><code>0</code> 表示障碍，无法触碰</li>
<li><code>1</code> 表示地面，可以行走</li>
<li><code>比 1 大的数</code> 表示有树的单元格，可以行走，数值表示树的高度</li>
</ul>
<p>每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。</p>
<p>你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 <code>1</code>（即变为地面）。</p>
<p>你将从 <code>(0, 0)</code> 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 <code>-1</code> 。</p>
<p>可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg" style="width: 242px; height: 242px;"/>
<pre><strong>输入：</strong>forest = [[1,2,3],[0,0,4],[7,6,5]]
<strong>输出：</strong>6
<strong>解释：</strong>沿着上面的路径，你可以用 6 步，按从最矮到最高的顺序砍掉这些树。</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg" style="width: 242px; height: 242px;"/>
<pre><strong>输入：</strong>forest = [[1,2,3],[0,0,0],[7,6,5]]
<strong>输出：</strong>-1
<strong>解释：</strong>由于中间一行被障碍阻塞，无法访问最下面一行中的树。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>forest = [[2,3,4],[0,0,5],[8,7,6]]
<strong>输出：</strong>6
<strong>解释：</strong>可以按与示例 1 相同的路径来砍掉所有的树。
(0,0) 位置的树，可以直接砍去，不用算步数。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == forest.length</code></li>
<li><code>n == forest[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 50</code></li>
<li><code>0 &lt;= forest[i][j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>************<div id="title">679. 24 Game</div>
************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个长度为4的整数数组 <code>cards</code> 。你有 <code>4</code> 张卡片，每张卡片上都包含一个范围在 <code>[1,9]</code> 的数字。您应该使用运算符 <code>['+', '-', '*', '/']</code> 和括号 <code>'('</code> 和 <code>')'</code> 将这些卡片上的数字排列成数学表达式，以获得值24。</p>
<p>你须遵守以下规则:</p>
<ul>
<li>除法运算符 <code>'/'</code> 表示实数除法，而不是整数除法。

	<ul>
<li>例如， <code>4 /(1 - 2 / 3)= 4 /(1 / 3)= 12</code> 。</li>
</ul>
</li>
<li>每个运算都在两个数字之间。特别是，不能使用 <code>“-”</code> 作为一元运算符。
	<ul>
<li>例如，如果 <code>cards =[1,1,1,1]</code> ，则表达式 <code>“-1 -1 -1 -1”</code> 是 <strong>不允许</strong> 的。</li>
</ul>
</li>
<li>你不能把数字串在一起
	<ul>
<li>例如，如果 <code>cards =[1,2,1,2]</code> ，则表达式 <code>“12 + 12”</code> 无效。</li>
</ul>
</li>
</ul>
<p>如果可以得到这样的表达式，其计算结果为 <code>24</code> ，则返回 <code>true </code>，否则返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> cards = [4, 1, 8, 7]
<strong>输出:</strong> true
<strong>解释:</strong> (8-4) * (7-1) = 24
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> cards = [1, 2, 1, 2]
<strong>输出:</strong> false
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>cards.length == 4</code></li>
<li><code>1 &lt;= cards[i] &lt;= 9</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************<div id="title">685. Redundant Connection II</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在本问题中，有根树指满足以下条件的 <strong>有向</strong> 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着 <code>n</code> 个节点（节点值不重复，从 <code>1</code> 到 <code>n</code>）的树及一条附加的有向边构成。附加的边包含在 <code>1</code> 到 <code>n</code> 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组 <code>edges</code> 。 每个元素是一对 <code>[u<sub>i</sub>, v<sub>i</sub>]</code>，用以表示 <strong>有向 </strong>图中连接顶点 <code>u<sub>i</sub></code> 和顶点 <code>v<sub>i</sub></code> 的边，其中 <code>u<sub>i</sub></code> 是 <code>v<sub>i</sub></code> 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有 <code>n</code> 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg" style="width: 222px; height: 222px;"/>
<pre><strong>输入：</strong>edges = [[1,2],[1,3],[2,3]]
<strong>输出：</strong>[2,3]
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg" style="width: 222px; height: 382px;"/>
<pre><strong>输入：</strong>edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]
<strong>输出：</strong>[4,1]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == edges.length</code></li>
<li><code>3 &lt;= n &lt;= 1000</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
</ul>
</div></div></div><br><br><hr><br>***********************************************<div id="title">689. Maximum Sum of 3 Non-Overlapping Subarrays</div>
***********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出三个长度为 <code>k</code> 、互不重叠、且全部数字和（<code>3 * k</code> 项）最大的子数组，并返回这三个子数组。</p>
<p>以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 <strong>0</strong> 开始）。如果有多个结果，返回字典序最小的一个。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,1,2,6,7,5,1], k = 2
<strong>输出：</strong>[0,3,5]
<strong>解释：</strong>子数组 [1, 2], [2, 6], [7, 5] 对应的起始下标为 [0, 3, 5]。
也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,1,2,1,2,1,2,1], k = 2
<strong>输出：</strong>[0,2,4]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= nums[i] &lt; 2<sup>16</sup></code></li>
<li><code>1 &lt;= k &lt;= floor(nums.length / 3)</code></li>
</ul>
</div></div></div><br><br><hr><br>***************************<div id="title">691. Stickers to Spell Word</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>我们有 <code>n</code> 种不同的贴纸。每个贴纸上都有一个小写的英文单词。</p>
<p>您想要拼写出给定的字符串 <code>target</code> ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。</p>
<p>返回你需要拼出 <code>target</code> 的最小贴纸数量。如果任务不可能，则返回 <code>-1</code> 。</p>
<p><strong>注意：</strong>在所有的测试用例中，所有的单词都是从 <code>1000</code> 个最常见的美国英语单词中随机选择的，并且 <code>target</code> 被选择为两个随机单词的连接。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong> stickers = ["with","example","science"], target = "thehat"
<b>输出：</b>3
<strong>解释：
</strong>我们可以使用 2 个 "with" 贴纸，和 1 个 "example" 贴纸。
把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。
此外，这是形成目标字符串所需的最小贴纸数量。
</pre>
<p><strong>示例 2:</strong></p>
<pre><b>输入：</b>stickers = ["notice","possible"], target = "basicbasic"
<b>输出：</b>-1
<strong>解释：</strong>我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>n == stickers.length</code></li>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>1 &lt;= stickers[i].length &lt;= 10</code></li>
<li><code>1 &lt;= target.length &lt;= 15</code></li>
<li><code>stickers[i]</code> 和 <code>target</code> 由小写英文单词组成</li>
</ul>
</div></div></div><br><br><hr><br>********************<div id="title">699. Falling Squares</div>
********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在二维平面上的 x 轴上，放置着一些方块。</p>
<p>给你一个二维整数数组 <code>positions</code> ，其中 <code>positions[i] = [left<sub>i</sub>, sideLength<sub>i</sub>]</code> 表示：第 <code>i</code> 个方块边长为 <code>sideLength<sub>i</sub></code> ，其左侧边与 x 轴上坐标点 <code>left<sub>i</sub></code> 对齐。</p>
<p>每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 <strong>另一个正方形的顶边</strong> 或者是 <strong>x 轴上</strong> 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。</p>
<p>在每个方块掉落后，你必须记录目前所有已经落稳的 <strong>方块堆叠的最高高度</strong> 。</p>
<p>返回一个整数数组 <code>ans</code> ，其中 <code>ans[i]</code> 表示在第 <code>i</code> 块方块掉落后堆叠的最高高度。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg" style="width: 500px; height: 505px;"/>
<pre><strong>输入：</strong>positions = [[1,2],[2,3],[6,1]]
<strong>输出：</strong>[2,5,5]
<strong>解释：</strong>
第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。
第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。
第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。
因此，返回 [2, 5, 5] 作为答案。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>positions = [[100,100],[200,100]]
<strong>输出：</strong>[100,100]
<strong>解释：</strong>
第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。
第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。
因此，返回 [100, 100] 作为答案。
注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= positions.length &lt;= 1000</code></li>
<li><code>1 &lt;= left<sub>i</sub> &lt;= 10<sup>8</sup></code></li>
<li><code>1 &lt;= sideLength<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">710. Random Pick with Blacklist</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个整数 <code>n</code> 和一个 <strong>无重复</strong> 黑名单整数数组 <code>blacklist</code> 。设计一种算法，从 <code>[0, n - 1]</code> 范围内的任意整数中选取一个 <strong>未加入 </strong>黑名单 <code>blacklist</code> 的整数。任何在上述范围内且不在黑名单 <code>blacklist</code> 中的整数都应该有 <strong>同等的可能性</strong> 被返回。</p>
<p>优化你的算法，使它最小化调用语言 <strong>内置</strong> 随机函数的次数。</p>
<p>实现 <code>Solution</code> 类:</p>
<ul>
<li><code>Solution(int n, int[] blacklist)</code> 初始化整数 <code>n</code> 和被加入黑名单 <code>blacklist</code> 的整数</li>
<li><code>int pick()</code> 返回一个范围为 <code>[0, n - 1]</code> 且不在黑名单 <code>blacklist</code> 中的随机整数</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入</strong>
["Solution", "pick", "pick", "pick", "pick", "pick", "pick", "pick"]
[[7, [2, 3, 5]], [], [], [], [], [], [], []]
<strong>输出</strong>
[null, 0, 4, 1, 6, 1, 0, 4]

<b>解释
</b>Solution solution = new Solution(7, [2, 3, 5]);
solution.pick(); // 返回0，任何[0,1,4,6]的整数都可以。注意，对于每一个pick的调用，
                 // 0、1、4和6的返回概率必须相等(即概率为1/4)。
solution.pick(); // 返回 4
solution.pick(); // 返回 1
solution.pick(); // 返回 6
solution.pick(); // 返回 1
solution.pick(); // 返回 0
solution.pick(); // 返回 4
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
<li><code>0 &lt;= blacklist.length &lt;= min(10<sup>5</sup>, n - 1)</code></li>
<li><code>0 &lt;= blacklist[i] &lt; n</code></li>
<li><code>blacklist</code> 中所有值都 <strong>不同</strong></li>
<li> <code>pick</code> 最多被调用 <code>2 * 10<sup>4</sup></code> 次</li>
</ul>
</div></div></div><br><br><hr><br>*****************<div id="title">715. Range Module</div>
*****************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 <strong>半开区间</strong> 的范围并查询它们。</p>
<p><strong>半开区间</strong> <code>[left, right)</code> 表示所有 <code>left &lt;= x &lt; right</code> 的实数 <code>x</code> 。</p>
<p>实现 <code>RangeModule</code> 类:</p>
<ul>
<li><code>RangeModule()</code> 初始化数据结构的对象。</li>
<li><code>void addRange(int left, int right)</code> 添加 <strong>半开区间</strong> <code>[left, right)</code>，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 <code>[left, right)</code> 中尚未跟踪的任何数字到该区间中。</li>
<li><code>boolean queryRange(int left, int right)</code> 只有在当前正在跟踪区间 <code>[left, right)</code> 中的每一个实数时，才返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
<li><code>void removeRange(int left, int right)</code> 停止跟踪 <strong>半开区间</strong> <code>[left, right)</code> 中当前正在跟踪的每个实数。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入</strong>
["RangeModule", "addRange", "removeRange", "queryRange", "queryRange", "queryRange"]
[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]
<strong>输出</strong>
[null, null, null, true, false, true]

<strong>解释</strong>
RangeModule rangeModule = new RangeModule();
rangeModule.addRange(10, 20);
rangeModule.removeRange(14, 16);
rangeModule.queryRange(10, 14); 返回 true （区间 [10, 14) 中的每个数都正在被跟踪）
rangeModule.queryRange(13, 15); 返回 false（未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）
rangeModule.queryRange(16, 17); 返回 true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪）
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= left &lt; right &lt;= 10<sup>9</sup></code></li>
<li>在单个测试用例中，对 <code>addRange</code> 、  <code>queryRange</code> 和 <code>removeRange</code> 的调用总数不超过 <code>10<sup>4</sup></code> 次</li>
</ul>
</div></div></div><br><br><hr><br>*************************************<div id="title">719. Find K-th Smallest Pair Distance</div>
*************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>数对 <code>(a,b)</code> 由整数 <code>a</code> 和 <code>b</code> 组成，其数对距离定义为 <code>a</code> 和 <code>b</code> 的绝对差值。</p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，数对由 <code>nums[i]</code> 和 <code>nums[j]</code> 组成且满足 <code>0 &lt;= i &lt; j &lt; nums.length</code> 。返回 <strong>所有数对距离中</strong> 第 <code>k</code> 小的数对距离。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,3,1], k = 1
<strong>输出：</strong>0
<strong>解释：</strong>数对和对应的距离如下：
(1,3) -&gt; 2
(1,1) -&gt; 0
(3,1) -&gt; 2
距离第 1 小的数对是 (1,1) ，距离为 0 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,1,1], k = 2
<strong>输出：</strong>0
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [1,6,1], k = 3
<strong>输出：</strong>5
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>
<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
<li><code>1 &lt;= k &lt;= n * (n - 1) / 2</code></li>
</ul>
</div></div></div><br><br><hr><br>********************<div id="title">726. Number of Atoms</div>
********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串化学式 <code>formula</code> ，返回 <strong>每种原子的数量</strong> 。</p>
<p>原子总是以一个大写字母开始，接着跟随 0 个或任意个小写字母，表示原子的名字。</p>
<p>如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。</p>
<ul>
<li>例如，<code>"H2O"</code> 和 <code>"H2O2"</code> 是可行的，但 <code>"H1O2"</code> 这个表达是不可行的。</li>
</ul>
<p>两个化学式连在一起可以构成新的化学式。</p>
<ul>
<li>例如 <code>"H2O2He3Mg4"</code> 也是化学式。</li>
</ul>
<p>由括号括起的化学式并佐以数字（可选择性添加）也是化学式。</p>
<ul>
<li>例如 <code>"(H2O2)"</code> 和 <code>"(H2O2)3"</code> 是化学式。</li>
</ul>
<p>返回所有原子的数量，格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>formula = "H2O"
<strong>输出：</strong>"H2O"
<strong>解释：</strong>原子的数量是 {'H': 2, 'O': 1}。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>formula = "Mg(OH)2"
<strong>输出：</strong>"H2MgO2"
<strong>解释：</strong>原子的数量是 {'H': 2, 'Mg': 1, 'O': 2}。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>formula = "K4(ON(SO3)2)2"
<strong>输出：</strong>"K4N2O14S4"
<strong>解释：</strong>原子的数量是 {'K': 4, 'N': 2, 'O': 14, 'S': 4}。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= formula.length &lt;= 1000</code></li>
<li><code>formula</code> 由英文字母、数字、<code>'('</code> 和 <code>')'</code> 组成</li>
<li><code>formula</code> 总是有效的化学式</li>
</ul>
</div></div></div><br><br><hr><br>*********************************************<div id="title">730. Count Different Palindromic Subsequences</div>
*********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串 s，返回 <em><code>s</code> 中不同的非空「回文子序列」个数 。</em></p>
<p>通过从 s 中删除 0 个或多个字符来获得子序列。</p>
<p>如果一个字符序列与它反转后的字符序列一致，那么它是「回文字符序列」。</p>
<p>如果有某个 <code>i</code> , 满足 <code>a<sub>i</sub> != b<sub>i</sub></code><sub> </sub>，则两个序列 <code>a<sub>1</sub>, a<sub>2</sub>, ...</code> 和 <code>b<sub>1</sub>, b<sub>2</sub>, ...</code> 不同。</p>
<p><strong>注意：</strong></p>
<ul>
<li>结果可能很大，你需要对 <code>10<sup>9</sup> + 7</code> 取模 。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = 'bccb'
<strong>输出：</strong>6
<strong>解释：</strong>6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。
注意：'bcb' 虽然出现两次但仅计数一次。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'
<strong>输出：</strong>104860361
<strong>解释：</strong>共有 3104860382 个不同的非空回文子序列，104860361 对 10<sup>9</sup> + 7 取模后的值。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i]</code> 仅包含 <code>'a'</code>, <code>'b'</code>, <code>'c'</code> 或 <code>'d'</code> </li>
</ul>
</div></div></div><br><br><hr><br>********************<div id="title">732. My Calendar III</div>
********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>当 <code>k</code> 个日程安排有一些时间上的交叉时（例如 <code>k</code> 个日程安排都在同一时间内），就会产生 <code>k</code> 次预订。</p>
<p>给你一些日程安排 <code>[start, end)</code> ，请你在每个日程安排添加后，返回一个整数 <code>k</code> ，表示所有先前日程安排会产生的最大 <code>k</code> 次预订。</p>
<p>实现一个 <code>MyCalendarThree</code> 类来存放你的日程安排，你可以一直添加新的日程安排。</p>
<ul>
<li><code>MyCalendarThree()</code> 初始化对象。</li>
<li><code>int book(int start, int end)</code> 返回一个整数 <code>k</code> ，表示日历中存在的 <code>k</code> 次预订的最大值。</li>
</ul>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>
["MyCalendarThree", "book", "book", "book", "book", "book", "book"]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
<strong>输出：</strong>
[null, 1, 1, 2, 3, 3, 3]

<strong>解释：</strong>
MyCalendarThree myCalendarThree = new MyCalendarThree();
myCalendarThree.book(10, 20); // 返回 1 ，第一个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。
myCalendarThree.book(50, 60); // 返回 1 ，第二个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。
myCalendarThree.book(10, 40); // 返回 2 ，第三个日程安排 [10, 40) 与第一个日程安排相交，所以最大 k 次预订是 2 次预订。
myCalendarThree.book(5, 15); // 返回 3 ，剩下的日程安排的最大 k 次预订是 3 次预订。
myCalendarThree.book(5, 10); // 返回 3
myCalendarThree.book(25, 55); // 返回 3
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= start &lt; end &lt;= 10<sup>9</sup></code></li>
<li>每个测试用例，调用 <code>book</code> 函数最多不超过 <code>400</code>次</li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">736. Parse Lisp Expression</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个类似 Lisp 语句的字符串表达式 <code>expression</code>，求出其计算结果。</p>
<p>表达式语法如下所示:</p>
<ul>
<li>表达式可以为整数，<strong>let</strong> 表达式，<strong>add</strong> 表达式，<strong>mult</strong> 表达式，或赋值的变量。表达式的结果总是一个整数。</li>
<li>(整数可以是正整数、负整数、0)</li>
<li><strong>let</strong> 表达式采用 <code>"(let v<sub>1</sub> e<sub>1</sub> v<sub>2</sub> e<sub>2</sub> ... v<sub>n</sub> e<sub>n</sub> expr)"</code> 的形式，其中 <code>let</code> 总是以字符串 <code>"let"</code>来表示，接下来会跟随一对或多对交替的变量和表达式，也就是说，第一个变量 <code>v<sub>1</sub></code>被分配为表达式 <code>e<sub>1</sub></code> 的值，第二个变量 <code>v<sub>2</sub></code> 被分配为表达式 <code>e<sub>2</sub></code> 的值，<strong>依次类推</strong>；最终 <code>let</code> 表达式的值为 <code>expr</code>表达式的值。</li>
<li><strong>add </strong>表达式表示为 <code>"(add e<sub>1</sub> e<sub>2</sub>)"</code> ，其中 <code>add</code> 总是以字符串 <code>"add"</code> 来表示，该表达式总是包含两个表达式 <code>e<sub>1</sub></code>、<code>e<sub>2</sub></code> ，最终结果是 <code>e<sub>1</sub></code> 表达式的值与 <code>e<sub>2</sub></code> 表达式的值之 <strong>和 </strong>。</li>
<li><strong>mult</strong> 表达式表示为 <code>"(mult e<sub>1</sub> e<sub>2</sub>)"</code> ，其中 <code>mult</code> 总是以字符串 <code>"mult"</code> 表示，该表达式总是包含两个表达式 <code>e<sub>1</sub></code>、<code>e<sub>2</sub></code>，最终结果是 <code>e<sub>1</sub></code> 表达式的值与 <code>e<sub>2</sub></code> 表达式的值之<strong> 积 </strong>。</li>
<li>在该题目中，变量名以小写字符开始，之后跟随 0 个或多个小写字符或数字。为了方便，<code>"add"</code> ，<code>"let"</code> ，<code>"mult"</code> 会被定义为 "关键字" ，不会用作变量名。</li>
<li>最后，要说一下作用域的概念。计算变量名所对应的表达式时，在计算上下文中，首先检查最内层作用域（按括号计），然后按顺序依次检查外部作用域。测试用例中每一个表达式都是合法的。有关作用域的更多详细信息，请参阅示例。</li>
</ul>
 

<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>expression = "(let x 2 (mult x (let x 3 y 4 (add x y))))"
<strong>输出：</strong>14
<strong>解释：</strong>
计算表达式 (add x y), 在检查变量 x 值时，
在变量的上下文中由最内层作用域依次向外检查。
首先找到 x = 3, 所以此处的 x 值是 3 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>expression = "(let x 3 x 2 x)"
<strong>输出：</strong>2
<strong>解释：</strong>let 语句中的赋值运算按顺序处理即可。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>expression = "(let x 1 y 2 x (add x y) (add x y))"
<strong>输出：</strong>5
<strong>解释：</strong>
第一个 (add x y) 计算结果是 3，并且将此值赋给了 x 。 
第二个 (add x y) 计算结果是 3 + 2 = 5 。
</pre>
 

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= expression.length &lt;= 2000</code></li>
<li><code>exprssion</code> 中不含前导和尾随空格</li>
<li><code>expressoin</code> 中的不同部分（token）之间用单个空格进行分隔</li>
<li>答案和所有中间计算结果都符合 <strong>32-bit</strong> 整数范围</li>
<li>测试用例中的表达式均为合法的且最终结果为整数</li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">741. Cherry Pickup</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个N x N的网格<code>(grid)</code> 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：</p>
<ul>
<li>0 表示这个格子是空的，所以你可以穿过它。</li>
<li>1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。</li>
<li>-1 表示这个格子里有荆棘，挡着你的路。</li>
</ul>
<p>你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：</p>
<ul>
<li>从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；</li>
<li>当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；</li>
<li>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；</li>
<li>如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
<strong>输出:</strong> 5
<strong>解释：</strong> 
玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。
在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。
接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。
在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。
</pre>
<p><strong>说明:</strong></p>
<ul>
<li><code>grid</code> 是一个 <code>N</code> * <code>N</code> 的二维数组，N的取值范围是<code>1 &lt;= N &lt;= 50</code>。</li>
<li>每一个 <code>grid[i][j]</code> 都是集合 <code>{-1, 0, 1}</code>其中的一个数。</li>
<li>可以保证起点 <code>grid[0][0]</code> 和终点 <code>grid[N-1][N-1]</code> 的值都不会是 -1。</li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">745. Prefix and Suffix Search</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>设计一个包含一些单词的特殊词典，并能够通过前缀和后缀来检索单词。</p>
<p>实现 <code>WordFilter</code> 类：</p>
<ul>
<li><code>WordFilter(string[] words)</code> 使用词典中的单词 <code>words</code> 初始化对象。</li>
<li><code>f(string pref, string suff)</code> 返回词典中具有前缀 <code>prefix</code> 和后缀 <code>suff</code> 的单词的下标。如果存在不止一个满足要求的下标，返回其中 <strong>最大的下标</strong> 。如果不存在这样的单词，返回 <code>-1</code> 。</li>
</ul>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入</strong>
["WordFilter", "f"]
[[["apple"]], ["a", "e"]]
<strong>输出</strong>
[null, 0]
<strong>解释</strong>
WordFilter wordFilter = new WordFilter(["apple"]);
wordFilter.f("a", "e"); // 返回 0 ，因为下标为 0 的单词：前缀 prefix = "a" 且 后缀 suff = "e" 。
</pre>
 

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>
<li><code>1 &lt;= words[i].length &lt;= 7</code></li>
<li><code>1 &lt;= pref.length, suff.length &lt;= 7</code></li>
<li><code>words[i]</code>、<code>pref</code> 和 <code>suff</code> 仅由小写英文字母组成</li>
<li>最多对函数 <code>f</code> 执行 <code>10<sup>4</sup></code> 次调用</li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">749. Contain Virus</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>病毒扩散得很快，现在你的任务是尽可能地通过安装防火墙来隔离病毒。</p>
<p>假设世界由 <code>m x n</code> 的二维矩阵 <code>isInfected</code> 组成， <code>isInfected[i][j] == 0</code> 表示该区域未感染病毒，而  <code>isInfected[i][j] == 1</code> 表示该区域已感染病毒。可以在任意 2 个相邻单元之间的共享边界上安装一个防火墙（并且只有一个防火墙）。</p>
<p>每天晚上，病毒会从被感染区域向相邻未感染区域扩散，除非被防火墙隔离。现由于资源有限，每天你只能安装一系列防火墙来隔离其中一个被病毒感染的区域（一个区域或连续的一片区域），且该感染区域对未感染区域的威胁最大且 <strong>保证唯一 </strong>。</p>
<p>你需要努力使得最后有部分区域不被病毒感染，如果可以成功，那么返回需要使用的防火墙个数; 如果无法实现，则返回在世界被病毒全部感染时已安装的防火墙个数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/01/virus11-grid.jpg" style="height: 255px; width: 500px;"/></p>
<pre><strong>输入:</strong> isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]
<strong>输出:</strong> 10
<strong>解释:</strong>一共有两块被病毒感染的区域。
在第一天，添加 5 墙隔离病毒区域的左侧。病毒传播后的状态是:
<img src="https://assets.leetcode.com/uploads/2021/06/01/virus12edited-grid.jpg" style="height: 261px; width: 500px;"/>
第二天，在右侧添加 5 个墙来隔离病毒区域。此时病毒已经被完全控制住了。
<img src="https://assets.leetcode.com/uploads/2021/06/01/virus13edited-grid.jpg" style="height: 261px; width: 500px;"/>
</pre>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/01/virus2-grid.jpg" style="height: 253px; width: 653px;"/></p>
<pre><strong>输入:</strong> isInfected = [[1,1,1],[1,0,1],[1,1,1]]
<strong>输出:</strong> 4
<strong>解释:</strong> 虽然只保存了一个小区域，但却有四面墙。
注意，防火墙只建立在两个不同区域的共享边界上。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]
<strong>输出:</strong> 13
<strong>解释:</strong> 在隔离右边感染区域后，隔离左边病毒区域只需要 2 个防火墙。
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>m == isInfected.length</code></li>
<li><code>n == isInfected[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 50</code></li>
<li><code>isInfected[i][j]</code> is either <code>0</code> or <code>1</code></li>
<li>在整个描述的过程中，总有一个相邻的病毒区域，它将在下一轮 <strong>严格地感染更多未受污染的方块</strong> </li>
</ul>
<p> </p>
</div></div></div><br><br><hr><br>**********************<div id="title">753. Cracking the Safe</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一个需要密码才能打开的保险箱。密码是 <code>n</code> 位数, 密码的每一位是 <code>k</code> 位序列 <code>0, 1, ..., k-1</code> 中的一个 。</p>
<p>你可以随意输入密码，保险箱会自动记住最后 <code>n</code> 位输入，如果匹配，则能够打开保险箱。</p>
<p>举个例子，假设密码是 <code>"345"</code>，你可以输入 <code>"012345"</code> 来打开它，只是你输入了 6 个字符.</p>
<p>请返回一个能打开保险箱的最短字符串。</p>
<p> </p>
<p><strong>示例1:</strong></p>
<pre><strong>输入:</strong> n = 1, k = 2
<strong>输出:</strong> "01"
<strong>说明:</strong> "10"也可以打开保险箱。
</pre>
<p> </p>
<p><strong>示例2:</strong></p>
<pre><strong>输入:</strong> n = 2, k = 2
<strong>输出:</strong> "00110"
<strong>说明: </strong>"01100", "10011", "11001" 也能打开保险箱。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ol>
<li><code>n</code> 的范围是 <code>[1, 4]</code>。</li>
<li><code>k</code> 的范围是 <code>[1, 10]</code>。</li>
<li><code>k^n</code> 最大可能为 <code>4096</code>。</li>
</ol>
<p> </p>
</div></div></div><br><br><hr><br>***************************************<div id="title">757. Set Intersection Size At Least Two</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个整数区间 <code>[a, b]</code>  ( <code>a &lt; b</code> ) 代表着从 <code>a</code> 到 <code>b</code> 的所有连续整数，包括 <code>a</code> 和 <code>b</code>。</p>
<p>给你一组整数区间<code>intervals</code>，请找到一个最小的集合 S，使得 S 里的元素与区间<code>intervals</code>中的每一个整数区间都至少有2个元素相交。</p>
<p>输出这个最小集合S的大小。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]
<strong>输出:</strong> 3
<strong>解释:</strong>
考虑集合 S = {2, 3, 4}. S与intervals中的四个区间都有至少2个相交的元素。
且这是S最小的情况，故我们输出3。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]
<strong>输出:</strong> 5
<strong>解释:</strong>
最小的集合S = {1, 2, 3, 4, 5}.
</pre>
<p><strong>注意:</strong></p>
<ol>
<li><code>intervals</code> 的长度范围为<code>[1, 3000]</code>。</li>
<li><code>intervals[i]</code> 长度为 <code>2</code>，分别代表左、右边界。</li>
<li><code>intervals[i][j]</code> 的值是 <code>[0, 10^8]</code>范围内的整数。</li>
</ol>
</div></div></div><br><br><hr><br>**************************<div id="title">761. Special Binary String</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>特殊的二进制序列是具有以下两个性质的二进制序列：</p>
<ul>
<li>0 的数量与 1 的数量相等。</li>
<li>二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。</li>
</ul>
<p>给定一个特殊的二进制序列 <code>S</code>，以字符串形式表示。定义一个<em>操作 </em>为首先选择 <code>S</code> 的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)</p>
<p>在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> S = "11011000"
<strong>输出:</strong> "11100100"
<strong>解释:</strong>
将子串 "10" （在S[1]出现） 和 "1100" （在S[3]出现）进行交换。
这是在进行若干次操作后按字典序排列最大的结果。
</pre>
<p><strong>说明:</strong></p>
<ol>
<li><code>S</code> 的长度不超过 <code>50</code>。</li>
<li><code>S</code> 保证为一个满足上述定义的<em>特殊 </em>的二进制序列。</li>
</ol>
</div></div></div><br><br><hr><br>**************************<div id="title">765. Couples Holding Hands</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><code>n</code> 对情侣坐在连续排列的 <code>2n</code> 个座位上，想要牵到对方的手。</p>
<p>人和座位由一个整数数组 <code>row</code> 表示，其中 <code>row[i]</code> 是坐在第 <code>i </code>个座位上的人的 <strong>ID</strong>。情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2n-2, 2n-1)</code>。</p>
<p>返回 <em>最少交换座位的次数，以便每对情侣可以并肩坐在一起</em>。 <i>每次</i>交换可选择任意两人，让他们站起来交换座位。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> row = [0,2,1,3]
<strong>输出:</strong> 1
<strong>解释:</strong> 只需要交换row[1]和row[2]的位置即可。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> row = [3,2,0,1]
<strong>输出:</strong> 0
<strong>解释:</strong> 无需交换座位，所有的情侣都已经可以手牵手了。
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>2n == row.length</code></li>
<li><code>2 &lt;= n &lt;= 30</code></li>
<li><code>n</code> 是偶数</li>
<li><code>0 &lt;= row[i] &lt; 2n</code></li>
<li><code>row</code> 中所有元素均<strong>无重复</strong></li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">768. Max Chunks To Make Sorted II</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><em>这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为<code>2000</code>，其中的元素最大为<code>10**8</code>。</em></p>
<p><code>arr</code>是一个可能包含<strong>重复元素</strong>的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p>
<p>我们最多能将数组分成多少块？</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> arr = [5,4,3,2,1]
<strong>输出:</strong> 1
<strong>解释:</strong>
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> arr = [2,1,3,4,4]
<strong>输出:</strong> 4
<strong>解释:</strong>
我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。
然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 
</pre>
<p><strong>注意:</strong></p>
<ul>
<li><code>arr</code>的长度在<code>[1, 2000]</code>之间。</li>
<li><code>arr[i]</code>的大小在<code>[0, 10**8]</code>之间。</li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">770. Basic Calculator IV</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个表达式如 <code>expression = "e + 8 - a + 5"</code> 和一个求值映射，如 <code>{"e": 1}</code>（给定的形式为 <code>evalvars = ["e"]</code> 和 <code>evalints = [1]</code>），返回表示简化表达式的标记列表，例如 <code>["-1*a","14"]</code></p>
<ul>
<li>表达式交替使用块和符号，每个块和符号之间有一个空格。</li>
<li>块要么是括号中的表达式，要么是变量，要么是非负整数。</li>
<li>变量是一个由小写字母组成的字符串（不包括数字）。请注意，变量可以是多个字母，并注意变量从不具有像 <code>"2x"</code> 或 <code>"-x"</code> 这样的前导系数或一元运算符 。</li>
</ul>
<p>表达式按通常顺序进行求值：先是括号，然后求乘法，再计算加法和减法。</p>
<ul>
<li>例如，<code>expression = "1 + 2 * 3"</code> 的答案是 <code>["7"]</code>。</li>
</ul>
<p>输出格式如下：</p>
<ul>
<li>对于系数非零的每个自变量项，我们按字典排序的顺序将自变量写在一个项中。
	<ul>
<li>例如，我们永远不会写像 <code>“b*a*c”</code> 这样的项，只写 <code>“a*b*c”</code>。</li>
</ul>
</li>
<li>项的次数等于被乘的自变量的数目，并计算重复项。我们先写出答案的最大次数项，用字典顺序打破关系，此时忽略词的前导系数。
	<ul>
<li>例如，<code>"a*a*b*c"</code> 的次数为 4。</li>
</ul>
</li>
<li>项的前导系数直接放在左边，用星号将它与变量分隔开(如果存在的话)。前导系数 1 仍然要打印出来。</li>
<li>格式良好的一个示例答案是 <code>["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"]</code> 。</li>
<li>系数为 <code>0</code> 的项（包括常数项）不包括在内。
	<ul>
<li>例如，<code>“0”</code> 的表达式输出为 <code>[]</code> 。</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong>你可以假设给定的表达式均有效。所有中间结果都在区间 <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code> 内。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1]
<strong>输出：</strong>["-1*a","14"]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>expression = "e - 8 + temperature - pressure",
evalvars = ["e", "temperature"], evalints = [1, 12]
<strong>输出：</strong>["-1*pressure","5"]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>expression = "(e + 8) * (e - 8)", evalvars = [], evalints = []
<strong>输出：</strong>["1*e*e","-64"]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= expression.length &lt;= 250</code></li>
<li><code>expression</code> 由小写英文字母，数字 <code>'+'</code>, <code>'-'</code>, <code>'*'</code>, <code>'('</code>, <code>')'</code>, <code>' '</code> 组成</li>
<li><code>expression</code> 不包含任何前空格或后空格</li>
<li><code>expression</code> 中的所有符号都用一个空格隔开</li>
<li><code>0 &lt;= evalvars.length &lt;= 100</code></li>
<li><code>1 &lt;= evalvars[i].length &lt;= 20</code></li>
<li><code>evalvars[i]</code> 由小写英文字母组成</li>
<li><code>evalints.length == evalvars.length</code></li>
<li><code>-100 &lt;= evalints[i] &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************<div id="title">773. Sliding Puzzle</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在一个 <code>2 x 3</code> 的板上（<code>board</code>）有 5 块砖瓦，用数字 <code>1~5</code> 来表示, 以及一块空缺用 <code>0</code> 来表示。一次 <strong>移动</strong> 定义为选择 <code>0</code> 与一个相邻的数字（上下左右）进行交换.</p>
<p>最终当板 <code>board</code> 的结果是 <code>[[1,2,3],[4,5,0]]</code> 谜板被解开。</p>
<p>给出一个谜板的初始状态 <code>board</code> ，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/29/slide1-grid.jpg"/></p>
<pre><strong>输入：</strong>board = [[1,2,3],[4,0,5]]
<strong>输出：</strong>1
<strong>解释：</strong>交换 0 和 5 ，1 步完成
</pre>
<p><strong>示例 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/29/slide2-grid.jpg"/></p>
<pre><strong>输入：</strong>board = [[1,2,3],[5,4,0]]
<strong>输出：</strong>-1
<strong>解释：</strong>没有办法完成谜板
</pre>
<p><strong>示例 3:</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/slide3-grid.jpg"/></p>
<pre><strong>输入：</strong>board = [[4,1,2],[5,0,3]]
<strong>输出：</strong>5
<strong>解释：</strong>
最少完成谜板的最少移动次数是 5 ，
一种移动路径:
尚未移动: [[4,1,2],[5,0,3]]
移动 1 次: [[4,1,2],[0,5,3]]
移动 2 次: [[0,1,2],[4,5,3]]
移动 3 次: [[1,0,2],[4,5,3]]
移动 4 次: [[1,2,0],[4,5,3]]
移动 5 次: [[1,2,3],[4,5,0]]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>board.length == 2</code></li>
<li><code>board[i].length == 3</code></li>
<li><code>0 &lt;= board[i][j] &lt;= 5</code></li>
<li><code>board[i][j]</code> 中每个值都 <strong>不同</strong></li>
</ul>
</div></div></div><br><br><hr><br>*************************<div id="title">778. Swim in Rising Water</div>
*************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在一个 <code>n x n</code> 的整数矩阵 <code>grid</code> 中，每一个方格的值 <code>grid[i][j]</code> 表示位置 <code>(i, j)</code> 的平台高度。</p>
<p>当开始下雨时，在时间为 <code>t</code> 时，水池中的水位为 <code>t</code> 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p>
<p>你从坐标方格的左上平台 <code>(0，0)</code> 出发。返回 <em>你到达坐标方格的右下平台 <code>(n-1, n-1)</code> 所需的最少时间 。</em></p>
<p> </p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg"/></p>
<pre><strong>输入:</strong> grid = [[0,2],[1,3]]
<strong>输出:</strong> 3
<strong>解释:</strong>
时间为0时，你位于坐标方格的位置为 <code>(0, 0)。</code>
此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。
等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置
</pre>
<p><strong>示例 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg"/></p>
<pre><strong>输入:</strong> grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
<strong>输出:</strong> 16
<strong>解释: </strong>最终的路线用加粗进行了标记。
我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>n == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>0 &lt;= grid[i][j] &lt; n<sup>2</sup></code></li>
<li><code>grid[i][j]</code> 中每个值 <strong>均无重复</strong></li>
</ul>
</div></div></div><br><br><hr><br>********************<div id="title">780. Reaching Points</div>
********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定四个整数 <code>sx</code> , <code>sy</code> ，<code>tx</code> 和 <code>ty</code>，如果通过一系列的<strong>转换</strong>可以从起点 <code>(sx, sy)</code> 到达终点 <code>(tx, ty)</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>从点 <code>(x, y)</code> 可以<strong>转换</strong>到 <code>(x, x+y)</code>  或者 <code>(x+y, y)</code>。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> sx = 1, sy = 1, tx = 3, ty = 5
<strong>输出:</strong> true
<strong>解释:
</strong>可以通过以下一系列<strong>转换</strong>从起点转换到终点：
(1, 1) -&gt; (1, 2)
(1, 2) -&gt; (3, 2)
(3, 2) -&gt; (3, 5)
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> sx = 1, sy = 1, tx = 2, ty = 2 
<strong>输出:</strong> false
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> sx = 1, sy = 1, tx = 1, ty = 1 
<strong>输出:</strong> true
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= sx, sy, tx, ty &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>****************************<div id="title">782. Transform to Chessboard</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个 <code>n x n</code> 的二维网络 <code>board</code> 仅由 <code>0</code> 和 <code>1</code> 组成 。每次移动，你能任意交换两列或是两行的位置。</p>
<p>返回 <em>将这个矩阵变为<strong>  “棋盘”  </strong>所需的最小移动次数 </em>。如果不存在可行的变换，输出 <code>-1</code>。</p>
<p><strong>“棋盘”</strong> 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/29/chessboard1-grid.jpg" style="height: 145px; width: 500px;"/></p>
<pre><strong>输入:</strong> board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
<strong>输出:</strong> 2
<strong>解释:</strong>一种可行的变换方式如下，从左到右：
第一次移动交换了第一列和第二列。
第二次移动交换了第二行和第三行。
</pre>
<p><strong>示例 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/29/chessboard2-grid.jpg"/></p>
<pre><strong>输入:</strong> board = [[0, 1], [1, 0]]
<strong>输出:</strong> 0
<strong>解释: </strong>注意左上角的格值为0时也是合法的棋盘，也是合法的棋盘.
</pre>
<p><strong>示例 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/29/chessboard3-grid.jpg"/></p>
<pre><strong>输入:</strong> board = [[1, 0], [1, 0]]
<strong>输出:</strong> -1
<strong>解释: </strong>任意的变换都不能使这个输入变为合法的棋盘。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == board.length</code></li>
<li><code>n == board[i].length</code></li>
<li><code>2 &lt;= n &lt;= 30</code></li>
<li><code>board[i][j]</code> 将只包含 <code>0</code>或 <code>1</code></li>
</ul>
</div></div></div><br><br><hr><br>***********************************************<div id="title">793. Preimage Size of Factorial Zeroes Function</div>
***********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p> <code>f(x)</code> 是 <code>x!</code> 末尾是 0 的数量。回想一下 <code>x! = 1 * 2 * 3 * ... * x</code>，且 <code>0! = 1</code> 。</p>
<ul>
<li>例如， <code>f(3) = 0</code> ，因为 <code>3! = 6</code> 的末尾没有 0 ；而 <code>f(11) = 2</code> ，因为 <code>11!= 39916800</code> 末端有 2 个 0 。</li>
</ul>
<p>给定 <code>k</code>，找出返回能满足 <code>f(x) = k</code> 的非负整数 <code>x</code> 的数量。</p>
<p> </p>
<p><strong>示例 1：</strong><strong> </strong></p>
<pre><strong>输入：</strong>k = 0<strong>
输出：</strong>5<strong>
解释：</strong>0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>k = 5
<strong>输出：</strong>0
<strong>解释：</strong>没有匹配到这样的 x!，符合 k = 5 的条件。</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> k = 3
<strong>输出:</strong> 5
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">798. Smallest Rotation with Highest Score</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个数组 <code>nums</code>，我们可以将它按一个非负整数 <code>k</code> 进行轮调，这样可以使数组变为 <code>[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]</code> 的形式。此后，任何值小于或等于其索引的项都可以记作一分。</p>
<ul>
<li>例如，数组为 <code>nums = [2,4,1,3,0]</code>，我们按 <code>k = 2</code> 进行轮调后，它将变成 <code>[1,3,0,2,4]</code>。这将记为 <code>3</code> 分，因为 <code>1 &gt; 0</code> [不计分]、<code>3 &gt; 1</code> [不计分]、<code>0 &lt;= 2</code> [计 1 分]、<code>2 &lt;= 3</code> [计 1 分]，<code>4 &lt;= 4</code> [计 1 分]。</li>
</ul>
<p>在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 <code>k</code> 。如果有多个答案，返回满足条件的最小的下标 <code>k</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [2,3,1,4,0]
<strong>输出：</strong>3
<strong>解释：</strong>
下面列出了每个 k 的得分：
k = 0,  nums = [2,3,1,4,0],    score 2
k = 1,  nums = [3,1,4,0,2],    score 3
k = 2,  nums = [1,4,0,2,3],    score 3
k = 3,  nums = [4,0,2,3,1],    score 4
k = 4,  nums = [0,2,3,1,4],    score 3
所以我们应当选择 k = 3，得分最高。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,3,0,2,4]
<strong>输出：</strong>0
<strong>解释：</strong>
nums 无论怎么变化总是有 3 分。
所以我们将选择最小的 k，即 0。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>
</ul>
</div></div></div><br><br><hr><br>***********************************************<div id="title">801. Minimum Swaps To Make Sequences Increasing</div>
***********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>我们有两个长度相等且不为空的整型数组 <code>nums1</code> 和 <code>nums2</code> 。在一次操作中，我们可以交换 <code>nums1[i]</code> 和 <code>nums2[i]</code>的元素。</p>
<ul>
<li>例如，如果 <code>nums1 = [1,2,3,<u>8</u>]</code> ， <code>nums2 =[5,6,7,<u>4</u>]</code> ，你可以交换 <code>i = 3</code> 处的元素，得到 <code>nums1 =[1,2,3,4]</code> 和 <code>nums2 =[5,6,7,8]</code> 。</li>
</ul>
<p>返回 <em>使 <code>nums1</code> 和 <code>nums2</code> <strong>严格递增 </strong>所需操作的最小次数</em> 。</p>
<p>数组 <code>arr</code> <strong>严格递增</strong> 且  <code>arr[0] &lt; arr[1] &lt; arr[2] &lt; ... &lt; arr[arr.length - 1]</code> 。</p>
<p><b>注意：</b></p>
<ul>
<li>用例保证可以实现操作。</li>
</ul>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> nums1 = [1,3,5,4], nums2 = [1,2,3,7]
<strong>输出:</strong> 1
<strong>解释: </strong>
交换 A[3] 和 B[3] 后，两个数组如下:
A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
两个数组均为严格递增的。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]
<strong>输出:</strong> 1
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>2 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>
<li><code>nums2.length == nums1.length</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 2 * 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>****************************<div id="title">803. Bricks Falling When Hit</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一个 <code>m x n</code> 的二元网格 <code>grid</code> ，其中 <code>1</code> 表示砖块，<code>0</code> 表示空白。砖块 <strong>稳定</strong>（不会掉落）的前提是：</p>
<ul>
<li>一块砖直接连接到网格的顶部，或者</li>
<li>至少有一块相邻（4 个方向之一）砖块<strong> 稳定 </strong>不会掉落时</li>
</ul>
<p>给你一个数组 <code>hits</code> ，这是需要依次消除砖块的位置。每当消除 <code>hits[i] = (rowi, coli)</code> 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而 <strong>掉落</strong> 。一旦砖块掉落，它会 <strong>立即</strong> 从网格 <code>grid</code> 中消失（即，它不会落在其他稳定的砖块上）。</p>
<p>返回一个数组 <code>result</code> ，其中 <code>result[i]</code> 表示第 <code>i</code> 次消除操作对应掉落的砖块数目。</p>
<p><strong>注意</strong>，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
<strong>输出：</strong>[2]
<strong>解释：</strong>网格开始为：
[[1,0,0,0]，
 [<strong>1</strong>,1,1,0]]
消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0]
 [0,<strong>1</strong>,<strong>1</strong>,0]]
两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：
[[1,0,0,0],
 [0,0,0,0]]
因此，结果为 [2] 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
<strong>输出：</strong>[0,0]
<strong>解释：</strong>网格开始为：
[[1,0,0,0],
 [1,<strong>1</strong>,0,0]]
消除 (1,1) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [1,0,0,0]]
剩下的砖都很稳定，所以不会掉落。网格保持不变：
[[1,0,0,0], 
 [<strong>1</strong>,0,0,0]]
接下来消除 (1,0) 处加粗的砖块，得到网格：
[[1,0,0,0],
 [0,0,0,0]]
剩下的砖块仍然是稳定的，所以不会有砖块掉落。
因此，结果为 [0,0] 。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
<li><code>1 &lt;= hits.length &lt;= 4 * 10<sup>4</sup></code></li>
<li><code>hits[i].length == 2</code></li>
<li><code>0 &lt;= x<sub>i </sub>&lt;= m - 1</code></li>
<li><code>0 &lt;= y<sub>i</sub> &lt;= n - 1</code></li>
<li>所有 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 互不相同</li>
</ul>
</div></div></div><br><br><hr><br>**********************************<div id="title">805. Split Array With Same Average</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定你一个整数数组 <code>nums</code></p>
<p>我们要将 <code>nums</code> 数组中的每个元素移动到 <code>A</code> 数组 或者 <code>B</code> 数组中，使得 <code>A</code> 数组和 <code>B</code> 数组不为空，并且 <code>average(A) == average(B)</code> 。</p>
<p>如果可以完成则返回<code>true</code> ， 否则返回 <code>false</code>  。</p>
<p><strong>注意：</strong>对于数组 <code>arr</code> ,  <code>average(arr)</code> 是 <code>arr</code> 的所有元素除以 <code>arr</code> 长度的和。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> nums = [1,2,3,4,5,6,7,8]
<strong>输出:</strong> true
<strong>解释: </strong>我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> nums = [3,1]
<strong>输出:</strong> false
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 30</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">810. Chalkboard XOR Game</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>黑板上写着一个非负整数数组 <code>nums[i]</code> 。</p>
<p>Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 <code>0</code> 的话，当前玩家游戏失败。 另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 <code>0</code>。</p>
<p>并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 <code>0</code> ，这个玩家获胜。</p>
<p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 <code>true</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入:</strong> nums = [1,1,2]
<strong>输出:</strong> false
<strong>解释:</strong> 
Alice 有两个选择: 擦掉数字 1 或 2。
如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。
如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> nums = [0,1]
<strong>输出:</strong> true
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> nums = [1,2,3]
<strong>输出:</strong> true
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt; 2<sup>16</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***************<div id="title">815. Bus Routes</div>
***************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个数组 <code>routes</code> ，表示一系列公交线路，其中每个 <code>routes[i]</code> 表示一条公交线路，第 <code>i</code> 辆公交车将会在上面循环行驶。</p>
<ul>
<li>例如，路线 <code>routes[0] = [1, 5, 7]</code> 表示第 <code>0</code> 辆公交车会一直按序列 <code>1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; ...</code> 这样的车站路线行驶。</li>
</ul>
<p>现在从 <code>source</code> 车站出发（初始时不在公交车上），要前往 <code>target</code> 车站。 期间仅可乘坐公交车。</p>
<p>求出 <strong>最少乘坐的公交车数量</strong> 。如果不可能到达终点车站，返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>routes = [[1,2,7],[3,6,7]], source = 1, target = 6
<strong>输出：</strong>2
<strong>解释：</strong>最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
<strong>输出：</strong>-1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= routes.length &lt;= 500</code>.</li>
<li><code>1 &lt;= routes[i].length &lt;= 10<sup>5</sup></code></li>
<li><code>routes[i]</code> 中的所有值 <strong>互不相同</strong></li>
<li><code>sum(routes[i].length) &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= routes[i][j] &lt; 10<sup>6</sup></code></li>
<li><code>0 &lt;= source, target &lt; 10<sup>6</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*************<div id="title">818. Race Car</div>
*************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate">你的赛车可以从位置 <code>0</code> 开始，并且速度为 <code>+1</code> ，在一条无限长的数轴上行驶。赛车也可以向负方向行驶。赛车可以按照由加速指令 <code>'A'</code> 和倒车指令 <code>'R'</code> 组成的指令序列自动行驶。
<ul>
<li>当收到指令 <code>'A'</code> 时，赛车这样行驶：
	<ul>
<li><code>position += speed</code></li>
<li><code>speed *= 2</code></li>
</ul>
</li>
<li>当收到指令 <code>'R'</code> 时，赛车这样行驶：
	<ul>
<li>如果速度为正数，那么<code>speed = -1</code></li>
<li>否则 <code>speed = 1</code></li>
</ul>
	当前所处位置不变。</li>
</ul>
<p>例如，在执行指令 <code>"AAR"</code> 后，赛车位置变化为 <code>0 --&gt; 1 --&gt; 3 --&gt; 3</code> ，速度变化为 <code>1 --&gt; 2 --&gt; 4 --&gt; -1</code> 。</p>
<p>给你一个目标位置 <code>target</code> ，返回能到达目标位置的最短指令序列的长度。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>target = 3
<strong>输出：</strong>2
<strong>解释：</strong>
最短指令序列是 "AA" 。
位置变化 0 --&gt; 1 --&gt; 3 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>target = 6
<strong>输出：</strong>5
<strong>解释：</strong>
最短指令序列是 "AAARA" 。
位置变化 0 --&gt; 1 --&gt; 3 --&gt; 7 --&gt; 7 --&gt; 6 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">827. Making A Large Island</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个大小为 <code>n x n</code> 二进制矩阵 <code>grid</code> 。<strong>最多</strong> 只能将一格 <code>0</code> 变成 <code>1</code> 。</p>
<p>返回执行此操作后，<code>grid</code> 中最大的岛屿面积是多少？</p>
<p><strong>岛屿</strong> 由一组上、下、左、右四个方向相连的 <code>1</code> 形成。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>grid = [[1, 0], [0, 1]]
<strong>输出:</strong> 3
<strong>解释:</strong> 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入: </strong>grid =<strong> </strong>[[1, 1], [1, 0]]
<strong>输出:</strong> 4
<strong>解释:</strong> 将一格0变成1，岛屿的面积扩大为 4。</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入: </strong>grid = [[1, 1], [1, 1]]
<strong>输出:</strong> 4
<strong>解释:</strong> 没有0可以让我们变成1，面积依然为 4。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************************************<div id="title">828. Count Unique Characters of All Substrings of a Given String</div>
****************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>我们定义了一个函数 <code>countUniqueChars(s)</code> 来统计字符串 <code>s</code> 中的唯一字符，并返回唯一字符的个数。</p>
<p>例如：<code>s = "LEETCODE"</code> ，则其中 <code>"L"</code>, <code>"T"</code>,<code>"C"</code>,<code>"O"</code>,<code>"D"</code> 都是唯一字符，因为它们只出现一次，所以 <code>countUniqueChars(s) = 5</code> 。</p>
<p>本题将会给你一个字符串 <code>s</code> ，我们需要返回 <code>countUniqueChars(t)</code> 的总和，其中 <code>t</code> 是 <code>s</code> 的子字符串。输入用例保证返回值为 32 位整数。</p>
<p>注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 <code>s</code> 的所有子字符串中的唯一字符）。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入: </strong>s = "ABC"
<strong>输出: </strong>10
<strong>解释:</strong> 所有可能的子串为："A","B","C","AB","BC" 和 "ABC"。
     其中，每一个子串都由独特字符构成。
     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入: </strong>s = "ABA"
<strong>输出: </strong>8
<strong>解释: </strong>除<code>了 countUniqueChars</code>("ABA") = 1 之外，其余与示例 1 相同。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "LEETCODE"
<strong>输出：</strong>92
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s</code> 只包含大写英文字符</li>
</ul>
</div></div></div><br><br><hr><br>****************************<div id="title">829. Consecutive Numbers Sum</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个正整数 <code>n</code>，返回 <em>连续正整数满足所有数字之和为 <code>n</code> 的组数</em> 。 </p>
<p> </p>
<p><strong>示</strong><strong>例 1:</strong></p>
<pre><strong>输入: </strong>n = 5
<strong>输出: </strong>2
<strong>解释: </strong>5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入: </strong>n = 9
<strong>输出: </strong>3
<strong>解释: </strong>9 = 4 + 5 = 2 + 3 + 4</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入: </strong>n = 15
<strong>输出: </strong>4
<strong>解释: </strong>15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code>​​​​​​​</li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">834. Sum of Distances in Tree</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个无向、连通的树。树中有 <code>n</code> 个标记为 <code>0...n-1</code> 的节点以及 <code>n-1</code> 条边 。</p>
<p>给定整数 <code>n</code> 和数组 <code>edges</code> ， <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>表示树中的节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间有一条边。</p>
<p>返回长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是树中第 <code>i</code> 个节点与所有其他节点之间的距离之和。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist1.jpg"/></p>
<pre><strong>输入: </strong>n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
<strong>输出: </strong>[8,12,6,10,10,10]
<strong>解释: </strong>树如图所示。
我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) 
也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。
</pre>
<p><strong>示例 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist2.jpg"/>
<pre><strong>输入:</strong> n = 1, edges = []
<strong>输出:</strong> [0]
</pre>
<p><strong>示例 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist3.jpg"/>
<pre><strong>输入:</strong> n = 2, edges = [[1,0]]
<strong>输出:</strong> [1,1]
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>
<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
<li>给定的输入保证为有效的树</li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">839. Similar String Groups</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>如果交换字符串 <code>X</code> 中的两个不同位置的字母，使得它和字符串 <code>Y</code> 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p>
<p>例如，<code>"tars"</code> 和 <code>"rats"</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)； <code>"rats"</code> 和 <code>"arts"</code> 也是相似的，但是 <code>"star"</code> 不与 <code>"tars"</code>，<code>"rats"</code>，或 <code>"arts"</code> 相似。</p>
<p>总之，它们通过相似性形成了两个关联组：<code>{"tars", "rats", "arts"}</code> 和 <code>{"star"}</code>。注意，<code>"tars"</code> 和 <code>"arts"</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p>
<p>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词。请问 <code>strs</code> 中有多少个相似字符串组？</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>strs = ["tars","rats","arts","star"]
<strong>输出：</strong>2
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>strs = ["omv","ovm"]
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 300</code></li>
<li><code>1 &lt;= strs[i].length &lt;= 300</code></li>
<li><code>strs[i]</code> 只包含小写字母。</li>
<li><code>strs</code> 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li>
</ul>
</div></div></div><br><br><hr><br>*******************<div id="title">843. Guess the Word</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个由 <strong>不同</strong> 字符串组成的单词列表 <code>words</code> ，其中 <code>words[i]</code> 长度均为 <code>6</code> 。<code>words</code> 中的一个单词将被选作秘密单词 <code>secret</code> 。</p>
<p>另给你一个辅助对象 <code>Master</code> ，你可以调用 <code>Master.guess(word)</code> 来猜单词，其中参数 <code>word</code> 长度为 6 且必须是 <code>words</code> 中的字符串。</p>
<p><code>Master.guess(word)</code> 将会返回如下结果：</p>
<ul>
<li>如果 <code>word</code> 不是 <code>words</code> 中的字符串，返回 <code>-1</code> ，或者</li>
<li>一个整数，表示你所猜测的单词 <code>word</code> 与 <strong>秘密单词</strong> <code>secret</code> 的准确匹配（值和位置同时匹配）的数目。</li>
</ul>
<p>每组测试用例都会包含一个参数 <code>allowedGuesses</code> ，其中 <code>allowedGuesses</code> 是你可以调用 <code>Master.guess(word)</code> 的最大次数。</p>
<p>对于每组测试用例，在不超过允许猜测的次数的前提下，你应该调用 <code>Master.guess</code> 来猜出秘密单词。最终，你将会得到以下结果：</p>
<ul>
<li>如果你调用 <code>Master.guess</code> 的次数大于 <code>allowedGuesses</code> 所限定的次数或者你没有用 <code>Master.guess</code> 猜到秘密单词，则得到 <strong><code>"Either you took too many guesses, or you did not find the secret word."</code> 。</strong></li>
<li>如果你调用 <code>Master.guess</code> 猜到秘密单词，且调用 <code>Master.guess</code> 的次数小于或等于 <code>allowedGuesses</code> ，则得到 <strong><code>"You guessed the secret word correctly."</code> 。</strong></li>
</ul>
<p>生成的测试用例保证你可以利用某种合理的策略（而不是暴力）猜到秘密单词。</p>
 

<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>secret = "acckzz", words = ["acckzz","ccbazz","eiowzz","abcczz"], allowedGuesses = 10
<strong>输出：</strong>You guessed the secret word correctly.
<strong>解释：</strong>
master.guess("aaaaaa") 返回 -1 ，因为 "aaaaaa" 不在 words 中。
master.guess("acckzz") 返回 6 ，因为 "acckzz" 是秘密单词 secret ，共有 6 个字母匹配。
master.guess("ccbazz") 返回 3 ，因为 "ccbazz" 共有 3 个字母匹配。
master.guess("eiowzz") 返回 2 ，因为 "eiowzz" 共有 2 个字母匹配。
master.guess("abcczz") 返回 4 ，因为 "abcczz" 共有 4 个字母匹配。
一共调用 5 次 master.guess ，其中一个为秘密单词，所以通过测试用例。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>secret = "hamada", words = ["hamada","khaled"], allowedGuesses = 10
<strong>输出：</strong>You guessed the secret word correctly.
<strong>解释：</strong>共有 2 个单词，且其中一个为秘密单词，可以通过测试用例。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 100</code></li>
<li><code>words[i].length == 6</code></li>
<li><code>words[i]</code> 仅由小写英文字母组成</li>
<li><code>words</code> 中所有字符串 <strong>互不相同</strong></li>
<li><code>secret</code> 存在于 <code>words</code> 中</li>
<li><code>10 &lt;= allowedGuesses &lt;= 30</code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************<div id="title">847. Shortest Path Visiting All Nodes</div>
*************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>存在一个由 <code>n</code> 个节点组成的无向连通图，图中的节点按从 <code>0</code> 到 <code>n - 1</code> 编号。</p>
<p>给你一个数组 <code>graph</code> 表示这个图。其中，<code>graph[i]</code> 是一个列表，由所有与节点 <code>i</code> 直接相连的节点组成。</p>
<p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p>
<p> </p>
<ol>
</ol>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg" style="width: 222px; height: 183px;"/>
<pre><strong>输入：</strong>graph = [[1,2,3],[0],[0],[0]]
<strong>输出：</strong>4
<strong>解释：</strong>一种可能的路径为 [1,0,2,0,3]</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg" style="width: 382px; height: 222px;"/></p>
<pre><strong>输入：</strong>graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
<strong>输出：</strong>4
<strong>解释：</strong>一种可能的路径为 [0,1,4,2,3]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == graph.length</code></li>
<li><code>1 &lt;= n &lt;= 12</code></li>
<li><code>0 &lt;= graph[i].length &lt; n</code></li>
<li><code>graph[i]</code> 不包含 <code>i</code></li>
<li>如果 <code>graph[a]</code> 包含 <code>b</code> ，那么 <code>graph[b]</code> 也包含 <code>a</code></li>
<li>输入的图总是连通图</li>
</ul>
</div></div></div><br><br><hr><br>**********************<div id="title">850. Rectangle Area II</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>我们给出了一个（轴对齐的）二维矩形列表 <code>rectangles</code> 。 对于 <code>rectangle[i] = [x<sub>i1</sub>, y<sub>i1</sub>, x<sub>i2</sub>, y<sub>i2</sub>]</code>，表示第 <code>i</code> 个矩形的坐标， <code>(x<sub>i1</sub>, y<sub>i1</sub>)</code> 是该矩形 <strong>左下角</strong> 的坐标， <code>(x<sub>i2</sub>, y<sub>i2</sub>)</code> 是该矩形 <strong>右上角</strong> 的坐标。</p>
<p>计算平面中所有 <code>rectangles</code> 所覆盖的 <strong>总面积 </strong>。任何被两个或多个矩形覆盖的区域应只计算 <strong>一次</strong> 。</p>
<p>返回<em> <strong>总面积</strong> </em>。因为答案可能太大，返回 <code>10<sup>9</sup> + 7</code> 的 <strong>模</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png" style="height: 300px; width: 400px;"/></p>
<pre><strong>输入：</strong>rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
<strong>输出：</strong>6
<strong>解释：</strong>如图所示，三个矩形覆盖了总面积为6的区域。
从(1,1)到(2,2)，绿色矩形和红色矩形重叠。
从(1,0)到(2,3)，三个矩形都重叠。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>rectangles = [[0,0,1000000000,1000000000]]
<strong>输出：</strong>49
<strong>解释：</strong>答案是 10<sup>18</sup> 对 (10<sup>9</sup> + 7) 取模的结果， 即 49 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= rectangles.length &lt;= 200</code></li>
<li><code>rectanges[i].length = 4</code></li>
<li><code>0 &lt;= x<sub>i1</sub>, y<sub>i1</sub>, x<sub>i2</sub>, y<sub>i2</sub> &lt;= 10<sup>9</sup></code></li>
<li>矩形叠加覆盖后的总面积不会超越 <code>2^63 - 1</code> ，这意味着可以用一个 64 位有符号整数来保存面积结果。</li>
</ul>
</div></div></div><br><br><hr><br>**********************<div id="title">854. K-Similar Strings</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>对于某些非负整数 <code>k</code> ，如果交换 <code>s1</code> 中两个字母的位置恰好 <code>k</code> 次，能够使结果字符串等于 <code>s2</code> ，则认为字符串 <code>s1</code> 和 <code>s2</code> 的<strong> 相似度为 </strong><code>k</code><strong> </strong><strong>。</strong></p>
<p>给你两个字母异位词 <code>s1</code> 和 <code>s2</code> ，返回 <code>s1</code> 和 <code>s2</code> 的相似度 <code>k</code><strong> </strong>的最小值。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s1 = "ab", s2 = "ba"
<strong>输出：</strong>1
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s1 = "abc", s2 = "bca"
<strong>输出：</strong>2
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s1.length &lt;= 20</code></li>
<li><code>s2.length == s1.length</code></li>
<li><code>s1</code> 和 <code>s2</code>  只包含集合 <code>{'a', 'b', 'c', 'd', 'e', 'f'}</code> 中的小写字母</li>
<li><code>s2</code> 是 <code>s1</code> 的一个字母异位词</li>
</ul>
</div></div></div><br><br><hr><br>***********************************<div id="title">857. Minimum Cost to Hire K Workers</div>
***********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有 <code>n</code> 名工人。 给定两个数组 <code>quality</code> 和 <code>wage</code> ，其中，<code>quality[i]</code> 表示第 <code>i</code> 名工人的工作质量，其最低期望工资为 <code>wage[i]</code> 。</p>
<p>现在我们想雇佣 <code>k</code> 名工人组成一个<em>工资组。</em>在雇佣 一组 <code>k</code> 名工人时，我们必须按照下述规则向他们支付工资：</p>
<ol>
<li>对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。</li>
<li>工资组中的每名工人至少应当得到他们的最低期望工资。</li>
</ol>
<p>给定整数 <code>k</code> ，返回 <em>组成满足上述条件的付费群体所需的最小金额 </em>。在实际答案的 <code>10<sup>-5</sup></code> 以内的答案将被接受。。</p>
<p> </p>
<ol>
</ol>
<p><strong>示例 1：</strong></p>
<pre><strong>输入： </strong>quality = [10,20,5], wage = [70,50,30], k = 2
<strong>输出： </strong>105.00000
<strong>解释：</strong> 我们向 0 号工人支付 70，向 2 号工人支付 35。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入： </strong>quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3
<strong>输出： </strong>30.66667
<strong>解释： </strong>我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == quality.length == wage.length</code></li>
<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>
<li><code>1 &lt;= quality[i], wage[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>******************************************<div id="title">862. Shortest Subarray with Sum at Least K</div>
******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出 <code>nums</code> 中和至少为 <code>k</code> 的 <strong>最短非空子数组</strong> ，并返回该子数组的长度。如果不存在这样的 <strong>子数组</strong> ，返回 <code>-1</code> 。</p>
<p><strong>子数组</strong> 是数组中 <strong>连续</strong> 的一部分。</p>
<p> </p>
<ol>
</ol>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1], k = 1
<strong>输出：</strong>1
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,2], k = 4
<strong>输出：</strong>-1
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [2,-1,2], k = 3
<strong>输出：</strong>3
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************<div id="title">864. Shortest Path to Get All Keys</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个二维网格 <code>grid</code> ，其中：</p>
<ul>
<li><font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">'.'</span></span></font></font> 代表一个空房间</li>
<li><font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">'#'</span></span></font></font> 代表一堵</li>
<li><font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">'@'</span></span></font></font> 是起点</li>
<li>小写字母代表钥匙</li>
<li>大写字母代表锁</li>
</ul>
<p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p>
<p>假设 k 为 钥匙/锁 的个数，且满足 <code>1 &lt;= k &lt;= 6</code>，字母表中的前 <code>k</code> 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p>
<p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg"/></p>
<pre><strong>输入：</strong>grid = ["@.a.#","###.#","b.A.B"]
<strong>输出：</strong>8
<strong>解释：</strong>目标是获得所有钥匙，而不是打开所有锁。
</pre>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg"/></p>
<pre><strong>输入：</strong>grid = ["@..aA","..B#.","....b"]
<strong>输出：</strong>6
</pre>
<p><strong>示例 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg"/>
<pre><strong>输入:</strong> grid = ["@Aa"]
<strong>输出:</strong> -1</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 30</code></li>
<li><code>grid[i][j]</code> 只含有 <code>'.'</code>, <code>'#'</code>, <code>'@'</code>, <code>'a'-</code><code>'f</code><code>'</code> 以及 <code>'A'-'F'</code></li>
<li>钥匙的数目范围是 <code>[1, 6]</code> </li>
<li>每个钥匙都对应一个 <strong>不同</strong> 的字母</li>
<li>每个钥匙正好打开一个对应的锁</li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">871. Minimum Number of Refueling Stops</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 <code>target</code> 英里处。</p>
<p>沿途有加油站，每个 <code>station[i]</code> 代表一个加油站，它位于出发位置东面 <code>station[i][0]</code> 英里处，并且有 <code>station[i][1]</code> 升汽油。</p>
<p>假设汽车油箱的容量是无限的，其中最初有 <code>startFuel</code> 升燃料。它每行驶 1 英里就会用掉 1 升汽油。</p>
<p>当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p>
<p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 <code>-1</code> 。</p>
<p>注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>target = 1, startFuel = 1, stations = []
<strong>输出：</strong>0
<strong>解释：</strong>我们可以在不加油的情况下到达目的地。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>target = 100, startFuel = 1, stations = [[10,100]]
<strong>输出：</strong>-1
<strong>解释：</strong>我们无法抵达目的地，甚至无法到达第一个加油站。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
<strong>输出：</strong>2
<strong>解释：</strong>
我们出发时有 10 升燃料。
我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。
然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），
并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。
我们沿途在1两个加油站停靠，所以返回 2 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= target, startFuel, stations[i][1] &lt;= 10^9</code></li>
<li><code>0 &lt;= stations.length &lt;= 500</code></li>
<li><code>0 &lt; stations[0][0] &lt; stations[1][0] &lt; ... &lt; stations[stations.length-1][0] &lt; target</code></li>
</ol>
</div></div></div><br><br><hr><br>***********************<div id="title">878. Nth Magical Number</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个正整数如果能被 <code>a</code> 或 <code>b</code> 整除，那么它是神奇的。</p>
<p>给定三个整数 <code>n</code> , <code>a</code> , <code>b</code> ，返回第 <code>n</code> 个神奇的数字。因为答案可能很大，所以返回答案 <strong>对 </strong><code>10<sup>9</sup> + 7</code> <strong>取模 </strong>后的值。</p>
<p> </p>
<ol>
</ol>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 1, a = 2, b = 3
<strong>输出：</strong>2
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 4, a = 2, b = 3
<strong>输出：</strong>6
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
<li><code>2 &lt;= a, b &lt;= 4 * 10<sup>4</sup></code></li>
</ul>
<p> </p>
</div></div></div><br><br><hr><br>***********************<div id="title">879. Profitable Schemes</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>集团里有 <code>n</code> 名员工，他们可以完成各种各样的工作创造利润。</p>
<p>第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>
<p>工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。</p>
<p>有多少种计划可以选择？因为答案很大，所以<strong> 返回结果模 </strong><code>10^9 + 7</code><strong> 的值</strong>。</p>
<div class="original__bRMd">
<div>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 5, minProfit = 3, group = [2,2], profit = [2,3]
<strong>输出：</strong>2
<strong>解释：</strong>至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
总的来说，有两种计划。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
<strong>输出：</strong>7
<strong>解释：</strong>至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。
有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</pre>
</div>
</div>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>0 &lt;= minProfit &lt;= 100</code></li>
<li><code>1 &lt;= group.length &lt;= 100</code></li>
<li><code>1 &lt;= group[i] &lt;= 100</code></li>
<li><code>profit.length == group.length</code></li>
<li><code>0 &lt;= profit[i] &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">882. Reachable Nodes In Subdivided Graph</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个无向图（<strong>原始图</strong>），图中有 <code>n</code> 个节点，编号从 <code>0</code> 到 <code>n - 1</code> 。你决定将图中的每条边 <strong>细分</strong> 为一条节点链，每条边之间的新节点数各不相同。</p>
<p>图用由边组成的二维数组 <code>edges</code> 表示，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cnt<sub>i</sub>]</code> 表示原始图中节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在一条边，<code>cnt<sub>i</sub></code> 是将边 <strong>细分</strong> 后的新节点总数。注意，<code>cnt<sub>i</sub> == 0</code> 表示边不可细分。</p>
<p>要 <strong>细分</strong> 边 <code>[ui, vi]</code> ，需要将其替换为 <code>(cnt<sub>i</sub> + 1)</code> 条新边，和 <code>cnt<sub>i</sub></code> 个新节点。新节点为 <code>x<sub>1</sub></code>, <code>x<sub>2</sub></code>, ..., <code>x<sub>cnt<sub>i</sub></sub></code> ，新边为 <code>[u<sub>i</sub>, x<sub>1</sub>]</code>, <code>[x<sub>1</sub>, x<sub>2</sub>]</code>, <code>[x<sub>2</sub>, x<sub>3</sub>]</code>, ..., <code>[x<sub>cnt<sub>i</sub>+1</sub>, x<sub>cnt<sub>i</sub></sub>]</code>, <code>[x<sub>cnt<sub>i</sub></sub>, v<sub>i</sub>]</code> 。</p>
<p>现在得到一个 <strong>新的细分图</strong> ，请你计算从节点 <code>0</code> 出发，可以到达多少个节点？如果节点间距离是 <code>maxMoves</code> 或更少，则视为 <strong>可以到达</strong> 。</p>
<p>给你原始图和 <code>maxMoves</code> ，返回 <em>新的细分图中从节点 <code>0</code> 出发</em><strong><em> 可到达的节点数</em></strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png" style="height: 247px; width: 600px;"/>
<pre><strong>输入：</strong>edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3
<strong>输出：</strong>13
<strong>解释：</strong>边的细分情况如上图所示。
可以到达的节点已经用黄色标注出来。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4
<strong>输出：</strong>23
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5
<strong>输出：</strong>1
<strong>解释：</strong>节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2, 10<sup>4</sup>)</code></li>
<li><code>edges[i].length == 3</code></li>
<li><code>0 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt; n</code></li>
<li>图中 <strong>不存在平行边</strong></li>
<li><code>0 &lt;= cnt<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
<li><code>0 &lt;= maxMoves &lt;= 10<sup>9</sup></code></li>
<li><code>1 &lt;= n &lt;= 3000</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************<div id="title">887. Super Egg Drop</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>
<p>已知存在楼层 <code>f</code> ，满足 <code>0 &lt;= f &lt;= n</code> ，任何从<strong> 高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。</p>
<p>请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p>
 

<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>k = 1, n = 2
<strong>输出：</strong>2
<strong>解释：</strong>
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
如果它没碎，那么肯定能得出 f = 2 。 
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>k = 2, n = 6
<strong>输出：</strong>3
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>k = 3, n = 14
<strong>输出：</strong>4
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">891. Sum of Subsequence Widths</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个序列的 <strong>宽度</strong> 定义为该序列中最大元素和最小元素的差值。</p>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 的所有非空 <strong>子序列</strong> 的 <strong>宽度之和</strong> 。由于答案可能非常大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>
<p><strong>子序列</strong> 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，<code>[3,6,2,7]</code> 就是数组 <code>[0,3,1,6,2,2,7]</code> 的一个子序列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [2,1,3]
<strong>输出：</strong>6
<strong>解释：</strong>子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。
相应的宽度是 0, 0, 0, 1, 1, 2, 2 。
宽度之和是 6 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [2]
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>****************************<div id="title">895. Maximum Frequency Stack</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出<strong>出现频率</strong>最高的元素。</p>
<p>实现 <code>FreqStack</code> 类:</p>
<ul>
<li><code>FreqStack()</code> 构造一个空的堆栈。</li>
<li><code>void push(int val)</code> 将一个整数 <code>val</code> 压入栈顶。</li>
<li><code>int pop()</code> 删除并返回堆栈中出现频率最高的元素。
	<ul>
<li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li>
</ul>
</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>
["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
<strong>输出：</strong>[null,null,null,null,null,null,null,5,7,5,4]
<strong>解释：</strong>
FreqStack = new FreqStack();
freqStack.push (5);//堆栈为 [5]
freqStack.push (7);//堆栈是 [5,7]
freqStack.push (5);//堆栈是 [5,7,5]
freqStack.push (7);//堆栈是 [5,7,5,7]
freqStack.push (4);//堆栈是 [5,7,5,7,4]
freqStack.push (5);//堆栈是 [5,7,5,7,4,5]
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。
freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。
freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。
freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= val &lt;= 10<sup>9</sup></code></li>
<li><code>push</code> 和 <code>pop</code> 的操作数不大于 <code>2 * 10<sup>4</sup></code>。</li>
<li>输入保证在调用 <code>pop</code> 之前堆栈中至少有一个元素。</li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">899. Orderly Queue</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以从 <code>s</code> 的前 <code>k</code> 个字母中选择一个，并把它加到字符串的末尾。</p>
<p>返回 <em>在应用上述步骤的任意数量的移动后，字典上最小的字符串 </em>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "cba", k = 1
<strong>输出：</strong>"acb"
<strong>解释：</strong>
在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。
在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "baaca", k = 3
<strong>输出：</strong>"aaabc"
<strong>解释：
</strong>在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。
在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= S.length &lt;= 1000</code></li>
<li><code>s</code> 只由小写字母组成。</li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">902. Numbers At Most N Given Digit Set</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个按 <strong>非递减顺序</strong> 排列的数字数组 <code>digits</code> 。你可以用任意次数 <code>digits[i]</code> 来写的数字。例如，如果 <code>digits = ['1','3','5']</code>，我们可以写数字，如 <code>'13'</code>, <code>'551'</code>, 和 <code>'1351315'</code>。</p>
<p>返回 <em>可以生成的小于或等于给定整数 <code>n</code> 的正整数的个数</em> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>digits = ["1","3","5","7"], n = 100
<strong>输出：</strong>20
<strong>解释：</strong>
可写出的 20 个数字是：
1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>digits = ["1","4","9"], n = 1000000000
<strong>输出：</strong>29523
<strong>解释：</strong>
我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，
81 个四位数字，243 个五位数字，729 个六位数字，
2187 个七位数字，6561 个八位数字和 19683 个九位数字。
总共，可以使用D中的数字写出 29523 个整数。</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入：</strong>digits = ["7"], n = 8
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= digits.length &lt;= 9</code></li>
<li><code>digits[i].length == 1</code></li>
<li><code>digits[i]</code> 是从 <code>'1'</code> 到 <code>'9'</code> 的数</li>
<li><code>digits</code> 中的所有值都 <strong>不同</strong> </li>
<li><code>digits</code> 按 <strong>非递减顺序</strong> 排列</li>
<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***************************************<div id="title">903. Valid Permutations for DI Sequence</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个长度为 <code>n</code> 的字符串 <code>s</code> ，其中 <code>s[i]</code> 是:</p>
<ul>
<li><code>“D”</code> 意味着减少，或者</li>
<li><code>“I”</code> 意味着增加</li>
</ul>
<p><strong>有效排列</strong> 是对有 <code>n + 1</code> 个在 <code>[0, n]</code>  范围内的整数的一个排列 <code>perm</code> ，使得对所有的 <code>i</code>：</p>
<ul>
<li>如果 <code>s[i] == 'D'</code>，那么 <code>perm[i] &gt; perm[i+1]</code>，以及；</li>
<li>如果 <code>s[i] == 'I'</code>，那么 <code>perm[i] &lt; perm[i+1]</code>。</li>
</ul>
<p>返回 <em><strong>有效排列 </strong> </em><code>perm</code><em>的数量 </em>。因为答案可能很大，所以请<strong>返回你的答案对</strong> <code>10<sup>9</sup> + 7</code><strong> 取余</strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "DID"
<strong>输出：</strong>5
<strong>解释：</strong>
(0, 1, 2, 3) 的五个有效排列是：
(1, 0, 3, 2)
(2, 0, 3, 1)
(2, 1, 3, 0)
(3, 0, 2, 1)
(3, 1, 2, 0)
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> s = "D"
<strong>输出:</strong> 1
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>n == s.length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>s[i]</code> 不是 <code>'I'</code> 就是 <code>'D'</code></li>
</ul>
</div></div></div><br><br><hr><br>**********************<div id="title">906. Super Palindromes</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。</p>
<p>现在，给定两个正整数 <code>L</code> 和 <code>R</code> （以字符串形式表示），返回包含在范围 <code>[L, R]</code> 中的超级回文数的数目。</p>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>L = "4", R = "1000"
<strong>输出：</strong>4
<strong>解释：
</strong>4，9，121，以及 484 是超级回文数。
注意 676 不是一个超级回文数： 26 * 26 = 676，但是 26 不是回文数。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= len(L) &lt;= 18</code></li>
<li><code>1 &lt;= len(R) &lt;= 18</code></li>
<li><code>L</code> 和 <code>R</code> 是表示 <code>[1, 10^18)</code> 范围的整数的字符串。</li>
<li><code>int(L) &lt;= int(R)</code></li>
</ol>
<p> </p>
</div></div></div><br><br><hr><br>******************<div id="title">913. Cat and Mouse</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>两位玩家分别扮演猫和老鼠，在一张 <strong>无向</strong> 图上进行游戏，两人轮流行动。</p>
<p>图的形式是：<code>graph[a]</code> 是一个列表，由满足 <code>ab</code> 是图中的一条边的所有节点 <code>b</code> 组成。</p>
<p>老鼠从节点 <code>1</code> 开始，第一个出发；猫从节点 <code>2</code> 开始，第二个出发。在节点 <code>0</code> 处有一个洞。</p>
<p>在每个玩家的行动中，他们 <strong>必须</strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 <code>1</code> ，那么它必须移动到 <code>graph[1]</code> 中的任一节点。</p>
<p>此外，猫无法移动到洞中（节点 <code>0</code>）。</p>
<p>然后，游戏在出现以下三种情形之一时结束：</p>
<ul>
<li>如果猫和老鼠出现在同一个节点，猫获胜。</li>
<li>如果老鼠到达洞中，老鼠获胜。</li>
<li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li>
</ul>
<p>给你一张图 <code>graph</code> ，并假设两位玩家都都以最佳状态参与游戏：</p>
<ul>
<li>如果老鼠获胜，则返回 <code>1</code>；</li>
<li>如果猫获胜，则返回 <code>2</code>；</li>
<li>如果平局，则返回 <code>0</code> 。</li>
</ul>
 

<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg" style="width: 300px; height: 300px;"/>
<pre><strong>输入：</strong>graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
<strong>输出：</strong>0
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/17/cat2.jpg" style="width: 200px; height: 200px;"/>
<pre><strong>输入：</strong>graph = [[1,3],[0],[3],[0,2]]
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= graph.length &lt;= 50</code></li>
<li><code>1 &lt;= graph[i].length &lt; graph.length</code></li>
<li><code>0 &lt;= graph[i][j] &lt; graph.length</code></li>
<li><code>graph[i][j] != i</code></li>
<li><code>graph[i]</code> 互不相同</li>
<li>猫和老鼠在游戏中总是移动</li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">920. Number of Music Playlists</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你的音乐播放器里有 <code>N</code> 首不同的歌，在旅途中，你的旅伴想要听 <code>L</code> 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：</p>
<ul>
<li>每首歌至少播放一次。</li>
<li>一首歌只有在其他 <code>K</code> 首歌播放完之后才能再次播放。</li>
</ul>
<p>返回可以满足要求的播放列表的数量。<strong>由于答案可能非常大，请返回它模 <code>10^9 + 7</code> 的结果。</strong></p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>N = 3, L = 3, K = 1
<strong>输出：</strong>6
<strong>解释：</strong>有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1].
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>N = 2, L = 3, K = 0
<strong>输出：</strong>6
<strong>解释：</strong>有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>N = 2, L = 3, K = 1
<strong>输出：</strong>2
<strong>解释：</strong>有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= K &lt; N &lt;= L &lt;= 100</code></li>
</ol>
</div></div></div><br><br><hr><br>****************************<div id="title">924. Minimize Malware Spread</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给出了一个由 <code>n</code> 个节点组成的网络，用 <code>n × n</code> 个邻接矩阵图 <code>graph</code> 表示。在节点网络中，当 <code>graph[i][j] = 1</code> 时，表示节点 <code>i</code> 能够直接连接到另一个节点 <code>j</code>。 </p>
<p>一些节点 <code>initial</code> 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p>
<p>假设 <code>M(initial)</code> 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p>
<p>如果从 <code>initial</code> 中<strong>移除某一节点</strong>能够最小化 <code>M(initial)</code>， 返回该节点。如果有多个节点满足条件，就返回<strong>索引最小</strong>的节点。</p>
<p>请注意，如果某个节点已从受感染节点的列表 <code>initial</code> 中删除，它以后仍有可能因恶意软件传播而受到感染。</p>
<p> </p>
<ol>
</ol>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>输出：</strong>0
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
<strong>输出：</strong>0
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == graph.length</code></li>
<li><code>n == graph[i].length</code></li>
<li><code>2 &lt;= n &lt;= 300</code></li>
<li><code>graph[i][j] == 0</code> 或 <code>1</code>.</li>
<li><code>graph[i][j] == graph[j][i]</code></li>
<li><code>graph[i][i] == 1</code></li>
<li><code>1 &lt;= initial.length &lt;= n</code></li>
<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
<li><code>initial</code> 中所有整数均<strong>不重复</strong></li>
</ul>
</div></div></div><br><br><hr><br>**********************<div id="title">927. Three Equal Parts</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个由 <code>0</code> 和 <code>1</code> 组成的数组 <code>arr</code> ，将数组分成  <strong>3 个非空的部分</strong> ，使得所有这些部分表示相同的二进制值。</p>
<p>如果可以做到，请返回<strong>任何</strong> <code>[i, j]</code>，其中 <code>i+1 &lt; j</code>，这样一来：</p>
<ul>
<li><code>arr[0], arr[1], ..., arr[i]</code> 为第一部分；</li>
<li><code>arr[i + 1], arr[i + 2], ..., arr[j - 1]</code> 为第二部分；</li>
<li><code>arr[j], arr[j + 1], ..., arr[arr.length - 1]</code> 为第三部分。</li>
<li>这三个部分所表示的二进制值相等。</li>
</ul>
<p>如果无法做到，就返回 <code>[-1, -1]</code>。</p>
<p>注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，<code>[1,1,0]</code> 表示十进制中的 <code>6</code>，而不会是 <code>3</code>。此外，前导零也是<strong>被允许</strong>的，所以 <code>[0,1,1]</code> 和 <code>[1,1]</code> 表示相同的值。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>arr = [1,0,1,0,1]
<strong>输出：</strong>[0,3]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>arr = [1,1,0,1,1]
<strong>输出：</strong>[-1,-1]</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入：</strong>arr = [1,1,0,0,1]
<strong>输出：</strong>[0,2]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= arr.length &lt;= 3 * 10<sup>4</sup></code></li>
<li><code>arr[i]</code> 是 <code>0</code> 或 <code>1</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">928. Minimize Malware Spread II</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个由 <code>n</code> 个节点组成的网络，用 <code>n x n</code> 个邻接矩阵 <code>graph</code> 表示。在节点网络中，只有当 <code>graph[i][j] = 1</code> 时，节点 <code>i</code> 能够直接连接到另一个节点 <code>j</code>。</p>
<p>一些节点 <code>initial</code> 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p>
<p>假设 <code>M(initial)</code> 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p>
<p>我们可以从 <code>initial</code> 中<strong>删除一个节点</strong>，<strong>并完全移除该节点以及从该节点到任何其他节点的任何连接。</strong></p>
<p>请返回移除后能够使 <code>M(initial)</code> 最小化的节点。如果有多个节点满足条件，返回索引 <strong>最小的节点</strong> 。</p>
<p> </p>
<ol>
</ol>
<p><strong>示例 1：</strong></p>
<pre><strong>输出：</strong>graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>输入：</strong>0
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
<strong>输出：</strong>1
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == graph.length</code></li>
<li><code>n == graph[i].length</code></li>
<li><code>2 &lt;= n &lt;= 300</code></li>
<li><code>graph[i][j]</code> 是 <code>0</code> 或 <code>1</code>.</li>
<li><code>graph[i][j] == graph[j][i]</code></li>
<li><code>graph[i][i] == 1</code></li>
<li><code>1 &lt;= initial.length &lt; n</code></li>
<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
<li> <code>initial</code> 中每个整数都<strong>不同</strong></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">936. Stamping The Sequence</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你想要用<strong>小写字母</strong>组成一个目标字符串 <code>target</code>。 </p>
<p>开始的时候，序列由 <code>target.length</code> 个 <code>'?'</code> 记号组成。而你有一个小写字母印章 <code>stamp</code>。</p>
<p>在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行 <code>10 * target.length</code>  个回合。</p>
<p>举个例子，如果初始序列为 "?????"，而你的印章 <code>stamp</code> 是 <code>"abc"</code>，那么在第一回合，你可以得到 "abc??"、"?abc?"、"??abc"。（请注意，印章必须完全包含在序列的边界内才能盖下去。）</p>
<p>如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。</p>
<p>例如，如果序列是 "ababc"，印章是 <code>"abc"</code>，那么我们就可以返回与操作 "?????" -&gt; "abc??" -&gt; "ababc" 相对应的答案 <code>[0, 2]</code>；</p>
<p>另外，如果可以印出序列，那么需要保证可以在 <code>10 * target.length</code> 个回合内完成。任何超过此数字的答案将不被接受。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>stamp = "abc", target = "ababc"
<strong>输出：</strong>[0,2]
（[1,0,2] 以及其他一些可能的结果也将作为答案被接受）
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>stamp = "abca", target = "aabcaca"
<strong>输出：</strong>[3,0,1]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= stamp.length &lt;= target.length &lt;= 1000</code></li>
<li><code>stamp</code> 和 <code>target</code> 只包含小写字母。</li>
</ol>
</div></div></div><br><br><hr><br>*****************************<div id="title">940. Distinct Subsequences II</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串 <code>s</code>，计算 <code>s</code> 的 <strong>不同非空子序列</strong> 的个数。因为结果可能很大，所以返回答案需要对<strong> </strong><strong><code>10^9 + 7</code> 取余</strong> 。</p>
<p>字符串的 <strong>子序列</strong> 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。</p>
<ul>
<li>例如，<code>"ace"</code> 是 <code>"<em><strong>a</strong></em>b<em><strong>c</strong></em>d<em><strong>e</strong></em>"</code> 的一个子序列，但 <code>"aec"</code> 不是。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "abc"
<strong>输出：</strong>7
<strong>解释：</strong>7 个不同的子序列分别是 "a", "b", "c", "ab", "ac", "bc", 以及 "abc"。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "aba"
<strong>输出：</strong>6
<strong>解释：</strong>6 个不同的子序列分别是 "a", "b", "ab", "ba", "aa" 以及 "aba"。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "aaa"
<strong>输出：</strong>3
<strong>解释：</strong>3 个不同的子序列分别是 "a", "aa" 以及 "aaa"。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<p> </p>
</div></div></div><br><br><hr><br>**********************************<div id="title">943. Find the Shortest Superstring</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串数组 <code>words</code>，找到以 <code>words</code> 中每个字符串作为子字符串的最短字符串。如果有多个有效最短字符串满足题目条件，返回其中 <strong>任意一个</strong> 即可。</p>
<p>我们可以假设 <code>words</code> 中没有字符串是 <code>words</code> 中另一个字符串的子字符串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>words = ["alex","loves","leetcode"]
<strong>输出：</strong>"alexlovesleetcode"
<strong>解释：</strong>"alex"，"loves"，"leetcode" 的所有排列都会被接受。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>words = ["catg","ctaagt","gcta","ttca","atgcatc"]
<strong>输出：</strong>"gctaagttcatgcatc"</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 12</code></li>
<li><code>1 &lt;= words[i].length &lt;= 20</code></li>
<li><code>words[i]</code> 由小写英文字母组成</li>
<li><code>words</code> 中的所有字符串 <strong>互不相同</strong></li>
</ul>
</div></div></div><br><br><hr><br>********************************************<div id="title">952. Largest Component Size by Common Factor</div>
********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个由不同正整数的组成的非空数组 <code>nums</code> ，考虑下面的图：</p>
<ul>
<li>有 <code>nums.length</code> 个节点，按从 <code>nums[0]</code> 到 <code>nums[nums.length - 1]</code> 标记；</li>
<li>只有当 <code>nums[i]</code> 和 <code>nums[j]</code> 共用一个大于 1 的公因数时，<code>nums[i]</code> 和 <code>nums[j]</code>之间才有一条边。</li>
</ul>
<p>返回 <em>图中最大连通组件的大小</em> 。</p>
<p> </p>
<ol>
</ol>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/01/ex1.png" style="height: 97px; width: 500px;"/></p>
<pre><strong>输入：</strong>nums = [4,6,15,35]
<strong>输出：</strong>4
</pre>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/01/ex2.png" style="height: 85px; width: 500px;"/></p>
<pre><strong>输入：</strong>nums = [20,50,9,63]
<strong>输出：</strong>2
</pre>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/01/ex3.png" style="height: 260px; width: 500px;"/></p>
<pre><strong>输入：</strong>nums = [2,3,6,7,4,12,21,39]
<strong>输出：</strong>8
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
<li><code>nums</code> 中所有值都 <strong>不同</strong></li>
</ul>
</div></div></div><br><br><hr><br>**********************<div id="title">956. Tallest Billboard</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。</p>
<p>你有一堆可以焊接在一起的钢筋 <code>rods</code>。举个例子，如果钢筋的长度为 <code>1</code>、<code>2</code> 和 <code>3</code>，则可以将它们焊接在一起形成长度为 <code>6</code> 的支架。</p>
<p>返回 <em>广告牌的最大可能安装高度</em> 。如果没法安装广告牌，请返回 <code>0</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>[1,2,3,6]
<strong>输出：</strong>6
<strong>解释：</strong>我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>[1,2,3,4,5,6]
<strong>输出：</strong>10
<strong>解释：</strong>我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>[1,2]
<strong>输出：</strong>0
<strong>解释：</strong>没法安装广告牌，所以返回 0。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= rods.length &lt;= 20</code></li>
<li><code>1 &lt;= rods[i] &lt;= 1000</code></li>
<li><code>sum(rods[i]) &lt;= 5000</code></li>
</ol>
</div></div></div><br><br><hr><br>**************************************<div id="title">960. Delete Columns to Make Sorted III</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定由 <code>n</code> 个小写字母字符串组成的数组 <code>strs</code> ，其中每个字符串长度相等。</p>
<p>选取一个删除索引序列，对于 <code>strs</code> 中的每个字符串，删除对应每个索引处的字符。</p>
<p>比如，有 <code>strs = ["abcdef","uvwxyz"]</code> ，删除索引序列 <code>{0, 2, 3}</code> ，删除后为 <code>["bef", "vyz"]</code> 。</p>
<p>假设，我们选择了一组删除索引 <code>answer</code> ，那么在执行删除操作之后，最终得到的数组的行中的 <strong>每个元素</strong> 都是按<strong>字典序</strong>排列的（即 <code>(strs[0][0] &lt;= strs[0][1] &lt;= ... &lt;= strs[0][strs[0].length - 1])</code> 和 <code>(strs[1][0] &lt;= strs[1][1] &lt;= ... &lt;= strs[1][strs[1].length - 1])</code> ，依此类推）。</p>
<p>请返回<em> <code>answer.length</code> 的最小可能值</em> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>strs = ["babca","bbazb"]
<strong>输出：</strong>3
<strong>解释：
</strong>删除 0、1 和 4 这三列后，最终得到的数组是 A = ["bc", "az"]。
这两行是分别按字典序排列的（即，A[0][0] &lt;= A[0][1] 且 A[1][0] &lt;= A[1][1]）。
注意，A[0] &gt; A[1] —— 数组 A 不一定是按字典序排列的。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>strs = ["edcba"]
<strong>输出：</strong>4
<strong>解释：</strong>如果删除的列少于 4 列，则剩下的行都不会按字典序排列。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>strs = ["ghi","def","abc"]
<strong>输出：</strong>0
<strong>解释：</strong>所有行都已按字典序排列。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == strs.length</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">964. Least Operators to Express Number</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个正整数 <code>x</code>，我们将会写出一个形如 <code>x (op1) x (op2) x (op3) x ...</code> 的表达式，其中每个运算符 <code>op1</code>，<code>op2</code>，… 可以是加、减、乘、除（<code>+</code>，<code>-</code>，<code>*</code>，或是 <code>/</code>）之一。例如，对于 <code>x = 3</code>，我们可以写出表达式 <code>3 * 3 / 3 + 3 - 3</code>，该式的值为 3 。</p>
<p>在写这样的表达式时，我们需要遵守下面的惯例：</p>
<ul>
<li>除运算符（<code>/</code>）返回有理数。</li>
<li>任何地方都没有括号。</li>
<li>我们使用通常的操作顺序：乘法和除法发生在加法和减法之前。</li>
<li>不允许使用一元否定运算符（<code>-</code>）。例如，“<code>x - x</code>” 是一个有效的表达式，因为它只使用减法，但是 “<code>-x + x</code>” 不是，因为它使用了否定运算符。 </li>
</ul>
<p>我们希望编写一个能使表达式等于给定的目标值 <code>target</code> 且运算符最少的表达式。返回所用运算符的最少数量。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>x = 3, target = 19
<strong>输出：</strong>5
<strong>解释：</strong>3 * 3 + 3 * 3 + 3 / 3 。表达式包含 5 个运算符。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>x = 5, target = 501
<strong>输出：</strong>8
<strong>解释：</strong>5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5 。表达式包含 8 个运算符。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>x = 100, target = 100000000
<strong>输出：</strong>3
<strong>解释：</strong>100 * 100 * 100 * 100 。表达式包含 3 个运算符。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= x &lt;= 100</code></li>
<li><code>1 &lt;= target &lt;= 2 * 10<sup>8</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">968. Binary Tree Cameras</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" style="height: 163px; width: 138px;"/></p>
<pre><strong>输入：</strong>[0,0,null,0,0]
<strong>输出：</strong>1
<strong>解释：</strong>如图所示，一台摄像头足以监控所有节点。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" style="height: 312px; width: 139px;"/></p>
<pre><strong>输入：</strong>[0,0,null,0,null,0,null,null,0]
<strong>输出：</strong>2
<strong>解释：</strong>需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
</pre>
<p><br/>
<strong>提示：</strong></p>
<ol>
<li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li>
<li>每个节点的值都是 0。</li>
</ol>
</div></div></div><br><br><hr><br>***************************<div id="title">972. Equal Rational Numbers</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，每个字符串代表一个非负有理数，只有当它们表示相同的数字时才返回 <code>true</code> 。字符串中可以使用括号来表示有理数的重复部分。</p>
<p><strong>有理数</strong> 最多可以用三个部分来表示：<em>整数部分</em> <code>&lt;IntegerPart&gt;</code>、<em>小数非重复部分</em> <code>&lt;NonRepeatingPart&gt;</code> 和<em>小数重复部分</em> <code>&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt;</code>。数字可以用以下三种方法之一来表示：</p>
<ul>
<li><code>&lt;IntegerPart&gt;</code> 

	<ul>
<li>例： <code>0</code> ,<code>12</code> 和 <code>123</code> </li>
</ul>
</li>
<li><code>&lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;</code>
<ul>
<li>例： <code>0.5<font color="#333333"><font face="Helvetica Neue, Helvetica, Arial, sans-serif"><span style="font-size:14px"><span style="background-color:#ffffff"> , </span></span></font></font></code><font color="#333333"><font face="Helvetica Neue, Helvetica, Arial, sans-serif"><span style="font-size:14px"><span style="background-color:#ffffff"><code>1.</code> , </span></span></font></font><code>2.12</code> 和 <code>123.0001</code></li>
</ul>
</li>
<li><code>&lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt;</code> 
	<ul>
<li>例： <code>0.1(6)</code> ， <code>1.(9)</code>， <code>123.00(1212)</code></li>
</ul>
</li>
</ul>
<p>十进制展开的重复部分通常在一对圆括号内表示。例如：</p>
<ul>
<li><code>1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)</code></li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "0.(52)", t = "0.5(25)"
<strong>输出：</strong>true
<strong>解释：</strong>因为 "0.(52)" 代表 0.52525252...，而 "0.5(25)" 代表 0.52525252525.....，则这两个字符串表示相同的数字。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "0.1666(6)", t = "0.166(66)"
<strong>输出：</strong>true
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "0.9(9)", t = "1."
<strong>输出：</strong>true
<strong>解释：</strong>"0.9(9)" 代表 0.999999999... 永远重复，等于 1 。[<a href="https://baike.baidu.com/item/0.999…/5615429?fr=aladdin">有关说明，请参阅此链接</a>]
"1." 表示数字 1，其格式正确：(IntegerPart) = "1" 且 (NonRepeatingPart) = "" 。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li>每个部分仅由数字组成。</li>
<li>整数部分 <code>&lt;IntegerPart&gt;</code> 不会以零开头。（零本身除外）</li>
<li><code>1 &lt;= &lt;IntegerPart&gt;.length &lt;= 4 </code></li>
<li><code>0 &lt;= &lt;NonRepeatingPart&gt;.length &lt;= 4 </code></li>
<li><code>1 &lt;= &lt;RepeatingPart&gt;.length &lt;= 4 </code></li>
</ul>
<span style="display:block"><span style="height:0px"><span style="position:absolute">​​​​​</span></span></span></div></div></div><br><br><hr><br>******************<div id="title">975. Odd Even Jump</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个整数数组 <code>A</code>，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。</p>
<p>你可以按以下方式从索引 <code>i</code> 向后跳转到索引 <code>j</code>（其中 <code>i &lt; j</code>）：</p>
<ul>
<li>在进行奇数跳跃时（如，第 1，3，5... 次跳跃），你将会跳到索引 <code>j</code>，使得 <code>A[i] &lt;= A[j]</code>，<code>A[j]</code> 是可能的最小值。如果存在多个这样的索引 <code>j</code>，你只能跳到满足要求的<strong>最小</strong>索引 <code>j</code> 上。</li>
<li>在进行偶数跳跃时（如，第 2，4，6... 次跳跃），你将会跳到索引 <code>j</code>，使得 <code>A[i] &gt;= A[j]</code>，<code>A[j]</code> 是可能的最大值。如果存在多个这样的索引 <code>j</code>，你只能跳到满足要求的<strong>最小</strong>索引 <code>j</code> 上。</li>
<li>（对于某些索引 <code>i</code>，可能无法进行合乎要求的跳跃。）</li>
</ul>
<p>如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 <code>A.length - 1</code>），那么该索引就会被认为是好的起始索引。</p>
<p>返回好的起始索引的数量。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>[10,13,12,14,15]
<strong>输出：</strong>2
<strong>解释： </strong>
从起始索引 i = 0 出发，我们可以跳到 i = 2，（因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。
从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。
从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。
从起始索引 i = 4 出发，我们已经到达数组末尾。
总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>[2,3,1,1,4]
<strong>输出：</strong>3
<strong>解释：</strong>
从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3：

在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。

在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。A[3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。

在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。

我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。

类似地，我们可以推断：
从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。
从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。
从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。
从起始索引 i = 4 出发，我们已经到达数组末尾。
总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>[5,1,3,4,2]
<strong>输出：</strong>3
<strong>解释： </strong>
我们可以从起始索引 1，2，4 出发到达数组末尾。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 20000</code></li>
<li><code>0 &lt;= A[i] &lt; 100000</code></li>
</ol>
</div></div></div><br><br><hr><br>*********************<div id="title">980. Unique Paths III</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在二维网格 <code>grid</code> 上，有 4 种类型的方格：</p>
<ul>
<li><code>1</code> 表示起始方格。且只有一个起始方格。</li>
<li><code>2</code> 表示结束方格，且只有一个结束方格。</li>
<li><code>0</code> 表示我们可以走过的空方格。</li>
<li><code>-1</code> 表示我们无法跨越的障碍。</li>
</ul>
<p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目<strong>。</strong></p>
<p><strong>每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格</strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
<strong>输出：</strong>2
<strong>解释：</strong>我们有以下两条路径：
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
<strong>输出：</strong>4
<strong>解释：</strong>我们有以下四条路径： 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>[[0,1],[2,0]]
<strong>输出：</strong>0
<strong>解释：</strong>
没有一条路能完全穿过每一个空的方格一次。
请注意，起始和结束方格可以位于网格中的任意位置。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= grid.length * grid[0].length &lt;= 20</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************************<div id="title">982. Triples with Bitwise AND Equal To Zero</div>
*******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> ，返回其中 <strong>按位与三元组</strong> 的数目。</p>
<p><strong>按位与三元组</strong> 是由下标 <code>(i, j, k)</code> 组成的三元组，并满足下述全部条件：</p>
<ul>
<li><code>0 &lt;= i &lt; nums.length</code></li>
<li><code>0 &lt;= j &lt; nums.length</code></li>
<li><code>0 &lt;= k &lt; nums.length</code></li>
<li><code>nums[i] &amp; nums[j] &amp; nums[k] == 0</code> ，其中 <code>&amp;</code> 表示按位与运算符。</li>
</ul>
 

<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [2,1,3]
<strong>输出：</strong>12
<strong>解释：</strong>可以选出如下 i, j, k 三元组：
(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1
(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2
(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1
(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3
(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1
(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2
(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1
(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3
(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2
(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2
(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1
(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [0,0,0]
<strong>输出：</strong>27
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt; 2<sup>16</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">987. Vertical Order Traversal of a Binary Tree</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你二叉树的根结点 <code>root</code> ，请你设计算法计算二叉树的<em> </em><strong>垂序遍历</strong> 序列。</p>
<p>对位于 <code>(row, col)</code> 的每个结点而言，其左右子结点分别位于 <code>(row + 1, col - 1)</code> 和 <code>(row + 1, col + 1)</code> 。树的根结点位于 <code>(0, 0)</code> 。</p>
<p>二叉树的 <strong>垂序遍历</strong> 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p>
<p>返回二叉树的 <strong>垂序遍历</strong> 序列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" style="width: 431px; height: 304px;"/>
<pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>[[9],[3,15],[20],[7]]
<strong>解释：</strong>
列 -1 ：只有结点 9 在此列中。
列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
列  1 ：只有结点 20 在此列中。
列  2 ：只有结点 7 在此列中。</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" style="width: 512px; height: 304px;"/>
<pre><strong>输入：</strong>root = [1,2,3,4,5,6,7]
<strong>输出：</strong>[[4],[2],[1,5,6],[3],[7]]
<strong>解释：</strong>
列 -2 ：只有结点 4 在此列中。
列 -1 ：只有结点 2 在此列中。
列  0 ：结点 1 、5 和 6 都在此列中。
          1 在上面，所以它出现在前面。
          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。
列  1 ：只有结点 3 在此列中。
列  2 ：只有结点 7 在此列中。
</pre>
<p><strong>示例 3：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" style="width: 512px; height: 304px;"/>
<pre><strong>输入：</strong>root = [1,2,3,4,6,5,7]
<strong>输出：</strong>[[4],[2],[1,5,6],[3],[7]]
<strong>解释：</strong>
这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。
因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li>树中结点数目总数在范围 <code>[1, 1000]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">992. Subarrays with K Different Integers</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个正整数数组 <code>nums</code>和一个整数 <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">k</span></span></font></font> ，返回 <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">num</span></span></font></font> 中 「<strong>好子数组」</strong><em> </em>的数目。</p>
<p>如果 <code>nums</code> 的某个子数组中不同整数的个数恰好为 <code>k</code>，则称 <code>nums</code> 的这个连续、不一定不同的子数组为 <strong>「</strong><strong>好子数组 」</strong>。</p>
<ul>
<li>例如，<code>[1,2,3,1,2]</code> 中有 <code>3</code> 个不同的整数：<code>1</code>，<code>2</code>，以及 <code>3</code>。</li>
</ul>
<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,1,2,3], k = 2
<strong>输出：</strong>7
<strong>解释：</strong>恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,1,3,4], k = 3
<strong>输出：</strong>3
<strong>解释：</strong>恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= nums[i], k &lt;= nums.length</code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">995. Minimum Number of K Consecutive Bit Flips</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p><strong>k位翻转</strong> 就是从 <code>nums</code> 中选择一个长度为 <code>k</code> 的 <strong>子数组</strong> ，同时把子数组中的每一个 <code>0</code> 都改成 <code>1</code> ，把子数组中的每一个 <code>1</code> 都改成 <code>0</code> 。</p>
<p>返回数组中不存在 <code>0</code> 所需的最小 <strong>k位翻转</strong> 次数。如果不可能，则返回 <code>-1</code> 。</p>
<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [0,1,0], K = 1
<strong>输出：</strong>2
<strong>解释：</strong>先翻转 A[0]，然后翻转 A[2]。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,1,0], K = 2
<strong>输出：</strong>-1
<strong>解释：</strong>无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [0,0,0,1,0,1,1,0], K = 3
<strong>输出：</strong>3
<strong>解释：</strong>
翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]
翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]
翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">996. Number of Squareful Arrays</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个非负整数数组 <code>A</code>，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为<em>正方形</em>数组。</p>
<p>返回 A 的正方形排列的数目。两个排列 <code>A1</code> 和 <code>A2</code> 不同的充要条件是存在某个索引 <code>i</code>，使得 A1[i] != A2[i]。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>[1,17,8]
<strong>输出：</strong>2
<strong>解释：</strong>
[1,8,17] 和 [17,8,1] 都是有效的排列。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>[2,2,2]
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 12</code></li>
<li><code>0 &lt;= A[i] &lt;= 1e9</code></li>
</ol>
</div></div></div><br><br><hr><br>**********************************<div id="title">1000. Minimum Cost to Merge Stones</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有 <code>N</code> 堆石头排成一排，第 <code>i</code> 堆中有 <code>stones[i]</code> 块石头。</p>
<p>每次<em>移动（move）</em>需要将<strong>连续的</strong> <code>K</code> 堆石头合并为一堆，而这个移动的成本为这 <code>K</code> 堆石头的总数。</p>
<p>找出把所有石头合并成一堆的最低成本。如果不可能，返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>stones = [3,2,4,1], K = 2
<strong>输出：</strong>20
<strong>解释：</strong>
从 [3, 2, 4, 1] 开始。
合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
合并 [4, 1]，成本为 5，剩下 [5, 5]。
合并 [5, 5]，成本为 10，剩下 [10]。
总成本 20，这是可能的最小值。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>stones = [3,2,4,1], K = 3
<strong>输出：</strong>-1
<strong>解释：</strong>任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>stones = [3,5,1,2,6], K = 3
<strong>输出：</strong>25
<strong>解释：</strong>
从 [3, 5, 1, 2, 6] 开始。
合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。
合并 [3, 8, 6]，成本为 17，剩下 [17]。
总成本 25，这是可能的最小值。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>2 &lt;= K &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>***********************<div id="title">1001. Grid Illumination</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在大小为 <code>n x n</code> 的网格 <code>grid</code> 上，每个单元格都有一盏灯，最初灯都处于 <strong>关闭</strong> 状态。</p>
<p>给你一个由灯的位置组成的二维数组 <code>lamps</code> ，其中 <code>lamps[i] = [row<sub>i</sub>, col<sub>i</sub>]</code> 表示 <strong>打开</strong> 位于 <code>grid[row<sub>i</sub>][col<sub>i</sub>]</code> 的灯。即便同一盏灯可能在 <code>lamps</code> 中多次列出，不会影响这盏灯处于 <strong>打开</strong> 状态。</p>
<p>当一盏灯处于打开状态，它将会照亮 <strong>自身所在单元格</strong> 以及同一 <strong>行</strong> 、同一 <strong>列</strong> 和两条 <strong>对角线</strong> 上的 <strong>所有其他单元格</strong> 。</p>
<p>另给你一个二维数组 <code>queries</code> ，其中 <code>queries[j] = [row<sub>j</sub>, col<sub>j</sub>]</code> 。对于第 <code>j</code> 个查询，如果单元格 <code>[row<sub>j</sub>, col<sub>j</sub>]</code> 是被照亮的，则查询结果为 <code>1</code> ，否则为 <code>0</code> 。在第 <code>j</code> 次查询之后 [按照查询的顺序] ，<strong>关闭</strong> 位于单元格 <code>grid[row<sub>j</sub>][col<sub>j</sub>]</code> 上及相邻 8 个方向上（与单元格 <code>grid[row<sub>i</sub>][col<sub>i</sub>]</code> 共享角或边）的任何灯。</p>
<p>返回一个整数数组 <code>ans</code> 作为答案， <code>ans[j]</code> 应等于第 <code>j</code> 次查询 <code>queries[j]</code> 的结果，<code>1</code> 表示照亮，<code>0</code> 表示未照亮。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/illu_1.jpg" style="height: 209px; width: 750px;"/>
<pre><strong>输入：</strong>n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
<strong>输出：</strong>[1,0]
<strong>解释：</strong>最初所有灯都是关闭的。在执行查询之前，打开位于 [0, 0] 和 [4, 4] 的灯。第 0 次查询检查 grid[1][1] 是否被照亮（蓝色方框）。该单元格被照亮，所以 ans[0] = 1 。然后，关闭红色方框中的所有灯。
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/illu_step1.jpg" style="height: 218px; width: 500px;"/>
第 1 次查询检查 grid[1][0] 是否被照亮（蓝色方框）。该单元格没有被照亮，所以 ans[1] = 0 。然后，关闭红色矩形中的所有灯。
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/illu_step2.jpg" style="height: 219px; width: 500px;"/>
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]
<strong>输出：</strong>[1,1]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]
<strong>输出：</strong>[1,1,0]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
<li><code>0 &lt;= lamps.length &lt;= 20000</code></li>
<li><code>0 &lt;= queries.length &lt;= 20000</code></li>
<li><code>lamps[i].length == 2</code></li>
<li><code>0 &lt;= row<sub>i</sub>, col<sub>i</sub> &lt; n</code></li>
<li><code>queries[j].length == 2</code></li>
<li><code>0 &lt;= row<sub>j</sub>, col<sub>j</sub> &lt; n</code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************<div id="title">1012. Numbers With Repeated Digits</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定正整数 <code>n</code>，返回在<em> </em><code>[1, n]</code><em> </em>范围内具有 <strong>至少 1 位</strong> 重复数字的正整数的个数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 20
<strong>输出：</strong>1
<strong>解释：</strong>具有至少 1 位重复数字的正数（&lt;= 20）只有 11 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 100
<strong>输出：</strong>10
<strong>解释：</strong>具有至少 1 位重复数字的正数（&lt;= 100）有 11，22，33，44，55，66，77，88，99 和 100 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 1000
<strong>输出：</strong>262
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>********************************************<div id="title">1028. Recover a Tree From Preorder Traversal</div>
********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>我们从二叉树的根节点 <code>root</code> 开始进行深度优先搜索。</p>
<p>在遍历中的每个节点处，我们输出 <code>D</code> 条短划线（其中 <code>D</code> 是该节点的深度），然后输出该节点的值。（<em>如果节点的深度为 <code>D</code>，则其直接子节点的深度为 <code>D + 1</code>。根节点的深度为 <code>0</code>）。</em></p>
<p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p>
<p>给出遍历输出 <code>S</code>，还原树并返回其根节点 <code>root</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/recover-a-tree-from-preorder-traversal.png" style="height: 200px; width: 320px;"/></strong></p>
<pre><strong>输入：</strong>"1-2--3--4-5--6--7"
<strong>输出：</strong>[1,2,5,3,4,6,7]
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/screen-shot-2019-04-10-at-114101-pm.png" style="height: 250px; width: 256px;"/></strong></p>
<pre><strong>输入：</strong>"1-2--3---4-5--6---7"
<strong>输出：</strong>[1,2,5,3,null,6,null,4,null,7]
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/screen-shot-2019-04-10-at-114955-pm.png" style="height: 250px; width: 276px;"/></p>
<pre><strong>输入：</strong>"1-401--349---90--88"
<strong>输出：</strong>[1,401,null,349,88,90]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li>原始树中的节点数介于 <code>1</code> 和 <code>1000</code> 之间。</li>
<li>每个节点的值介于 <code>1</code> 和 <code>10 ^ 9</code> 之间。</li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">1032. Stream of Characters</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>设计一个算法：接收一个字符流，并检查这些字符的后缀是否是字符串数组 <code>words</code> 中的一个字符串。</p>
<p>例如，<code>words = ["abc", "xyz"]</code> 且字符流中逐个依次加入 4 个字符 <code>'a'</code>、<code>'x'</code>、<code>'y'</code> 和 <code>'z'</code> ，你所设计的算法应当可以检测到 <code>"axyz"</code> 的后缀 <code>"xyz"</code> 与 <code>words</code> 中的字符串 <code>"xyz"</code> 匹配。</p>
<p>按下述要求实现 <code>StreamChecker</code> 类：</p>
<ul>
<li><code>StreamChecker(String[] words)</code> ：构造函数，用字符串数组 <code>words</code> 初始化数据结构。</li>
<li><code>boolean query(char letter)</code>：从字符流中接收一个新字符，如果字符流中的任一非空后缀能匹配 <code>words</code> 中的某一字符串，返回 <code>true</code> ；否则，返回 <code>false</code>。</li>
</ul>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>
["StreamChecker", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query"]
[[["cd", "f", "kl"]], ["a"], ["b"], ["c"], ["d"], ["e"], ["f"], ["g"], ["h"], ["i"], ["j"], ["k"], ["l"]]
<strong>输出：</strong>
[null, false, false, false, true, false, true, false, false, false, false, false, true]

<strong>解释：</strong>
StreamChecker streamChecker = new StreamChecker(["cd", "f", "kl"]);
streamChecker.query("a"); // 返回 False
streamChecker.query("b"); // 返回 False
streamChecker.query("c"); // 返回n False
streamChecker.query("d"); // 返回 True ，因为 'cd' 在 words 中
streamChecker.query("e"); // 返回 False
streamChecker.query("f"); // 返回 True ，因为 'f' 在 words 中
streamChecker.query("g"); // 返回 False
streamChecker.query("h"); // 返回 False
streamChecker.query("i"); // 返回 False
streamChecker.query("j"); // 返回 False
streamChecker.query("k"); // 返回 False
streamChecker.query("l"); // 返回 True ，因为 'kl' 在 words 中
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 2000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 200</code></li>
<li><code>words[i]</code> 由小写英文字母组成</li>
<li><code>letter</code> 是一个小写英文字母</li>
<li>最多调用查询 <code>4 * 10<sup>4</sup></code> 次</li>
</ul>
</div></div></div><br><br><hr><br>*************************<div id="title">1036. Escape a Large Maze</div>
*************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在一个 10<sup>6</sup> x 10<sup>6</sup> 的网格中，每个网格上方格的坐标为 <code>(x, y)</code> 。</p>
<p>现在从源方格 <code>source = [s<sub>x</sub>, s<sub>y</sub>]</code> 开始出发，意图赶往目标方格 <code>target = [t<sub>x</sub>, t<sub>y</sub>]</code> 。数组 <code>blocked</code> 是封锁的方格列表，其中每个 <code>blocked[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示坐标为 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 的方格是禁止通行的。</p>
<p>每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 <strong>不</strong> 在给出的封锁列表 <code>blocked</code> 上。同时，不允许走出网格。</p>
<p>只有在可以通过一系列的移动从源方格 <code>source</code> 到达目标方格 <code>target</code> 时才返回 <code>true</code>。否则，返回 <code>false</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
<strong>输出：</strong>false
<strong>解释：</strong>
从源方格无法到达目标方格，因为我们无法在网格中移动。
无法向北或者向东移动是因为方格禁止通行。
无法向南或者向西移动是因为不能走出网格。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>blocked = [], source = [0,0], target = [999999,999999]
<strong>输出：</strong>true
<strong>解释：</strong>
因为没有方格被封锁，所以一定可以到达目标方格。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= blocked.length &lt;= 200</code></li>
<li><code>blocked[i].length == 2</code></li>
<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt; 10<sup>6</sup></code></li>
<li><code>source.length == target.length == 2</code></li>
<li><code>0 &lt;= s<sub>x</sub>, s<sub>y</sub>, t<sub>x</sub>, t<sub>y</sub> &lt; 10<sup>6</sup></code></li>
<li><code>source != target</code></li>
<li>题目数据保证 <code>source</code> 和 <code>target</code> 不在封锁列表内</li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1044. Longest Duplicate Substring</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> ，考虑其所有 <em>重复子串</em> ：即 <code>s</code> 的（连续）子串，在 <code>s</code> 中出现 2 次或更多次。这些出现之间可能存在重叠。</p>
<p>返回 <strong>任意一个</strong> 可能具有最长长度的重复子串。如果 <code>s</code> 不含重复子串，那么答案为 <code>""</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "banana"
<strong>输出：</strong>"ana"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "abcd"
<strong>输出：</strong>""
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">1074. Number of Submatrices That Sum to Target</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>子矩阵 <code>x1, y1, x2, y2</code> 是满足 <code>x1 &lt;= x &lt;= x2</code> 且 <code>y1 &lt;= y &lt;= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>
<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1', y1', x2', y2')</code> 两个子矩阵中部分坐标不同（如：<code>x1 != x1'</code>），那么这两个子矩阵也不同。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg" style="width: 242px; height: 242px;"/></p>
<pre><strong>输入：</strong>matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
<strong>输出：</strong>4
<strong>解释：</strong>四个只含 0 的 1x1 子矩阵。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>matrix = [[1,-1],[-1,1]], target = 0
<strong>输出：</strong>5
<strong>解释：</strong>两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>matrix = [[904]], target = 0
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong><strong>提示：</strong></strong></p>
<ul>
<li><code>1 &lt;= matrix.length &lt;= 100</code></li>
<li><code>1 &lt;= matrix[0].length &lt;= 100</code></li>
<li><code>-1000 &lt;= matrix[i] &lt;= 1000</code></li>
<li><code>-10^8 &lt;= target &lt;= 10^8</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************<div id="title">1092. Shortest Common Supersequence </div>
************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给出两个字符串 <code>str1</code> 和 <code>str2</code>，返回同时以 <code>str1</code> 和 <code>str2</code> 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。</p>
<p>（如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 <strong>任意位置</strong>），可以得到字符串 S，那么 S 就是 T 的子序列）</p>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>str1 = "abac", str2 = "cab"
<strong>输出：</strong>"cabac"
<strong>解释：</strong>
str1 = "abac" 是 "cabac" 的一个子串，因为我们可以删去 "cabac" 的第一个 "c"得到 "abac"。 
str2 = "cab" 是 "cabac" 的一个子串，因为我们可以删去 "cabac" 末尾的 "ac" 得到 "cab"。
最终我们给出的答案是满足上述属性的最短字符串。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li>
<li><code>str1</code> 和 <code>str2</code> 都由小写英文字母组成。</li>
</ol>
</div></div></div><br><br><hr><br>****************************<div id="title">1095. Find in Mountain Array</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>（这是一个 <strong>交互式问题 </strong>）</p>
<p>给你一个 <strong>山脉数组</strong> <code>mountainArr</code>，请你返回能够使得 <code>mountainArr.get(index)</code> <strong>等于</strong> <code>target</code> <strong>最小</strong> 的下标 <code>index</code> 值。</p>
<p>如果不存在这样的下标 <code>index</code>，就请返回 <code>-1</code>。</p>
<p> </p>
<p>何为山脉数组？如果数组 <code>A</code> 是一个山脉数组的话，那它满足如下条件：</p>
<p><strong>首先</strong>，<code>A.length &gt;= 3</code></p>
<p><strong>其次</strong>，在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 <code>i</code> 使得：</p>
<ul>
<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>
<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
<p> </p>
<p>你将 <strong>不能直接访问该山脉数组</strong>，必须通过 <code>MountainArray</code> 接口来获取数据：</p>
<ul>
<li><code>MountainArray.get(k)</code> - 会返回数组中索引为<code>k</code> 的元素（下标从 0 开始）</li>
<li><code>MountainArray.length()</code> - 会返回该数组的长度</li>
</ul>
<p> </p>
<p><strong>注意：</strong></p>
<p>对 <code>MountainArray.get</code> 发起超过 <code>100</code> 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p>
<p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “<strong>答案</strong>”：<a href="https://leetcode-cn.com/playground/RKhe3ave">https://leetcode-cn.com/playground/RKhe3ave</a>，请注意这 <strong>不是一个正确答案</strong>。</p>
<ol>
</ol>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>array = [1,2,3,4,5,3,1], target = 3
<strong>输出：</strong>2
<strong>解释：</strong>3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>array = [0,1,2,4,2,1], target = 3
<strong>输出：</strong>-1
<strong>解释：</strong>3 在数组中没有出现，返回 -1。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li>
<li><code>0 &lt;= target &lt;= 10^9</code></li>
<li><code>0 &lt;= mountain_arr.get(index) &lt;= 10^9</code></li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">1096. Brace Expansion II</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。</p>
<p>花括号展开的表达式可以看作一个由 <strong>花括号</strong>、<strong>逗号</strong> 和 <strong>小写英文字母</strong> 组成的字符串，定义下面几条语法规则：</p>
<ul>
<li>如果只给出单一的元素 <code>x</code>，那么表达式表示的字符串就只有 <code>"x"</code>。<code>R(x) = {x}</code>
<ul>
<li>例如，表达式 <code>"a"</code> 表示字符串 <code>"a"</code>。</li>
<li>而表达式 <code>"w"</code> 就表示字符串 <code>"w"</code>。</li>
</ul>
</li>
<li>当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。<code>R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ...</code>
<ul>
<li>例如，表达式 <code>"{a,b,c}"</code> 表示字符串 <code>"a","b","c"</code>。</li>
<li>而表达式 <code>"{{a,b},{b,c}}"</code> 也可以表示字符串 <code>"a","b","c"</code>。</li>
</ul>
</li>
<li>要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。<code>R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)}</code>
<ul>
<li>例如，表达式 <code>"{a,b}{c,d}"</code> 表示字符串 <code>"ac","ad","bc","bd"</code>。</li>
</ul>
</li>
<li>表达式之间允许嵌套，单一元素与表达式的连接也是允许的。
	<ul>
<li>例如，表达式 <code>"a{b,c,d}"</code> 表示字符串 <code>"ab","ac","ad"​​​​​​</code>。</li>
<li>例如，表达式 <code>"a{b,c}{d,e}f{g,h}"</code> 可以表示字符串 <code>"abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"</code>。</li>
</ul>
</li>
</ul>
<p>给出表示基于给定语法规则的表达式 <code>expression</code>，返回它所表示的所有字符串组成的有序列表。</p>
<p>假如你希望以「集合」的概念了解此题，也可以通过点击 “<strong>显示英文描述</strong>” 获取详情。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>expression = "{a,b}{c,{d,e}}"
<strong>输出：</strong>["ac","ad","ae","bc","bd","be"]</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>expression = "{{a,z},a{b,c},{ab,z}}"
<strong>输出：</strong>["a","ab","ac","z"]
<strong>解释：</strong>输出中 <strong>不应 </strong>出现重复的组合结果。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= expression.length &lt;= 60</code></li>
<li><code>expression[i]</code> 由 <code>'{'</code>，<code>'}'</code>，<code>','</code> 或小写英文字母组成</li>
<li>给出的表达式 <code>expression</code> 用以表示一组基于题目描述中语法构造的字符串</li>
</ul>
</div></div></div><br><br><hr><br>**********************************<div id="title">1106. Parsing A Boolean Expression</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个以字符串形式表述的 <a href="https://baike.baidu.com/item/%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/1574380?fr=aladdin">布尔表达式</a>（boolean） <code>expression</code>，返回该式的运算结果。</p>
<p>有效的表达式需遵循以下约定：</p>
<ul>
<li><code>"t"</code>，运算结果为 <code>True</code></li>
<li><code>"f"</code>，运算结果为 <code>False</code></li>
<li><code>"!(expr)"</code>，运算过程为对内部表达式 <code>expr</code> 进行逻辑 <strong>非的运算</strong>（NOT）</li>
<li><code>"&amp;(expr1,expr2,...)"</code>，运算过程为对 2 个或以上内部表达式 <code>expr1, expr2, ...</code> 进行逻辑 <strong>与的运算</strong>（AND）</li>
<li><code>"|(expr1,expr2,...)"</code>，运算过程为对 2 个或以上内部表达式 <code>expr1, expr2, ...</code> 进行逻辑 <strong>或的运算</strong>（OR）</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>expression = "!(f)"
<strong>输出：</strong>true
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>expression = "|(f,t)"
<strong>输出：</strong>true
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>expression = "&amp;(t,f)"
<strong>输出：</strong>false
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>expression = "|(&amp;(t,f,t),!(t))"
<strong>输出：</strong>false
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= expression.length &lt;= 20000</code></li>
<li><code>expression[i]</code> 由 <code>{'(', ')', '&amp;', '|', '!', 't', 'f', ','}</code> 中的字符组成。</li>
<li><code>expression</code> 是以上述形式给出的有效表达式，表示一个布尔值。</li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">1125. Smallest Sufficient Team</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>作为项目经理，你规划了一份需求的技能清单 <code>req_skills</code>，并打算从备选人员名单 <code>people</code> 中选出些人组成一个「必要团队」（ 编号为 <code>i</code> 的备选人员 <code>people[i]</code> 含有一份该备选人员掌握的技能列表）。</p>
<p>所谓「必要团队」，就是在这个团队中，对于所需求的技能列表 <code>req_skills</code> 中列出的每项技能，团队中至少有一名成员已经掌握。可以用每个人的编号来表示团队中的成员：</p>
<ul>
<li>例如，团队 <code>team = [0, 1, 3]</code> 表示掌握技能分别为 <code>people[0]</code>，<code>people[1]</code>，和 <code>people[3]</code> 的备选人员。</li>
</ul>
<p>请你返回 <strong>任一</strong> 规模最小的必要团队，团队成员用人员编号表示。你可以按 <strong>任意顺序</strong> 返回答案，题目数据保证答案存在。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]
<strong>输出：</strong>[0,2]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]
<strong>输出：</strong>[1,2]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= req_skills.length &lt;= 16</code></li>
<li><code>1 &lt;= req_skills[i].length &lt;= 16</code></li>
<li><code>req_skills[i]</code> 由小写英文字母组成</li>
<li><code>req_skills</code> 中的所有字符串 <strong>互不相同</strong></li>
<li><code>1 &lt;= people.length &lt;= 60</code></li>
<li><code>0 &lt;= people[i].length &lt;= 16</code></li>
<li><code>1 &lt;= people[i][j].length &lt;= 16</code></li>
<li><code>people[i][j]</code> 由小写英文字母组成</li>
<li><code>people[i]</code> 中的所有字符串 <strong>互不相同</strong></li>
<li><code>people[i]</code> 中的每个技能是 <code>req_skills</code> 中的技能</li>
<li>题目数据保证「必要团队」一定存在</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">1147. Longest Chunked Palindrome Decomposition</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你会得到一个字符串 <code>text</code> 。你应该把它分成 <code>k</code> 个子字符串 <code>(subtext1, subtext2，…， subtextk)</code> ，要求满足:</p>
<ul>
<li><code>subtext<sub>i</sub></code><sub> </sub>是 <strong>非空 </strong>字符串</li>
<li>所有子字符串的连接等于 <code>text</code> ( 即<code>subtext<sub>1</sub> + subtext<sub>2</sub> + ... + subtext<sub>k</sub> == text</code> )</li>
<li><code>subtext<sub>i</sub> == subtext<sub>k - i + 1</sub></code><sub> </sub>表示所有 <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">i</span></span></font></font> 的有效值( 即 <code>1 &lt;= i &lt;= k</code> )</li>
</ul>
<p>返回<code>k</code>可能最大值。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>text = "ghiabcdefhelloadamhelloabcdefghi"
<strong>输出：</strong>7
<strong>解释：</strong>我们可以把字符串拆分成 "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>text = "merchant"
<strong>输出：</strong>1
<strong>解释：</strong>我们可以把字符串拆分成 "(merchant)"。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>text = "antaprezatepzapreanta"
<strong>输出：</strong>11
<strong>解释：</strong>我们可以把字符串拆分成 "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)"。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text.length &lt;= 1000</code></li>
<li><code>text</code> 仅由小写英文字符组成</li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">1157. Online Majority Element In Subarray</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>设计一个数据结构，有效地找到给定子数组的 <strong>多数元素</strong> 。</p>
<p>子数组的 <strong>多数元素</strong> 是在子数组中出现 <code>threshold</code> 次数或次数以上的元素。</p>
<p>实现 <code>MajorityChecker</code> 类:</p>
<ul>
<li><code>MajorityChecker(int[] arr)</code> 会用给定的数组 <code>arr</code> 对 <code>MajorityChecker</code> 初始化。</li>
<li><code>int query(int left, int right, int threshold)</code> 返回子数组中的元素  <code>arr[left...right]</code> 至少出现 <code>threshold</code> 次数，如果不存在这样的元素则返回 <code>-1</code>。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入:</strong>
["MajorityChecker", "query", "query", "query"]
[[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]
<strong>输出：</strong>
[null, 1, -1, 2]

<b>解释：</b>
MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);
majorityChecker.query(0,5,4); // 返回 1
majorityChecker.query(0,3,3); // 返回 -1
majorityChecker.query(2,3,2); // 返回 2
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= arr[i] &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>
<li><code>threshold &lt;= right - left + 1</code></li>
<li><code>2 * threshold &gt; right - left + 1</code></li>
<li>调用 <code>query</code> 的次数最多为 <code>10<sup>4</sup></code> </li>
</ul>
</div></div></div><br><br><hr><br>*********************************************<div id="title">1163. Last Substring in Lexicographical Order</div>
*********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> ，找出它的所有子串并按字典序排列，返回排在最后的那个子串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "abab"
<strong>输出：</strong>"bab"
<strong>解释：</strong>我们可以找出 7 个子串 ["a", "ab", "aba", "abab", "b", "ba", "bab"]。按字典序排在最后的子串是 "bab"。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "leetcode"
<strong>输出：</strong>"tcode"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 4 * 10<sup>5</sup></code></li>
<li><code>s</code> 仅含有小写英文字符。</li>
</ul>
</div></div></div><br><br><hr><br>*************************<div id="title">1172. Dinner Plate Stacks</div>
*************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>我们把无限数量 ∞ 的栈排成一行，按从左到右的次序从 0 开始编号。每个栈的的最大容量 <code>capacity</code> 都相同。</p>
<p>实现一个叫「餐盘」的类 <code>DinnerPlates</code>：</p>
<ul>
<li><code>DinnerPlates(int capacity)</code> - 给出栈的最大容量 <code>capacity</code>。</li>
<li><code>void push(int val)</code> - 将给出的正整数 <code>val</code> 推入 <strong>从左往右第一个 </strong>没有满的栈。</li>
<li><code>int pop()</code> - 返回 <strong>从右往左第一个 </strong>非空栈顶部的值，并将其从栈中删除；如果所有的栈都是空的，请返回 <code>-1</code>。</li>
<li><code>int popAtStack(int index)</code> - 返回编号 <code>index</code> 的栈顶部的值，并将其从栈中删除；如果编号 <code>index</code> 的栈是空的，请返回 <code>-1</code>。</li>
</ul>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入： </strong>
["DinnerPlates","push","push","push","push","push","popAtStack","push","push","popAtStack","popAtStack","pop","pop","pop","pop","pop"]
[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]
<strong>输出：</strong>
[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]

<strong>解释：</strong>
DinnerPlates D = DinnerPlates(2);  // 初始化，栈最大容量 capacity = 2
D.push(1);
D.push(2);
D.push(3);
D.push(4);
D.push(5);         // 栈的现状为：    2  4
                                    1  3  5
                                    ﹈ ﹈ ﹈
D.popAtStack(0);   // 返回 2。栈的现状为：      4
                                          1  3  5
                                          ﹈ ﹈ ﹈
D.push(20);        // 栈的现状为：  20  4
                                   1  3  5
                                   ﹈ ﹈ ﹈
D.push(21);        // 栈的现状为：  20  4 21
                                   1  3  5
                                   ﹈ ﹈ ﹈
D.popAtStack(0);   // 返回 20。栈的现状为：       4 21
                                            1  3  5
                                            ﹈ ﹈ ﹈
D.popAtStack(2);   // 返回 21。栈的现状为：       4
                                            1  3  5
                                            ﹈ ﹈ ﹈ 
D.pop()            // 返回 5。栈的现状为：        4
                                            1  3 
                                            ﹈ ﹈  
D.pop()            // 返回 4。栈的现状为：    1  3 
                                           ﹈ ﹈   
D.pop()            // 返回 3。栈的现状为：    1 
                                           ﹈   
D.pop()            // 返回 1。现在没有栈。
D.pop()            // 返回 -1。仍然没有栈。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 20000</code></li>
<li><code>1 &lt;= val &lt;= 20000</code></li>
<li><code>0 &lt;= index &lt;= 100000</code></li>
<li>最多会对 <code>push</code>，<code>pop</code>，和 <code>popAtStack</code> 进行 <code>200000</code> 次调用。</li>
</ul>
</div></div></div><br><br><hr><br>*******************************************<div id="title">1178. Number of Valid Words for Each Puzzle</div>
*******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p>
<p>字谜的迷面 <code>puzzle</code> 按字符串形式给出，如果一个单词 <code>word</code> 符合下面两个条件，那么它就可以算作谜底：</p>
<ul>
<li>单词 <code>word</code> 中包含谜面 <code>puzzle</code> 的第一个字母。</li>
<li>单词 <code>word</code> 中的每一个字母都可以在谜面 <code>puzzle</code> 中找到。<br/>
	例如，如果字谜的谜面是 "abcdefg"，那么可以作为谜底的单词有 "faced", "cabbage", 和 "baggage"；而 "beefed"（不含字母 "a"）以及 "based"（其中的 "s" 没有出现在谜面中）都不能作为谜底。</li>
</ul>
<p>返回一个答案数组 <code>answer</code>，数组中的每个元素 <code>answer[i]</code> 是在给出的单词列表 <code>words</code> 中可以作为字谜迷面 <code>puzzles[i]</code> 所对应的谜底的单词数目。</p>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>
words = ["aaaa","asas","able","ability","actt","actor","access"], 
puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]
<strong>输出：</strong>[1,1,3,2,4,0]
<strong>解释：</strong>
1 个单词可以作为 "aboveyz" 的谜底 : "aaaa" 
1 个单词可以作为 "abrodyz" 的谜底 : "aaaa"
3 个单词可以作为 "abslute" 的谜底 : "aaaa", "asas", "able"
2 个单词可以作为 "absoryz" 的谜底 : "aaaa", "asas"
4 个单词可以作为 "actresz" 的谜底 : "aaaa", "asas", "actt", "access"
没有单词可以作为 "gaswxyz" 的谜底，因为列表中的单词都不含字母 'g'。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 10^5</code></li>
<li><code>4 &lt;= words[i].length &lt;= 50</code></li>
<li><code>1 &lt;= puzzles.length &lt;= 10^4</code></li>
<li><code>puzzles[i].length == 7</code></li>
<li><code>words[i][j]</code>, <code>puzzles[i][j]</code> 都是小写英文字母。</li>
<li>每个 <code>puzzles[i]</code> 所包含的字符都不重复。</li>
</ul>
</div></div></div><br><br><hr><br>************************************<div id="title">1187. Make Array Strictly Increasing</div>
************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个整数数组 <code>arr1</code> 和 <code>arr2</code>，返回使 <code>arr1</code> 严格递增所需要的最小「操作」数（可能为 0）。</p>
<p>每一步「操作」中，你可以分别从 <code>arr1</code> 和 <code>arr2</code> 中各选出一个索引，分别为 <code>i</code> 和 <code>j</code>，<code>0 &lt;= i &lt; arr1.length</code> 和 <code>0 &lt;= j &lt; arr2.length</code>，然后进行赋值运算 <code>arr1[i] = arr2[j]</code>。</p>
<p>如果无法让 <code>arr1</code> 严格递增，请返回 <code>-1</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
<strong>输出：</strong>1
<strong>解释：</strong>用 2 来替换 <code>5，之后</code> <code>arr1 = [1, 2, 3, 6, 7]</code>。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [4,3,1]
<strong>输出：</strong>2
<strong>解释：</strong>用 3 来替换 <code>5，然后</code>用 4 来替换 3<code>，得到</code> <code>arr1 = [1, 3, 4, 6, 7]</code>。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
<strong>输出：</strong>-1
<strong>解释：</strong>无法使 <code>arr1 严格递增</code>。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr1.length, arr2.length &lt;= 2000</code></li>
<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 10^9</code></li>
</ul>
<p> </p>
</div></div></div><br><br><hr><br>***************************************<div id="title">1192. Critical Connections in a Network</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>力扣数据中心有 <code>n</code> 台服务器，分别按从 <code>0</code> 到 <code>n-1</code> 的方式进行了编号。它们之间以 <strong>服务器到服务器</strong> 的形式相互连接组成了一个内部集群，连接是无向的。用  <code>connections</code> 表示集群网络，<code>connections[i] = [a, b]</code> 表示服务器 <code>a</code> 和 <code>b</code> 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。</p>
<p><strong>关键连接</strong><em> </em>是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。</p>
<p>请你以任意顺序返回该集群内的所有 <strong>关键连接</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png" style="height: 205px; width: 200px;"/></strong></p>
<pre><strong>输入：</strong>n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
<strong>输出：</strong>[[1,3]]
<strong>解释：</strong>[[3,1]] 也是正确的。</pre>
<p><strong>示例 2:</strong></p>
<pre><b>输入：</b>n = 2, connections = [[0,1]]
<b>输出：</b>[[0,1]]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>n - 1 &lt;= connections.length &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
<li>不存在重复的连接</li>
</ul>
</div></div></div><br><br><hr><br>**************************************************<div id="title">1203. Sort Items by Groups Respecting Dependencies</div>
**************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有 <code>n</code> 个项目，每个项目或者不属于任何小组，或者属于 <code>m</code> 个小组之一。<code>group[i]</code> 表示第 <code>i</code> 个项目所属的小组，如果第 <code>i</code> 个项目不属于任何小组，则 <code>group[i]</code> 等于 <code>-1</code>。项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。</p>
<p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p>
<ul>
<li>同一小组的项目，排序后在列表中彼此相邻。</li>
<li>项目之间存在一定的依赖关系，我们用一个列表 <code>beforeItems</code> 来表示，其中 <code>beforeItems[i]</code> 表示在进行第 <code>i</code> 个项目前（位于第 <code>i</code> 个项目左侧）应该完成的所有项目。</li>
</ul>
<p>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 <strong>空列表 </strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/22/1359_ex1.png" style="height: 181px; width: 191px;"/></strong></p>
<pre><strong>输入：</strong>n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
<strong>输出：</strong>[6,3,4,1,5,2,0,7]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
<strong>输出：</strong>[]
<strong>解释：</strong>与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
<li><code>group.length == beforeItems.length == n</code></li>
<li><code>-1 &lt;= group[i] &lt;= m - 1</code></li>
<li><code>0 &lt;= beforeItems[i].length &lt;= n - 1</code></li>
<li><code>0 &lt;= beforeItems[i][j] &lt;= n - 1</code></li>
<li><code>i != beforeItems[i][j]</code></li>
<li><code>beforeItems[i]</code> 不含重复元素</li>
</ul>
</div></div></div><br><br><hr><br>*********************<div id="title">1206. Design Skiplist</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>不使用任何库函数，设计一个 <strong>跳表</strong> 。</p>
<p><strong>跳表</strong> 是在 <code>O(log(n))</code> 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p>
<p>例如，一个跳表包含 <code>[30, 40, 50, 60, 70, 90]</code> ，然后增加 <code>80</code>、<code>45</code> 到跳表中，以下图的方式操作：</p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif"/><br/>
<small>Artyom Kalinin [CC BY-SA 3.0], via <a href="https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif" title="Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons">Wikimedia Commons</a></small></p>
<p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 <code>O(n)</code>。跳表的每一个操作的平均时间复杂度是 <code>O(log(n))</code>，空间复杂度是 <code>O(n)</code>。</p>
<p>了解更多 : <a href="https://en.wikipedia.org/wiki/Skip_list">https://en.wikipedia.org/wiki/Skip_list</a></p>
<p>在本题中，你的设计应该要包含这些函数：</p>
<ul>
<li><code>bool search(int target)</code> : 返回target是否存在于跳表中。</li>
<li><code>void add(int num)</code>: 插入一个元素到跳表。</li>
<li><code>bool erase(int num)</code>: 在跳表中删除一个值，如果 <code>num</code> 不存在，直接返回false. 如果存在多个 <code>num</code> ，删除其中任意一个即可。</li>
</ul>
<p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><b>输入</b>
["Skiplist", "add", "add", "add", "search", "add", "search", "erase", "erase", "search"]
[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]
<strong>输出</strong>
[null, null, null, null, false, null, true, false, true, false]

<strong>解释</strong>
Skiplist skiplist = new Skiplist();
skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0);   // 返回 false
skiplist.add(4);
skiplist.search(1);   // 返回 true
skiplist.erase(0);    // 返回 false，0 不在跳表中
skiplist.erase(1);    // 返回 true
skiplist.search(1);   // 返回 false，1 已被擦除
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt;= num, target &lt;= 2 * 10<sup>4</sup></code></li>
<li>调用<code>search</code>, <code>add</code>,  <code>erase</code>操作次数不大于 <code>5 * 10<sup>4</sup></code> </li>
</ul>
</div></div></div><br><br><hr><br>**************************************************<div id="title">1210. Minimum Moves to Reach Target with Rotations</div>
**************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你还记得那条风靡全球的贪吃蛇吗？</p>
<p>我们在一个 <code>n*n</code> 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（<code>(0, 0)</code> 和 <code>(0, 1)</code>）开始移动。我们用 <code>0</code> 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（<code>(n-1, n-2)</code> 和 <code>(n-1, n-1)</code>）。</p>
<p>每次移动，蛇可以这样走：</p>
<ul>
<li>如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。</li>
<li>如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。</li>
<li>如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（<code>(r, c)</code>、<code>(r, c+1)</code>）移动到 （<code>(r, c)</code>、<code>(r+1, c)</code>）。<br/>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-2.png" style="height: 134px; width: 300px;"/></li>
<li>如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（<code>(r, c)</code>、<code>(r+1, c)</code>）移动到（<code>(r, c)</code>、<code>(r, c+1)</code>）。<br/>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-1.png" style="height: 121px; width: 300px;"/></li>
</ul>
<p>返回蛇抵达目的地所需的最少移动次数。</p>
<p>如果无法到达目的地，请返回 <code>-1</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image.png" style="height: 439px; width: 400px;"/></strong></p>
<pre><strong>输入：</strong>grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
               [0,0,0,0,1,1],
               [0,0,1,0,1,0],
               [0,1,1,0,0,0],
               [0,1,1,0,0,0]]
<strong>输出：</strong>11
<strong>解释：
</strong>一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>grid = [[0,0,1,1,1,1],
               [0,0,0,0,1,1],
               [1,1,0,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,0]]
<strong>输出：</strong>9
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 100</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>
<li>蛇保证从空单元格开始出发。</li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">1220. Count Vowels Permutation</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数 <code>n</code>，请你帮忙统计一下我们可以按下述规则形成多少个长度为 <code>n</code> 的字符串：</p>
<ul>
<li>字符串中的每个字符都应当是小写元音字母（<code>'a'</code>, <code>'e'</code>, <code>'i'</code>, <code>'o'</code>, <code>'u'</code>）</li>
<li>每个元音 <code>'a'</code> 后面都只能跟着 <code>'e'</code></li>
<li>每个元音 <code>'e'</code> 后面只能跟着 <code>'a'</code> 或者是 <code>'i'</code></li>
<li>每个元音 <code>'i'</code> 后面 <strong>不能</strong> 再跟着另一个 <code>'i'</code></li>
<li>每个元音 <code>'o'</code> 后面只能跟着 <code>'i'</code> 或者是 <code>'u'</code></li>
<li>每个元音 <code>'u'</code> 后面只能跟着 <code>'a'</code></li>
</ul>
<p>由于答案可能会很大，所以请你返回 模 <code>10^9 + 7</code> 之后的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>5
<strong>解释：</strong>所有可能的字符串分别是："a", "e", "i" , "o" 和 "u"。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>10
<strong>解释：</strong>所有可能的字符串分别是："ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" 和 "ua"。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 5
<strong>输出：</strong>68</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 2 * 10^4</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">1223. Dice Roll Simulation</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p>
<p>不过我们在使用它时有个约束，就是使得投掷骰子时，<strong>连续</strong> 掷出数字 <code>i</code> 的次数不能超过 <code>rollMax[i]</code>（<code>i</code> 从 1 开始编号）。</p>
<p>现在，给你一个整数数组 <code>rollMax</code> 和一个整数 <code>n</code>，请你来计算掷 <code>n</code> 次骰子可得到的不同点数序列的数量。</p>
<p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 <strong>模 <code>10^9 + 7</code></strong> 之后的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 2, rollMax = [1,1,2,2,2,3]
<strong>输出：</strong>34
<strong>解释：</strong>我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2, rollMax = [1,1,1,1,1,1]
<strong>输出：</strong>30
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 3, rollMax = [1,1,1,2,2,3]
<strong>输出：</strong>181
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>rollMax.length == 6</code></li>
<li><code>1 &lt;= rollMax[i] &lt;= 15</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">1224. Maximum Equal Frequency</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个正整数数组 <code>nums</code>，请你帮忙从该数组中找出能满足下面要求的 <strong>最长</strong> 前缀，并返回该前缀的长度：</p>
<ul>
<li>从前缀中 <strong>恰好删除一个</strong> 元素后，剩下每个数字的出现次数都相同。</li>
</ul>
<p>如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [2,2,1,1,5,3,3,5]
<strong>输出：</strong>7
<strong>解释：</strong>对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4] = 5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]
<strong>输出：</strong>13
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">1235. Maximum Profit in Job Scheduling</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你打算利用空闲时间来做兼职工作赚些零花钱。</p>
<p>这里有 <code>n</code> 份兼职工作，每份工作预计从 <code>startTime[i]</code> 开始到 <code>endTime[i]</code> 结束，报酬为 <code>profit[i]</code>。</p>
<p>给你一份兼职工作表，包含开始时间 <code>startTime</code>，结束时间 <code>endTime</code> 和预计报酬 <code>profit</code> 三个数组，请你计算并返回可以获得的最大报酬。</p>
<p>注意，时间上出现重叠的 2 份工作不能同时进行。</p>
<p>如果你选择的工作在时间 <code>X</code> 结束，那么你可以立刻进行在时间 <code>X</code> 开始的下一份工作。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample1_1584.png" style="width: 300px;"/></strong></p>
<pre><strong>输入：</strong>startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
<strong>输出：</strong>120
<strong>解释：
</strong>我们选出第 1 份和第 4 份工作， 
时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample22_1584.png" style="height: 112px; width: 600px;"/> </strong></p>
<pre><strong>输入：</strong>startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
<strong>输出：</strong>150
<strong>解释：
</strong>我们选择第 1，4，5 份工作。 
共获得报酬 150 = 20 + 70 + 60。
</pre>
<p><strong>示例 3：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample3_1584.png" style="height: 112px; width: 400px;"/></strong></p>
<pre><strong>输入：</strong>startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
<strong>输出：</strong>6
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= startTime.length == endTime.length == profit.length &lt;= 5 * 10^4</code></li>
<li><code>1 &lt;= startTime[i] &lt; endTime[i] &lt;= 10^9</code></li>
<li><code>1 &lt;= profit[i] &lt;= 10^4</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************************<div id="title">1240. Tiling a Rectangle with the Fewest Squares</div>
************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。</p>
<p>房子的客厅大小为 <code>n</code> x <code>m</code>，为保持极简的风格，需要使用尽可能少的 <strong>正方形</strong> 瓷砖来铺盖地面。</p>
<p>假设正方形瓷砖的规格不限，边长都是整数。</p>
<p>请你帮设计师计算一下，最少需要用到多少块方形瓷砖？</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_11_1592.png" style="height: 106px; width: 154px;"/></p>
<pre><strong>输入：</strong>n = 2, m = 3
<strong>输出：</strong>3
<code><strong>解释：</strong>3</code> 块地砖就可以铺满卧室。
<code>     2</code> 块 <code>1x1 地砖</code>
<code>     1</code> 块 <code>2x2 地砖</code></pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_22_1592.png" style="height: 126px; width: 224px;"/></p>
<pre><strong>输入：</strong>n = 5, m = 8
<strong>输出：</strong>5
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_33_1592.png" style="height: 189px; width: 224px;"/></p>
<pre><strong>输入：</strong>n = 11, m = 13
<strong>输出：</strong>6
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 13</code></li>
<li><code>1 &lt;= m &lt;= 13</code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1250. Check If It Is a Good Array</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个正整数数组 <code>nums</code>，你需要从中任选一些子集，然后将子集中每一个数乘以一个 <strong>任意整数</strong>，并求出他们的和。</p>
<p>假如该和结果为 <code>1</code>，那么原数组就是一个「<strong>好数组</strong>」，则返回 <code>True</code>；否则请返回 <code>False</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [12,5,7,23]
<strong>输出：</strong>true
<strong>解释：</strong>挑选数字 5 和 7。
5*3 + 7*(-2) = 1
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [29,6,10]
<strong>输出：</strong>true
<strong>解释：</strong>挑选数字 29, 6 和 10。
29*1 + 6*(-3) + 10*(-1) = 1
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [3,6]
<strong>输出：</strong>false
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************************<div id="title">1255. Maximum Score Words Formed by Letters</div>
*******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你将会得到一份单词表 <code>words</code>，一个字母表 <code>letters</code> （可能会有重复字母），以及每个字母对应的得分情况表 <code>score</code>。</p>
<p>请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 <code>letters</code> 里的字母拼写出的 <strong>任意</strong> 属于 <code>words</code> 单词子集中，分数最高的单词集合的得分。</p>
<p>单词拼写游戏的规则概述如下：</p>
<ul>
<li>玩家需要用字母表 <code>letters</code> 里的字母来拼写单词表 <code>words</code> 中的单词。</li>
<li>可以只使用字母表 <code>letters</code> 中的部分字母，但是每个字母最多被使用一次。</li>
<li>单词表 <code>words</code> 中每个单词只能计分（使用）一次。</li>
<li>根据字母得分情况表<code>score</code>，字母 <code>'a'</code>, <code>'b'</code>, <code>'c'</code>, ... , <code>'z'</code> 对应的得分分别为 <code>score[0]</code>, <code>score[1]</code>, ..., <code>score[25]</code>。</li>
<li>本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>words = ["dog","cat","dad","good"], letters = ["a","a","c","d","d","d","g","o","o"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
<strong>输出：</strong>23
<strong>解释：</strong>
字母得分为  a=1, c=9, d=5, g=3, o=2
使用给定的字母表 letters，我们可以拼写单词 "dad" (5+1+5)和 "good" (3+2+2+5)，得分为 23 。
而单词 "dad" 和 "dog" 只能得到 21 分。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>words = ["xxxz","ax","bx","cx"], letters = ["z","a","b","c","x","x","x"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
<strong>输出：</strong>27
<strong>解释：</strong>
字母得分为  a=4, b=4, c=4, x=5, z=10
使用给定的字母表 letters，我们可以组成单词 "ax" (4+5)， "bx" (4+5) 和 "cx" (4+5) ，总得分为 27 。
单词 "xxxz" 的得分仅为 25 。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>words = ["leetcode"], letters = ["l","e","t","c","o","d"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
<strong>输出：</strong>0
<strong>解释：</strong>
字母 "e" 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 14</code></li>
<li><code>1 &lt;= words[i].length &lt;= 15</code></li>
<li><code>1 &lt;= letters.length &lt;= 100</code></li>
<li><code>letters[i].length == 1</code></li>
<li><code>score.length == 26</code></li>
<li><code>0 &lt;= score[i] &lt;= 10</code></li>
<li><code>words[i]</code> 和 <code>letters[i]</code> 只包含小写的英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************************<div id="title">1263. Minimum Moves to Move a Box to Their Target Location</div>
**********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。</p>
<p>游戏地图用大小为 <code>m x n</code> 的网格 <code>grid</code> 表示，其中每个元素可以是墙、地板或者是箱子。</p>
<p>现在你将作为玩家参与游戏，按规则将箱子 <code>'B'</code> 移动到目标位置 <code>'T'</code> ：</p>
<ul>
<li>玩家用字符 <code>'S'</code> 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。</li>
<li>地板用字符 <code>'.'</code> 表示，意味着可以自由行走。</li>
<li>墙用字符 <code>'#'</code> 表示，意味着障碍物，不能通行。 </li>
<li>箱子仅有一个，用字符 <code>'B'</code> 表示。相应地，网格上有一个目标位置 <code>'T'</code>。</li>
<li>玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。</li>
<li>玩家无法越过箱子。</li>
</ul>
<p>返回将箱子推到目标位置的最小 <strong>推动</strong> 次数，如果无法做到，请返回 <code>-1</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/sample_1_1620.png" style="height: 335px; width: 500px;"/></strong></p>
<pre><strong>输入：</strong>grid = [["#","#","#","#","#","#"],
             ["#","T","#","#","#","#"],
             ["#",".",".","B",".","#"],
             ["#",".","#","#",".","#"],
             ["#",".",".",".","S","#"],
             ["#","#","#","#","#","#"]]
<strong>输出：</strong>3
<strong>解释：</strong>我们只需要返回推箱子的次数。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>grid = [["#","#","#","#","#","#"],
             ["#","T","#","#","#","#"],
             ["#",".",".","B",".","#"],
             ["#","#","#","#",".","#"],
             ["#",".",".",".","S","#"],
             ["#","#","#","#","#","#"]]
<strong>输出：</strong>-1
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>grid = [["#","#","#","#","#","#"],
             ["#","T",".",".","#","#"],
             ["#",".","#","B",".","#"],
             ["#",".",".",".",".","#"],
             ["#",".",".",".","S","#"],
             ["#","#","#","#","#","#"]]
<strong>输出：</strong>5
<strong>解释：</strong>向下、向左、向左、向上再向上。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 20</code></li>
<li><code>grid</code> 仅包含字符 <code>'.'</code>, <code>'#'</code>,  <code>'S'</code> , <code>'T'</code>, 以及 <code>'B'</code>。</li>
<li><code>grid</code> 中 <code>'S'</code>, <code>'B'</code> 和 <code>'T'</code> 各只能出现一个。</li>
</ul>
</div></div></div><br><br><hr><br>***************************************************************<div id="title">1269. Number of Ways to Stay in the Same Place After Some Steps</div>
***************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一个长度为 <code>arrLen</code> 的数组，开始有一个指针在索引 <code>0</code> 处。</p>
<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>
<p>给你两个整数 <code>steps</code> 和 <code>arrLen</code> ，请你计算并返回：在恰好执行 <code>steps</code> 次操作以后，指针仍然指向索引 <code>0</code> 处的方案数。</p>
<p>由于答案可能会很大，请返回方案数 <strong>模</strong> <code>10^9 + 7</code> 后的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>steps = 3, arrLen = 2
<strong>输出：</strong>4
<strong>解释：</strong>3 步后，总共有 4 种不同的方法可以停在索引 0 处。
向右，向左，不动
不动，向右，向左
向右，不动，向左
不动，不动，不动
</pre>
<p><strong>示例  2：</strong></p>
<pre><strong>输入：</strong>steps = 2, arrLen = 4
<strong>输出：</strong>2
<strong>解释：</strong>2 步后，总共有 2 种不同的方法可以停在索引 0 处。
向右，向左
不动，不动
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>steps = 4, arrLen = 2
<strong>输出：</strong>8
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= steps &lt;= 500</code></li>
<li><code>1 &lt;= arrLen &lt;= 10<sup>6</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1278. Palindrome Partitioning III</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个由小写字母组成的字符串 <code>s</code>，和一个整数 <code>k</code>。</p>
<p>请你按下面的要求分割字符串：</p>
<ul>
<li>首先，你可以将 <code>s</code> 中的部分字符修改为其他的小写英文字母。</li>
<li>接着，你需要把 <code>s</code> 分割成 <code>k</code> 个非空且不相交的子串，并且每个子串都是回文串。</li>
</ul>
<p>请返回以这种方式分割字符串所需修改的最少字符数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "abc", k = 2
<strong>输出：</strong>1
<strong>解释：</strong>你可以把字符串分割成 "ab" 和 "c"，并修改 "ab" 中的 1 个字符，将它变成回文串。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "aabbc", k = 3
<strong>输出：</strong>0
<strong>解释：</strong>你可以把字符串分割成 "aa"、"bb" 和 "c"，它们都是回文串。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "leetcode", k = 8
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 中只含有小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*********************************************************************<div id="title">1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</div>
*********************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m x n</code> 的二进制矩阵 <code>mat</code>。每一步，你可以选择一个单元格并将它反转（反转表示 <code>0</code> 变 <code>1</code> ，<code>1</code> 变 <code>0</code> ）。如果存在和它相邻的单元格，那么这些相邻的单元格也会被反转。相邻的两个单元格共享同一条边。</p>
<p>请你返回将矩阵 <code>mat</code> 转化为全零矩阵的<em>最少反转次数</em>，如果无法转化为全零矩阵，请返回 <code>-1</code> 。</p>
<p><strong>二进制矩阵</strong> 的每一个格子要么是 <code>0</code> 要么是 <code>1</code> 。</p>
<p><strong>全零矩阵</strong> 是所有格子都为 <code>0</code> 的矩阵。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/13/matrix.png"/></p>
<pre><strong>输入：</strong>mat = [[0,0],[0,1]]
<strong>输出：</strong>3
<strong>解释：</strong>一个可能的解是反转 (1, 0)，然后 (0, 1) ，最后是 (1, 1) 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>mat = [[0]]
<strong>输出：</strong>0
<strong>解释：</strong>给出的矩阵是全零矩阵，所以你不需要改变它。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>mat = [[1,0,0],[1,0,0]]
<strong>输出：</strong>-1
<strong>解释：</strong>该矩阵无法转变成全零矩阵
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[0].length</code></li>
<li><code>1 &lt;= m &lt;= 3</code></li>
<li><code>1 &lt;= n &lt;= 3</code></li>
<li><code>mat[i][j]</code> 是 0 或 1 。</li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1289. Minimum Falling Path Sum II</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>n x n</code> 整数矩阵 <code>arr</code> ，请你返回 <strong>非零偏移下降路径</strong> 数字和的最小值。</p>
<p><strong>非零偏移下降路径</strong> 定义为：从 <code>arr</code> 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/falling-grid.jpg" style="width: 244px; height: 245px;"/></p>
<pre><strong>输入：</strong>arr = [[1,2,3],[4,5,6],[7,8,9]]
<strong>输出：</strong>13
<strong>解释：</strong>
所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>grid = [[7]]
<strong>输出：</strong>7
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == grid.length == grid[i].length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>-99 &lt;= grid[i][j] &lt;= 99</code></li>
</ul>
</div></div></div><br><br><hr><br>********************************************************<div id="title">1293. Shortest Path in a Grid with Obstacles Elimination</div>
********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m * n</code> 的网格，其中每个单元格不是 <code>0</code>（空）就是 <code>1</code>（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。</p>
<p>如果您 <strong>最多</strong> 可以消除 <code>k</code> 个障碍物，请找出从左上角 <code>(0, 0)</code> 到右下角 <code>(m-1, n-1)</code> 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg"/></p>
<pre><strong>输入：</strong> grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
<strong>输出：</strong>6
<strong>解释：
</strong>不消除任何障碍的最短路径是 10。
消除位置 (3,2) 处的障碍后，最短路径是 6 。该路径是 <code>(0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; <strong>(3,2)</strong> -&gt; (4,2)</code>.
</pre>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg"/></p>
<pre><strong>输入：</strong>grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1
<strong>输出：</strong>-1
<strong>解释：</strong>我们至少需要消除两个障碍才能找到这样的路径。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>grid.length == m</code></li>
<li><code>grid[0].length == n</code></li>
<li><code>1 &lt;= m, n &lt;= 40</code></li>
<li><code>1 &lt;= k &lt;= m*n</code></li>
<li><code>grid[i][j]</code> 是 <code>0</code> 或<strong> </strong><code>1</code></li>
<li><code>grid[0][0] == grid[m-1][n-1] == 0</code></li>
</ul>
</div></div></div><br><br><hr><br>********************************************<div id="title">1298. Maximum Candies You Can Get from Boxes</div>
********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你 <code>n</code> 个盒子，每个盒子的格式为 <code>[status, candies, keys, containedBoxes]</code> ，其中：</p>
<ul>
<li>状态字 <code>status[i]</code>：整数，如果 <code>box[i]</code> 是开的，那么是 <strong>1 </strong>，否则是 <strong>0 </strong>。</li>
<li>糖果数 <code>candies[i]</code>: 整数，表示 <code>box[i]</code> 中糖果的数目。</li>
<li>钥匙 <code>keys[i]</code>：数组，表示你打开 <code>box[i]</code> 后，可以得到一些盒子的钥匙，每个元素分别为该钥匙对应盒子的下标。</li>
<li>内含的盒子 <code>containedBoxes[i]</code>：整数，表示放在 <code>box[i]</code> 里的盒子所对应的下标。</li>
</ul>
<p>给你一个 <code>initialBoxes</code> 数组，表示你现在得到的盒子，你可以获得里面的糖果，也可以用盒子里的钥匙打开新的盒子，还可以继续探索从这个盒子里找到的其他盒子。</p>
<p>请你按照上述规则，返回可以获得糖果的 <strong>最大数目 </strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]
<strong>输出：</strong>16
<strong>解释：
</strong>一开始你有盒子 0 。你将获得它里面的 7 个糖果和盒子 1 和 2。
盒子 1 目前状态是关闭的，而且你还没有对应它的钥匙。所以你将会打开盒子 2 ，并得到里面的 4 个糖果和盒子 1 的钥匙。
在盒子 1 中，你会获得 5 个糖果和盒子 3 ，但是你没法获得盒子 3 的钥匙所以盒子 3 会保持关闭状态。
你总共可以获得的糖果数目 = 7 + 4 + 5 = 16 个。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]
<strong>输出：</strong>6
<strong>解释：
</strong>你一开始拥有盒子 0 。打开它你可以找到盒子 1,2,3,4,5 和它们对应的钥匙。
打开这些盒子，你将获得所有盒子的糖果，所以总糖果数为 6 个。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>status = [1,1,1], candies = [100,1,100], keys = [[],[0,2],[]], containedBoxes = [[],[],[]], initialBoxes = [1]
<strong>输出：</strong>1
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>status = [1], candies = [100], keys = [[]], containedBoxes = [[]], initialBoxes = []
<strong>输出：</strong>0
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>status = [1,1,1], candies = [2,3,2], keys = [[],[],[]], containedBoxes = [[],[],[]], initialBoxes = [2,1,0]
<strong>输出：</strong>7
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= status.length &lt;= 1000</code></li>
<li><code>status.length == candies.length == keys.length == containedBoxes.length == n</code></li>
<li><code>status[i]</code> 要么是 <code>0</code> 要么是 <code>1</code> 。</li>
<li><code>1 &lt;= candies[i] &lt;= 1000</code></li>
<li><code>0 &lt;= keys[i].length &lt;= status.length</code></li>
<li><code>0 &lt;= keys[i][j] &lt; status.length</code></li>
<li><code>keys[i]</code> 中的值都是互不相同的。</li>
<li><code>0 &lt;= containedBoxes[i].length &lt;= status.length</code></li>
<li><code>0 &lt;= containedBoxes[i][j] &lt; status.length</code></li>
<li><code>containedBoxes[i]</code> 中的值都是互不相同的。</li>
<li>每个盒子最多被一个盒子包含。</li>
<li><code>0 &lt;= initialBoxes.length &lt;= status.length</code></li>
<li><code>0 &lt;= initialBoxes[i] &lt; status.length</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************<div id="title">1301. Number of Paths with Max Score</div>
************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个正方形字符数组 <code>board</code> ，你从数组最右下方的字符 <code>'S'</code> 出发。</p>
<p>你的目标是到达数组最左上角的字符 <code>'E'</code> ，数组剩余的部分为数字字符 <code>1, 2, ..., 9</code> 或者障碍 <code>'X'</code>。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。</p>
<p>一条路径的 「得分」 定义为：路径上所有数字的和。</p>
<p>请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对 <strong><code>10^9 + 7</code></strong> <strong>取余</strong>。</p>
<p>如果没有任何路径可以到达终点，请返回 <code>[0, 0]</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>board = ["E23","2X2","12S"]
<strong>输出：</strong>[7,1]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>board = ["E12","1X1","21S"]
<strong>输出：</strong>[4,2]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>board = ["E11","XXX","11S"]
<strong>输出：</strong>[0,0]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= board.length == board[i].length &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">1307. Verbal Arithmetic Puzzle</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个方程，左边用 <code>words</code> 表示，右边用 <code>result</code> 表示。</p>
<p>你需要根据以下规则检查方程是否可解：</p>
<ul>
<li>每个字符都会被解码成一位数字（0 - 9）。</li>
<li>每对不同的字符必须映射到不同的数字。</li>
<li>每个 <code>words[i]</code> 和 <code>result</code> 都会被解码成一个没有前导零的数字。</li>
<li>左侧数字之和（<code>words</code>）等于右侧数字（<code>result</code>）。 </li>
</ul>
<p>如果方程可解，返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>words = ["SEND","MORE"], result = "MONEY"
<strong>输出：</strong>true
<strong>解释：</strong>映射 'S'-&gt; 9, 'E'-&gt;5, 'N'-&gt;6, 'D'-&gt;7, 'M'-&gt;1, 'O'-&gt;0, 'R'-&gt;8, 'Y'-&gt;'2'
所以 "SEND" + "MORE" = "MONEY" ,  9567 + 1085 = 10652</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>words = ["SIX","SEVEN","SEVEN"], result = "TWENTY"
<strong>输出：</strong>true
<strong>解释：</strong>映射 'S'-&gt; 6, 'I'-&gt;5, 'X'-&gt;0, 'E'-&gt;8, 'V'-&gt;7, 'N'-&gt;2, 'T'-&gt;1, 'W'-&gt;'3', 'Y'-&gt;4
所以 "SIX" + "SEVEN" + "SEVEN" = "TWENTY" ,  650 + 68782 + 68782 = 138214</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>words = ["THIS","IS","TOO"], result = "FUNNY"
<strong>输出：</strong>true
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>words = ["LEET","CODE"], result = "POINT"
<strong>输出：</strong>false
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= words.length &lt;= 5</code></li>
<li><code>1 &lt;= words[i].length, results.length &lt;= 7</code></li>
<li><code>words[i], result</code> 只含有大写英文字母</li>
<li>表达式中使用的不同字符数最大为 10</li>
</ul>
</div></div></div><br><br><hr><br>*********************************************************<div id="title">1312. Minimum Insertion Steps to Make a String Palindrome</div>
*********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。</p>
<p>请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。</p>
<p>「回文串」是正读和反读都相同的字符串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "zzazz"
<strong>输出：</strong>0
<strong>解释：</strong>字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "mbadm"
<strong>输出：</strong>2
<strong>解释：</strong>字符串可变为 "mbdadbm" 或者 "mdbabdm" 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "leetcode"
<strong>输出：</strong>5
<strong>解释：</strong>插入 5 个字符后字符串变为 "leetcodocteel" 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 中所有字符都是小写字母。</li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">1316. Distinct Echo Substrings</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>text</code> ，请你返回满足下述条件的 <strong>不同</strong> 非空子字符串的数目：</p>
<ul>
<li>可以写成某个字符串与其自身相连接的形式（即，可以写为 <code>a + a</code>，其中 <code>a</code> 是某个字符串）。</li>
</ul>
<p>例如，<code>abcabc</code> 就是 <code>abc</code> 和它自身连接形成的。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>text = "abcabcabc"
<strong>输出：</strong>3
<strong>解释：</strong>3 个子字符串分别为 "abcabc"，"bcabca" 和 "cabcab" 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>text = "leetcodeleetcode"
<strong>输出：</strong>2
<strong>解释：</strong>2 个子字符串为 "ee" 和 "leetcodeleetcode" 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text.length &lt;= 2000</code></li>
<li><code>text</code> 只包含小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*******************************************************<div id="title">1320. Minimum Distance to Type a Word Using Two Fingers</div>
*******************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/leetcode_keyboard.png"/></p>
<p>二指输入法定制键盘在 <strong>X-Y</strong> 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处。</p>
<ul>
<li>例如字母 <strong>A</strong> 位于坐标 <strong>(0,0)</strong>，字母 <strong>B</strong> 位于坐标 <strong>(0,1)</strong>，字母 <strong>P</strong> 位于坐标 <strong>(2,3)</strong> 且字母 <strong>Z</strong> 位于坐标 <strong>(4,1)</strong>。</li>
</ul>
<p>给你一个待输入字符串 <code>word</code>，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。</p>
<p>坐标<code> <strong>(x<sub>1</sub>,y<sub>1</sub>)</strong> </code>和 <code><strong>(x<sub>2</sub>,y<sub>2</sub>)</strong></code> 之间的 <strong>距离</strong> 是 <code><strong>|x<sub>1</sub> - x<sub>2</sub>| + |y<sub>1</sub> - y<sub>2</sub>|</strong></code>。 </p>
<p><strong>注意</strong>，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>word = "CAKE"
<strong>输出：</strong>3
<strong>解释： 
</strong>使用两根手指输入 "CAKE" 的最佳方案之一是： 
手指 1 在字母 'C' 上 -&gt; 移动距离 = 0 
手指 1 在字母 'A' 上 -&gt; 移动距离 = 从字母 'C' 到字母 'A' 的距离 = 2 
手指 2 在字母 'K' 上 -&gt; 移动距离 = 0 
手指 2 在字母 'E' 上 -&gt; 移动距离 = 从字母 'K' 到字母 'E' 的距离  = 1 
总距离 = 3
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>word = "HAPPY"
<strong>输出：</strong>6
<strong>解释： </strong>
使用两根手指输入 "HAPPY" 的最佳方案之一是：
手指 1 在字母 'H' 上 -&gt; 移动距离 = 0
手指 1 在字母 'A' 上 -&gt; 移动距离 = 从字母 'H' 到字母 'A' 的距离 = 2
手指 2 在字母 'P' 上 -&gt; 移动距离 = 0
手指 2 在字母 'P' 上 -&gt; 移动距离 = 从字母 'P' 到字母 'P' 的距离 = 0
手指 1 在字母 'Y' 上 -&gt; 移动距离 = 从字母 'A' 到字母 'Y' 的距离 = 4
总距离 = 6
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= word.length &lt;= 300</code></li>
<li>每个 <code>word[i]</code> 都是一个大写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>******************************************************<div id="title">1326. Minimum Number of Taps to Open to Water a Garden</div>
******************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在 x 轴上有一个一维的花园。花园长度为 <code>n</code>，从点 <code>0</code> 开始，到点 <code>n</code> 结束。</p>
<p>花园里总共有 <code>n + 1</code> 个水龙头，分别位于 <code>[0, 1, ..., n]</code> 。</p>
<p>给你一个整数 <code>n</code> 和一个长度为 <code>n + 1</code> 的整数数组 <code>ranges</code> ，其中 <code>ranges[i]</code> （下标从 0 开始）表示：如果打开点 <code>i</code> 处的水龙头，可以灌溉的区域为 <code>[i -  ranges[i], i + ranges[i]]</code> 。</p>
<p>请你返回可以灌溉整个花园的 <strong>最少水龙头数目</strong> 。如果花园始终存在无法灌溉到的地方，请你返回 <strong>-1</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/19/1685_example_1.png"/></p>
<pre><strong>输入：</strong>n = 5, ranges = [3,4,1,1,0,0]
<strong>输出：</strong>1
<strong>解释：
</strong>点 0 处的水龙头可以灌溉区间 [-3,3]
点 1 处的水龙头可以灌溉区间 [-3,5]
点 2 处的水龙头可以灌溉区间 [1,3]
点 3 处的水龙头可以灌溉区间 [2,4]
点 4 处的水龙头可以灌溉区间 [4,4]
点 5 处的水龙头可以灌溉区间 [5,5]
只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 3, ranges = [0,0,0,0]
<strong>输出：</strong>-1
<strong>解释：</strong>即使打开所有水龙头，你也无法灌溉整个花园。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
<li><code>ranges.length == n + 1</code></li>
<li><code>0 &lt;= ranges[i] &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">1330. Reverse Subarray To Maximize Array Value</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 。「数组值」定义为所有满足 <code>0 &lt;= i &lt; nums.length-1</code> 的 <code>|nums[i]-nums[i+1]|</code> 的和。</p>
<p>你可以选择给定数组的任意子数组，并将该子数组翻转。但你只能执行这个操作 <strong>一次</strong> 。</p>
<p>请你找到可行的最大 <strong>数组值 </strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [2,3,1,5,4]
<strong>输出：</strong>10
<strong>解释：</strong>通过翻转子数组 [3,1,5] ，数组变成 [2,5,1,3,4] ，数组值为 10 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [2,4,9,24,2,1,10]
<strong>输出：</strong>68
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3*10^4</code></li>
<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
</div></div></div><br><br><hr><br>******************************************<div id="title">1335. Minimum Difficulty of a Job Schedule</div>
******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你需要制定一份 <code>d</code> 天的工作计划表。工作之间存在依赖，要想执行第 <code>i</code> 项工作，你必须完成全部 <code>j</code> 项工作（ <code>0 &lt;= j &lt; i</code>）。</p>
<p>你每天 <strong>至少</strong> 需要完成一项任务。工作计划的总难度是这 <code>d</code> 天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。</p>
<p>给你一个整数数组 <code>jobDifficulty</code> 和一个整数 <code>d</code>，分别代表工作难度和需要计划的天数。第 <code>i</code> 项工作的难度是 <code>jobDifficulty[i]</code>。</p>
<p>返回整个工作计划的 <strong>最小难度</strong> 。如果无法制定工作计划，则返回 <strong>-1 </strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/untitled.png" style="height: 304px; width: 365px;"/></p>
<pre><strong>输入：</strong>jobDifficulty = [6,5,4,3,2,1], d = 2
<strong>输出：</strong>7
<strong>解释：</strong>第一天，您可以完成前 5 项工作，总难度 = 6.
第二天，您可以完成最后一项工作，总难度 = 1.
计划表的难度 = 6 + 1 = 7 
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>jobDifficulty = [9,9,9], d = 4
<strong>输出：</strong>-1
<strong>解释：</strong>就算你每天完成一项工作，仍然有一天是空闲的，你无法制定一份能够满足既定工作时间的计划表。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>jobDifficulty = [1,1,1], d = 3
<strong>输出：</strong>3
<strong>解释：</strong>工作计划为每天一项工作，总难度为 3 。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>jobDifficulty = [7,1,7,1,7,1], d = 3
<strong>输出：</strong>15
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>jobDifficulty = [11,111,22,222,33,333,44,444], d = 6
<strong>输出：</strong>843
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= jobDifficulty.length &lt;= 300</code></li>
<li><code>0 &lt;= jobDifficulty[i] &lt;= 1000</code></li>
<li><code>1 &lt;= d &lt;= 10</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************<div id="title">1340. Jump Game V</div>
*****************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>d</code> 。每一步你可以从下标 <code>i</code> 跳到：</p>
<ul>
<li><code>i + x</code> ，其中 <code>i + x &lt; arr.length</code> 且 <code>0 &lt; x &lt;= d</code> 。</li>
<li><code>i - x</code> ，其中 <code>i - x &gt;= 0</code> 且 <code>0 &lt; x &lt;= d</code> 。</li>
</ul>
<p>除此以外，你从下标 <code>i</code> 跳到下标 <code>j</code> 需要满足：<code>arr[i] &gt; arr[j]</code> 且 <code>arr[i] &gt; arr[k]</code> ，其中下标 <code>k</code> 是所有 <code>i</code> 到 <code>j</code> 之间的数字（更正式的，<code>min(i, j) &lt; k &lt; max(i, j)</code>）。</p>
<p>你可以选择数组的任意下标开始跳跃。请你返回你 <strong>最多</strong> 可以访问多少个下标。</p>
<p>请注意，任何时刻你都不能跳到数组的外面。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/meta-chart.jpeg" style="height: 419px; width: 633px;"/></p>
<pre><strong>输入：</strong>arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2
<strong>输出：</strong>4
<strong>解释：</strong>你可以从下标 10 出发，然后如上图依次经过 10 --&gt; 8 --&gt; 6 --&gt; 7 。
注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 &gt; 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 &gt; 9 。
类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>arr = [3,3,3,3,3], d = 3
<strong>输出：</strong>1
<strong>解释：</strong>你可以从任意下标处开始且你永远无法跳到任何其他坐标。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>arr = [7,6,5,4,3,2,1], d = 1
<strong>输出：</strong>7
<strong>解释：</strong>从下标 0 处开始，你可以按照数值从大到小，访问所有的下标。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>arr = [7,1,7,1,7,1], d = 2
<strong>输出：</strong>2
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>arr = [66], d = 1
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 1000</code></li>
<li><code>1 &lt;= arr[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= d &lt;= arr.length</code></li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">1345. Jump Game IV</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>arr</code> ，你一开始在数组的第一个元素处（下标为 0）。</p>
<p>每一步，你可以从下标 <code>i</code> 跳到下标 <code>i + 1</code> 、<code>i - 1</code> 或者 <code>j</code> ：</p>
<ul>
<li><code>i + 1</code> 需满足：<code>i + 1 &lt; arr.length</code></li>
<li><code>i - 1</code> 需满足：<code>i - 1 &gt;= 0</code></li>
<li><code>j</code> 需满足：<code>arr[i] == arr[j]</code> 且 <code>i != j</code></li>
</ul>
<p>请你返回到达数组最后一个元素的下标处所需的 <strong>最少操作次数</strong> 。</p>
<p>注意：任何时候你都不能跳到数组外面。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>arr = [100,-23,-23,404,100,23,23,23,3,404]
<strong>输出：</strong>3
<strong>解释：</strong>那你需要跳跃 3 次，下标依次为 0 --&gt; 4 --&gt; 3 --&gt; 9 。下标 9 为数组的最后一个元素的下标。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>arr = [7]
<strong>输出：</strong>0
<strong>解释：</strong>一开始就在最后一个元素处，所以你不需要跳跃。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>arr = [7,6,9,6,9,6,9,7]
<strong>输出：</strong>1
<strong>解释：</strong>你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>-10<sup>8</sup> &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************<div id="title">1349. Maximum Students Taking Exam</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m * n</code> 的矩阵 <code>seats</code> 表示教室中的座位分布。如果座位是坏的（不可用），就用 <code>'#'</code> 表示；否则，用 <code>'.'</code> 表示。</p>
<p>学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。</p>
<p>学生必须坐在状况良好的座位上。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/09/image.png" style="height: 197px; width: 339px;"/></p>
<pre><strong>输入：</strong>seats = [["#",".","#","#",".","#"],
              [".","#","#","#","#","."],
              ["#",".","#","#",".","#"]]
<strong>输出：</strong>4
<strong>解释：</strong>教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。 
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>seats = [[".","#"],
              ["#","#"],
              ["#","."],
              ["#","#"],
              [".","#"]]
<strong>输出：</strong>3
<strong>解释：</strong>让所有学生坐在可用的座位上。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>seats = [["#",".","<strong>.</strong>",".","#"],
              ["<strong>.</strong>","#","<strong>.</strong>","#","<strong>.</strong>"],
              ["<strong>.</strong>",".","#",".","<strong>.</strong>"],
              ["<strong>.</strong>","#","<strong>.</strong>","#","<strong>.</strong>"],
              ["#",".","<strong>.</strong>",".","#"]]
<strong>输出：</strong>10
<strong>解释：</strong>让学生坐在第 1、3 和 5 列的可用座位上。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>seats</code> 只包含字符 <code>'.' 和</code><code>'#'</code></li>
<li><code>m == seats.length</code></li>
<li><code>n == seats[i].length</code></li>
<li><code>1 &lt;= m &lt;= 8</code></li>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
</div></div></div><br><br><hr><br>***********************************************<div id="title">1354. Construct Target Array With Multiple Sums</div>
***********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>target</code> 。一开始，你有一个数组 <code>A</code> ，它的所有元素均为 1 ，你可以执行以下操作：</p>
<ul>
<li>令 <code>x</code> 为你数组里所有元素的和</li>
<li>选择满足 <code>0 &lt;= i &lt; target.size</code> 的任意下标 <code>i</code> ，并让 <code>A</code> 数组里下标为 <code>i</code> 处的值为 <code>x</code> 。</li>
<li>你可以重复该过程任意次</li>
</ul>
<p>如果能从 <code>A</code> 开始构造出目标数组 <code>target</code> ，请你返回 True ，否则返回 False 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>target = [9,3,5]
<strong>输出：</strong>true
<strong>解释：</strong>从 [1, 1, 1] 开始
[1, 1, 1], 和为 3 ，选择下标 1
[1, 3, 1], 和为 5， 选择下标 2
[1, 3, 5], 和为 9， 选择下标 0
[9, 3, 5] 完成
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>target = [1,1,1,2]
<strong>输出：</strong>false
<strong>解释：</strong>不可能从 [1,1,1,1] 出发构造目标数组。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>target = [8,5]
<strong>输出：</strong>true
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>N == target.length</code></li>
<li><code>1 &lt;= target.length &lt;= 5 * 10^4</code></li>
<li><code>1 &lt;= target[i] &lt;= 10^9</code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************************<div id="title">1359. Count All Valid Pickup and Delivery Options</div>
*************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你 <code>n</code> 笔订单，每笔订单都需要快递服务。</p>
<p>请你统计所有有效的 收件/配送 序列的数目，确保第 <code>i</code> 个物品的配送服务 <code>delivery(i)</code> 总是在其收件服务 <code>pickup(i)</code> 之后。</p>
<p>由于答案可能很大，请返回答案对 <code>10^9 + 7</code> 取余的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>1
<strong>解释：</strong>只有一种序列 (P1, D1)，物品 1 的配送服务（D1）在物品 1 的收件服务（P1）后。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>6
<strong>解释：</strong>所有可能的序列包括：
(P1,P2,D1,D2)，(P1,P2,D2,D1)，(P1,D1,P2,D2)，(P2,P1,D1,D2)，(P2,P1,D2,D1) 和 (P2,D2,P1,D1)。
(P1,D2,P2,D1) 是一个无效的序列，因为物品 2 的收件服务（P2）不应在物品 2 的配送服务（D2）之后。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>90
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 500</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">1363. Largest Multiple of Three</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>digits</code>，你可以通过按任意顺序连接其中某些数字来形成 <strong>3</strong> 的倍数，请你返回所能得到的最大的 3 的倍数。</p>
<p>由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。</p>
<p>如果无法得到答案，请返回一个空字符串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>digits = [8,1,9]
<strong>输出：</strong>"981"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>digits = [8,6,7,1,0]
<strong>输出：</strong>"8760"
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>digits = [1]
<strong>输出：</strong>""
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>digits = [0,0,0,0,0,0]
<strong>输出：</strong>"0"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= digits.length &lt;= 10^4</code></li>
<li><code>0 &lt;= digits[i] &lt;= 9</code></li>
<li>返回的结果不应包含不必要的前导零。</li>
</ul>
</div></div></div><br><br><hr><br>************************************************************<div id="title">1368. Minimum Cost to Make at Least One Valid Path in a Grid</div>
************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 m x n 的网格图 <code>grid</code> 。 <code>grid</code> 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 <code>grid[i][j]</code> 中的数字可能为以下几种情况：</p>
<ul>
<li><strong>1</strong> ，下一步往右走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i][j + 1]</code></li>
<li><strong>2</strong> ，下一步往左走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i][j - 1]</code></li>
<li><strong>3</strong> ，下一步往下走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i + 1][j]</code></li>
<li><strong>4</strong> ，下一步往上走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i - 1][j]</code></li>
</ul>
<p>注意网格图中可能会有 <strong>无效数字</strong> ，因为它们可能指向 <code>grid</code> 以外的区域。</p>
<p>一开始，你会从最左上角的格子 <code>(0,0)</code> 出发。我们定义一条 <strong>有效路径</strong> 为从格子 <code>(0,0)</code> 出发，每一步都顺着数字对应方向走，最终在最右下角的格子 <code>(m - 1, n - 1)</code> 结束的路径。有效路径 <strong>不需要是最短路径</strong> 。</p>
<p>你可以花费 <code>cost = 1</code> 的代价修改一个格子中的数字，但每个格子中的数字 <strong>只能修改一次</strong> 。</p>
<p>请你返回让网格图至少有一条有效路径的最小代价。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid1.png" style="height: 528px; width: 542px;"/></p>
<pre><strong>输入：</strong>grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
<strong>输出：</strong>3
<strong>解释：</strong>你将从点 (0, 0) 出发。
到达 (3, 3) 的路径为： (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) 花费代价 cost = 1 使方向向下 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) 花费代价 cost = 1 使方向向下 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) 花费代价 cost = 1 使方向向下 --&gt; (3, 3)
总花费为 cost = 3.
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid2.png" style="height: 408px; width: 419px;"/></p>
<pre><strong>输入：</strong>grid = [[1,1,3],[3,2,2],[1,1,4]]
<strong>输出：</strong>0
<strong>解释：</strong>不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid3.png" style="height: 302px; width: 314px;"/></p>
<pre><strong>输入：</strong>grid = [[1,2],[4,3]]
<strong>输出：</strong>1
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>grid = [[2,2,2],[2,2,2]]
<strong>输出：</strong>3
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>grid = [[4]]
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************<div id="title">1373. Maximum Sum BST in Binary Tree</div>
************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一棵以 <code>root</code> 为根的 <strong>二叉树</strong> ，请你返回 <strong>任意</strong> 二叉搜索子树的最大键值和。</p>
<p>二叉搜索树的定义如下：</p>
<ul>
<li>任意节点的左子树中的键值都 <strong>小于</strong> 此节点的键值。</li>
<li>任意节点的右子树中的键值都 <strong>大于</strong> 此节点的键值。</li>
<li>任意节点的左子树和右子树都是二叉搜索树。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_1_1709.png" style="height: 250px; width: 320px;"/></p>
<pre><strong>输入：</strong>root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
<strong>输出：</strong>20
<strong>解释：</strong>键值为 3 的子树是和最大的二叉搜索树。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_2_1709.png" style="height: 180px; width: 134px;"/></p>
<pre><strong>输入：</strong>root = [4,3,null,1,2]
<strong>输出：</strong>2
<strong>解释：</strong>键值为 2 的单节点子树是和最大的二叉搜索树。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>root = [-4,-2,-5]
<strong>输出：</strong>0
<strong>解释：</strong>所有节点键值都为负数，和最大的二叉搜索树为空。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>root = [2,1,3]
<strong>输出：</strong>6
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>root = [5,4,8,3,null,6,3]
<strong>输出：</strong>7
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li>每棵树有 <code>1</code> 到 <code>40000</code> 个节点。</li>
<li>每个节点的键值在 <code>[-4 * 10^4 , 4 * 10^4]</code> 之间。</li>
</ul>
</div></div></div><br><br><hr><br>***********************************<div id="title">1377. Frog Position After T Seconds</div>
***********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 <code>n</code>。青蛙从 <strong>顶点 1</strong> 开始起跳。规则如下：</p>
<ul>
<li>在一秒内，青蛙从它所在的当前顶点跳到另一个 <strong>未访问</strong> 过的顶点（如果它们直接相连）。</li>
<li>青蛙无法跳回已经访问过的顶点。</li>
<li>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</li>
<li>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</li>
</ul>
<p>无向树的边用数组 <code>edges</code> 描述，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> 意味着存在一条直接连通 <code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code> 两个顶点的边。</p>
<p>返回青蛙在 <em><code>t</code></em> 秒后位于目标顶点 <em><code>target</code> </em>上的概率。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/12/21/frog1.jpg"/></p>
<pre><strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4
<strong>输出：</strong>0.16666666666666666 
<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，第 <strong>1 秒</strong> 有 1/3 的概率跳到顶点 2 ，然后第 <strong>2 秒</strong> 有 1/2 的概率跳到顶点 4，因此青蛙在 2 秒后位于顶点 4 的概率是 1/3 * 1/2 = 1/6 = 0.16666666666666666 。 
</pre>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/12/21/frog2.jpg"/></p>
<pre><strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7
<strong>输出：</strong>0.3333333333333333
<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，有 1/3 = 0.3333333333333333 的概率能够 <strong>1 秒</strong> 后跳到顶点 7 。 
</pre>
<p> </p>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
<li><code>1 &lt;= t &lt;= 50</code></li>
<li><code>1 &lt;= target &lt;= n</code></li>
</ul>
</div></div></div><br><br><hr><br>***********************************<div id="title">1383. Maximum Performance of a Team</div>
***********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>公司有编号为 <code>1</code> 到 <code>n</code> 的 <code>n</code> 个工程师，给你两个数组 <code>speed</code> 和 <code>efficiency</code> ，其中 <code>speed[i]</code> 和 <code>efficiency[i]</code> 分别代表第 <code>i</code> 位工程师的速度和效率。请你返回由最多 <code>k</code> 个工程师组成的 <strong>​​​​​​最大团队表现值</strong> ，由于答案可能很大，请你返回结果对 <code>10^9 + 7</code> 取余后的结果。</p>
<p><strong>团队表现值</strong> 的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
<strong>输出：</strong>60
<strong>解释：</strong>
我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
<strong>输出：</strong>68
<strong>解释：
</strong>此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
<strong>输出：</strong>72
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>speed.length == n</code></li>
<li><code>efficiency.length == n</code></li>
<li><code>1 &lt;= speed[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= efficiency[i] &lt;= 10^8</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">1388. Pizza With 3n Slices</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：</p>
<ul>
<li>你挑选 <strong>任意</strong> 一块披萨。</li>
<li>Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。</li>
<li>Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。</li>
<li>重复上述过程直到没有披萨剩下。</li>
</ul>
<p>每一块披萨的大小按顺时针方向由循环数组 <code>slices</code> 表示。</p>
<p>请你返回你可以获得的披萨大小总和的最大值。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_3_1723.png" style="height: 240px; width: 475px;"/></p>
<pre><strong>输入：</strong>slices = [1,2,3,4,5,6]
<strong>输出：</strong>10
<strong>解释：</strong>选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_4_1723.png" style="height: 250px; width: 475px;"/></strong></p>
<pre><strong>输入：</strong>slices = [8,9,8,6,1,1]
<strong>输出：</strong>16
<strong>解释：</strong>两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= slices.length &lt;= 500</code></li>
<li><code>slices.length % 3 == 0</code></li>
<li><code>1 &lt;= slices[i] &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">1392. Longest Happy Prefix</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><strong>「快乐前缀」</strong> 是在原字符串中既是 <strong>非空</strong> 前缀也是后缀（不包括原字符串自身）的字符串。</p>
<p>给你一个字符串 <code>s</code>，请你返回它的 <strong>最长快乐前缀</strong>。如果不存在满足题意的前缀，则返回一个空字符串 <code>""</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "level"
<strong>输出：</strong>"l"
<strong>解释：</strong>不包括 s 自己，一共有 4 个前缀（"l", "le", "lev", "leve"）和 4 个后缀（"l", "el", "vel", "evel"）。最长的既是前缀也是后缀的字符串是 "l" 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "ababab"
<strong>输出：</strong>"abab"
<strong>解释：</strong>"abab" 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
<li><code>s</code> 只含有小写英文字母</li>
</ul>
</div></div></div><br><br><hr><br>***************************<div id="title">1397. Find All Good Strings</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个长度为 <code>n</code> 的字符串 <code>s1</code> 和 <code>s2</code> ，以及一个字符串 <code>evil</code> 。请你返回 <strong>好字符串 </strong>的数目。</p>
<p><strong>好字符串</strong> 的定义为：它的长度为 <code>n</code> ，字典序大于等于 <code>s1</code> ，字典序小于等于 <code>s2</code> ，且不包含 <code>evil</code> 为子字符串。</p>
<p>由于答案可能很大，请你返回答案对 10^9 + 7 取余的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 2, s1 = "aa", s2 = "da", evil = "b"
<strong>输出：</strong>51 
<strong>解释：</strong>总共有 25 个以 'a' 开头的好字符串："aa"，"ac"，"ad"，...，"az"。还有 25 个以 'c' 开头的好字符串："ca"，"cc"，"cd"，...，"cz"。最后，还有一个以 'd' 开头的好字符串："da"。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 8, s1 = "leetcode", s2 = "leetgoes", evil = "leet"
<strong>输出：</strong>0 
<strong>解释：</strong>所有字典序大于等于 s1 且小于等于 s2 的字符串都以 evil 字符串 "leet" 开头。所以没有好字符串。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 2, s1 = "gx", s2 = "gz", evil = "x"
<strong>输出：</strong>2
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>s1.length == n</code></li>
<li><code>s2.length == n</code></li>
<li><code>s1 &lt;= s2</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= evil.length &lt;= 50</code></li>
<li>所有字符串都只包含小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*********************<div id="title">1402. Reducing Dishes</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个厨师收集了他 <code>n</code> 道菜的满意程度 <code>satisfaction</code> ，这个厨师做出每道菜的时间都是 1 单位时间。</p>
<p>一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是 <code>time[i]</code>*<code>satisfaction[i]</code> 。</p>
<p>请你返回做完所有菜 「喜爱时间」总和的最大值为多少。</p>
<p>你可以按 <strong>任意</strong> 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>satisfaction = [-1,-8,0,5,-9]
<strong>输出：</strong>14
<strong>解释：</strong>去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>satisfaction = [4,3,2]
<strong>输出：</strong>20
<strong>解释：</strong>按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 = 20)
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>satisfaction = [-1,-4,-5]
<strong>输出：</strong>0
<strong>解释：</strong>大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == satisfaction.length</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>-1000 &lt;= satisfaction[i] &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>********************<div id="title">1406. Stone Game III</div>
********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 <code>stoneValue</code> 给出。</p>
<p>Alice 和 Bob 轮流取石子，<strong>Alice</strong> 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 <strong>1、2 或 3 堆石子</strong> 。比赛一直持续到所有石头都被拿走。</p>
<p>每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 <strong>0</strong> 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。</p>
<p>假设 Alice 和 Bob 都采取 <strong>最优策略</strong> 。如果 Alice 赢了就返回 <em>"Alice"</em> <em>，</em>Bob 赢了就返回<em> "Bob"，</em>平局（分数相同）返回 <em>"Tie"</em> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>values = [1,2,3,7]
<strong>输出：</strong>"Bob"
<strong>解释：</strong>Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>values = [1,2,3,-9]
<strong>输出：</strong>"Alice"
<strong>解释：</strong>Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。
如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。
如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。
注意，他们都应该采取 <strong>最优策略 </strong>，所以在这里 Alice 将选择能够使她获胜的方案。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>values = [1,2,3,6]
<strong>输出：</strong>"Tie"
<strong>解释：</strong>Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>values = [1,2,3,-1,-2,-3,7]
<strong>输出：</strong>"Alice"
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>values = [-1,-2,-3]
<strong>输出：</strong>"Tie"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= values.length &lt;= 50000</code></li>
<li><code>-1000 &lt;= values[i] &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">1411. Number of Ways to Paint N × 3 Grid</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你有一个 <code>n x 3</code> 的网格图 <code>grid</code> ，你需要用 <strong>红，黄，绿</strong> 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。</p>
<p>给你网格图的行数 <code>n</code> 。</p>
<p>请你返回给 <code>grid</code> 涂色的方案数。由于答案可能会非常大，请你返回答案对 <code>10^9 + 7</code> 取余的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>12
<strong>解释：</strong>总共有 12 种可行的方法：
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/12/e1.png" style="height: 289px; width: 450px;"/>
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>54
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>246
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>n = 7
<strong>输出：</strong>106494
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>n = 5000
<strong>输出：</strong>30228214
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == grid.length</code></li>
<li><code>grid[i].length == 3</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
</ul>
</div></div></div><br><br><hr><br>***********************<div id="title">1416. Restore The Array</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 <code>[1, k]</code> 之间，且数组中的数字都没有前导 0 。</p>
<p>给你字符串 <code>s</code> 和整数 <code>k</code> 。可能会有多种不同的数组恢复结果。</p>
<p>按照上述程序，请你返回所有可能输出字符串 <code>s</code> 的数组方案数。</p>
<p>由于数组方案数可能会很大，请你返回它对 <code>10^9 + 7</code> <strong>取余</strong> 后的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "1000", k = 10000
<strong>输出：</strong>1
<strong>解释：</strong>唯一一种可能的数组方案是 [1000]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "1000", k = 10
<strong>输出：</strong>0
<strong>解释：</strong>不存在任何数组方案满足所有整数都 &gt;= 1 且 &lt;= 10 同时输出结果为 s 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "1317", k = 2000
<strong>输出：</strong>8
<strong>解释：</strong>可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>s = "2020", k = 30
<strong>输出：</strong>1
<strong>解释：</strong>唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 &gt; 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>s = "1234567890", k = 90
<strong>输出：</strong>34
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code>.</li>
<li><code>s</code> 只包含数字且不包含前导 0 。</li>
<li><code>1 &lt;= k &lt;= 10^9</code>.</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************************************<div id="title">1420. Build Array Where You Can Find The Maximum Exactly K Comparisons</div>
**********************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你三个整数 <code>n</code>、<code>m</code> 和 <code>k</code> 。下图描述的算法用于找出正整数数组中最大的元素。</p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/19/e.png" style="height: 372px; width: 424px;"/></p>
<p>请你生成一个具有下述属性的数组 <code>arr</code> ：</p>
<ul>
<li><code>arr</code> 中有 <code>n</code> 个整数。</li>
<li><code>1 &lt;= arr[i] &lt;= m</code> 其中 <code>(0 &lt;= i &lt; n)</code> 。</li>
<li>将上面提到的算法应用于 <code>arr</code> ，<code>search_cost</code> 的值等于 <code>k</code> 。</li>
</ul>
<p>返回上述条件下生成数组 <code>arr</code> 的 <strong>方法数</strong> ，由于答案可能会很大，所以 <strong>必须</strong> 对 <code>10^9 + 7</code> 取余。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 2, m = 3, k = 1
<strong>输出：</strong>6
<strong>解释：</strong>可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 5, m = 2, k = 3
<strong>输出：</strong>0
<strong>解释：</strong>没有数组可以满足上述条件
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 9, m = 1, k = 1
<strong>输出：</strong>1
<strong>解释：</strong>可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>n = 50, m = 100, k = 25
<strong>输出：</strong>34549172
<strong>解释：</strong>不要忘了对 1000000007 取余
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>n = 37, m = 17, k = 7
<strong>输出：</strong>418930126
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>1 &lt;= m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= n</code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1425. Constrained Subsequence Sum</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <strong>非空</strong> 子序列元素和的最大值，子序列需要满足：子序列中每两个 <strong>相邻</strong> 的整数 <code>nums[i]</code> 和 <code>nums[j]</code> ，它们在原数组中的下标 <code>i</code> 和 <code>j</code> 满足 <code>i &lt; j</code> 且 <code>j - i &lt;= k</code> 。</p>
<p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [10,2,-10,5,20], k = 2
<strong>输出：</strong>37
<strong>解释：</strong>子序列为 [10, 2, 5, 20] 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [-1,-2,-3], k = 1
<strong>输出：</strong>-1
<strong>解释：</strong>子序列必须是非空的，所以我们选择最大的数字。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [10,-2,-10,-5,20], k = 2
<strong>输出：</strong>23
<strong>解释：</strong>子序列为 [10, -2, -5, 20] 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************************************<div id="title">1434. Number of Ways to Wear Different Hats to Each Other</div>
*********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>总共有 <code>n</code> 个人和 <code>40</code> 种不同的帽子，帽子编号从 <code>1</code> 到 <code>40</code> 。</p>
<p>给你一个整数列表的列表 <code>hats</code> ，其中 <code>hats[i]</code> 是第 <code>i</code> 个人所有喜欢帽子的列表。</p>
<p>请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数。</p>
<p>由于答案可能很大，请返回它对 <code>10^9 + 7</code> 取余后的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>hats = [[3,4],[4,5],[5]]
<strong>输出：</strong>1
<strong>解释：</strong>给定条件下只有一种方法选择帽子。
第一个人选择帽子 3，第二个人选择帽子 4，最后一个人选择帽子 5。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>hats = [[3,5,1],[3,5]]
<strong>输出：</strong>4
<strong>解释：</strong>总共有 4 种安排帽子的方法：
(3,5)，(5,3)，(1,3) 和 (1,5)
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
<strong>输出：</strong>24
<strong>解释：</strong>每个人都可以从编号为 1 到 4 的帽子中选。
(1,2,3,4) 4 个帽子的排列方案数为 24 。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]
<strong>输出：</strong>111
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == hats.length</code></li>
<li><code>1 &lt;= n &lt;= 10</code></li>
<li><code>1 &lt;= hats[i].length &lt;= 40</code></li>
<li><code>1 &lt;= hats[i][j] &lt;= 40</code></li>
<li><code>hats[i]</code> 包含一个数字互不相同的整数列表。</li>
</ul>
</div></div></div><br><br><hr><br>************************************************************<div id="title">1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows</div>
************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m * n</code> 的矩阵 <code>mat</code>，以及一个整数 <code>k</code> ，矩阵中的每一行都以非递减的顺序排列。</p>
<p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 <strong>最小</strong> 数组和。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>mat = [[1,3,11],[2,4,6]], k = 5
<strong>输出：</strong>7
<strong>解释：</strong>从每一行中选出一个元素，前 k 个和最小的数组分别是：
[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。  </pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>mat = [[1,3,11],[2,4,6]], k = 9
<strong>输出：</strong>17
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
<strong>输出：</strong>9
<strong>解释：</strong>从每一行中选出一个元素，前 k 个和最小的数组分别是：
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>mat = [[1,1,10],[2,2,9]], k = 7
<strong>输出：</strong>12
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat.length[i]</code></li>
<li><code>1 &lt;= m, n &lt;= 40</code></li>
<li><code>1 &lt;= k &lt;= min(200, n ^ m)</code></li>
<li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li>
<li><code>mat[i]</code> 是一个非递减数组</li>
</ul>
</div></div></div><br><br><hr><br>***************************************<div id="title">1444. Number of Ways of Cutting a Pizza</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>rows x cols</code> 大小的矩形披萨和一个整数 <code>k</code> ，矩形包含两种字符： <code>'A'</code> （表示苹果）和 <code>'.'</code> （表示空白格子）。你需要切披萨 <code>k-1</code> 次，得到 <code>k</code> 块披萨并送给别人。</p>
<p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p>
<p>请你返回确保每一块披萨包含 <strong>至少</strong> 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/ways_to_cut_apple_1.png" style="height: 378px; width: 500px;"/></strong></p>
<pre><strong>输入：</strong>pizza = ["A..","AAA","..."], k = 3
<strong>输出：</strong>3 
<strong>解释：</strong>上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>pizza = ["A..","AA.","..."], k = 3
<strong>输出：</strong>1
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>pizza = ["A..","A..","..."], k = 1
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= rows, cols &lt;= 50</code></li>
<li><code>rows == pizza.length</code></li>
<li><code>cols == pizza[i].length</code></li>
<li><code>1 &lt;= k &lt;= 10</code></li>
<li><code>pizza</code> 只包含字符 <code>'A'</code> 和 <code>'.'</code> 。</li>
</ul>
</div></div></div><br><br><hr><br>************************************************************<div id="title">1449. Form Largest Integer With Digits That Add up to Target</div>
************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code> 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p>
<ul>
<li>给当前结果添加一个数位（<code>i + 1</code>）的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。</li>
<li>总成本必须恰好等于 <code>target</code> 。</li>
<li>添加的数位中没有数字 0 。</li>
</ul>
<p>由于答案可能会很大，请你以字符串形式返回。</p>
<p>如果按照上述要求无法得到任何整数，请你返回 "0" 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>cost = [4,3,2,5,6,7,2,5,5], target = 9
<strong>输出：</strong>"7772"
<strong>解释：</strong>添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 "7772" 的代价为 2*3+ 3*1 = 9 。 "977" 也是满足要求的数字，但 "7772" 是较大的数字。
<strong> 数字     成本</strong>
  1  -&gt;   4
  2  -&gt;   3
  3  -&gt;   2
  4  -&gt;   5
  5  -&gt;   6
  6  -&gt;   7
  7  -&gt;   2
  8  -&gt;   5
  9  -&gt;   5
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>cost = [7,6,5,5,5,6,8,7,8], target = 12
<strong>输出：</strong>"85"
<strong>解释：</strong>添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。"85" 的成本为 7 + 5 = 12 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>cost = [2,4,6,2,4,6,4,4,4], target = 5
<strong>输出：</strong>"0"
<strong>解释：</strong>总成本是 target 的条件下，无法生成任何整数。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>cost = [6,10,15,40,40,40,40,40,40], target = 47
<strong>输出：</strong>"32211"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>cost.length == 9</code></li>
<li><code>1 &lt;= cost[i] &lt;= 5000</code></li>
<li><code>1 &lt;= target &lt;= 5000</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************************************<div id="title">1453. Maximum Number of Darts Inside of a Circular Dartboard</div>
************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>墙壁上挂着一个圆形的飞镖靶。现在请你蒙着眼睛向靶上投掷飞镖。</p>
<p>投掷到墙上的飞镖用二维平面上的点坐标数组表示。飞镖靶的半径为 <code>r</code> 。</p>
<p>请返回能够落在 <strong>任意</strong> 半径为 <code>r</code> 的圆形靶内或靶上的最大飞镖数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/sample_1_1806.png" style="height: 159px; width: 186px;"/></p>
<pre><strong>输入：</strong>points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2
<strong>输出：</strong>4
<strong>解释：</strong>如果圆形的飞镖靶的圆心为 (0,0) ，半径为 2 ，所有的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 4 。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/sample_2_1806.png" style="height: 183px; width: 224px;"/></strong></p>
<pre><strong>输入：</strong>points = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5
<strong>输出：</strong>5
<strong>解释：</strong>如果圆形的飞镖靶的圆心为 (0,4) ，半径为 5 ，则除了 (7,8) 之外的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 5 。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>points = [[-2,0],[2,0],[0,2],[0,-2]], r = 1
<strong>输出：</strong>1
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>points = [[1,2],[3,5],[1,-1],[2,3],[4,1],[1,3]], r = 2
<strong>输出：</strong>4
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= points.length &lt;= 100</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-10^4 &lt;= points[i][0], points[i][1] &lt;= 10^4</code></li>
<li><code>1 &lt;= r &lt;= 5000</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">1458. Max Dot Product of Two Subsequences</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个数组 <code>nums1</code> 和 <code>nums2</code> 。</p>
<p>请你返回 <code>nums1</code> 和 <code>nums2</code> 中两个长度相同的 <strong>非空</strong> 子序列的最大点积。</p>
<p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，<code>[2,3,5]</code> 是 <code>[1,2,3,4,5]</code> 的一个子序列而 <code>[1,5,3]</code> 不是。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums1 = [2,1,-2,5], nums2 = [3,0,-6]
<strong>输出：</strong>18
<strong>解释：</strong>从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。
它们的点积为 (2*3 + (-2)*(-6)) = 18 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums1 = [3,-2], nums2 = [2,-6,7]
<strong>输出：</strong>21
<strong>解释：</strong>从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。
它们的点积为 (3*7) = 21 。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums1 = [-1,-1], nums2 = [1,1]
<strong>输出：</strong>-1
<strong>解释：</strong>从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。
它们的点积为 -1 。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>
<li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>
</ul>
<p> </p>
<p><strong>点积：</strong></p>
<pre>定义 <code><strong>a</strong> = [<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>,…, <em>a</em><sub><em>n</em></sub>]</code> 和<strong> <code>b</code></strong><code> = [<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>,…, <em>b</em><sub><em>n</em></sub>]</code> 的点积为：

<img alt="\mathbf{a}\cdot \mathbf{b} = \sum_{i=1}^n a_ib_i = a_1b_1 + a_2b_2 + \cdots + a_nb_n" class="tex" src="https://pic.leetcode-cn.com/1666164309-PBJMQp-image.png"/>

这里的 <strong>Σ</strong> 指示总和符号。
</pre>
</div></div></div><br><br><hr><br>**********************<div id="title">1463. Cherry Pickup II</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>rows x cols</code> 的矩阵 <code>grid</code> 来表示一块樱桃地。 <code>grid</code> 中每个格子的数字表示你能获得的樱桃数目。</p>
<p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 <code>(0,0)</code> 出发，机器人 2 从右上角格子 <code>(0, cols-1)</code> 出发。</p>
<p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p>
<ul>
<li>从格子 <code>(i,j)</code> 出发，机器人可以移动到格子 <code>(i+1, j-1)</code>，<code>(i+1, j)</code> 或者 <code>(i+1, j+1)</code> 。</li>
<li>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。</li>
<li>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。</li>
<li>两个机器人在任意时刻都不能移动到 <code>grid</code> 外面。</li>
<li>两个机器人最后都要到达 <code>grid</code> 最底下一行。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1802.png" style="height: 182px; width: 139px;"/></strong></p>
<pre><strong>输入：</strong>grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
<strong>输出：</strong>24
<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。
机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。
机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。
樱桃总数为： 12 + 12 = 24 。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1802.png" style="height: 257px; width: 284px;"/></strong></p>
<pre><strong>输入：</strong>grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
<strong>输出：</strong>28
<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。
机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。
机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。
樱桃总数为： 17 + 11 = 28 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]
<strong>输出：</strong>22
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>grid = [[1,1],[1,1]]
<strong>输出：</strong>4
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>rows == grid.length</code></li>
<li><code>cols == grid[i].length</code></li>
<li><code>2 &lt;= rows, cols &lt;= 70</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 100 </code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************************************************<div id="title">1467. Probability of a Two Boxes Having The Same Number of Distinct Balls</div>
*************************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>桌面上有 <code>2n</code> 个颜色不完全相同的球，球上的颜色共有 <code>k</code> 种。给你一个大小为 <code>k</code> 的整数数组 <code>balls</code> ，其中 <code>balls[i]</code> 是颜色为 <code>i</code> 的球的数量。</p>
<p>所有的球都已经 <strong>随机打乱顺序</strong> ，前 <code>n</code> 个球放入第一个盒子，后 <code>n</code> 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。</p>
<p><strong>注意：</strong>这两个盒子是不同的。例如，两个球颜色分别为 <code>a</code> 和 <code>b</code>，盒子分别为 <code>[]</code> 和 <code>()</code>，那么 <code>[a] (b)</code> 和 <code>[b] (a)</code> 这两种分配方式是不同的（请认真阅读示例的解释部分）。</p>
<p>请返回「两个盒子中球的颜色数相同」的情况的概率。答案与真实值误差在 <code>10^-5</code> 以内，则被视为正确答案</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>balls = [1,1]
<strong>输出：</strong>1.00000
<strong>解释：</strong>球平均分配的方式只有两种：
- 颜色为 1 的球放入第一个盒子，颜色为 2 的球放入第二个盒子
- 颜色为 2 的球放入第一个盒子，颜色为 1 的球放入第二个盒子
这两种分配，两个盒子中球的颜色数都相同。所以概率为 2/2 = 1 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>balls = [2,1,1]
<strong>输出：</strong>0.66667
<strong>解释：</strong>球的列表为 [1, 1, 2, 3]
随机打乱，得到 12 种等概率的不同打乱方案，每种方案概率为 1/12 ：
[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]
然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。
这 12 种可能的随机打乱方式中的 8 种满足「两个盒子中球的颜色数相同」。
概率 = 8/12 = 0.66667
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>balls = [1,2,1,2]
<strong>输出：</strong>0.60000
<strong>解释：</strong>球的列表为 [1, 2, 2, 3, 4, 4]。要想显示所有 180 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 108 种情况是比较容易的。
概率 = 108 / 180 = 0.6 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= balls.length &lt;= 8</code></li>
<li><code>1 &lt;= balls[i] &lt;= 6</code></li>
<li><code>sum(balls)</code> 是偶数</li>
</ul>
</div></div></div><br><br><hr><br>*********************<div id="title">1473. Paint House III</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在一个小城市里，有 <code>m</code> 个房子排成一排，你需要给每个房子涂上 <code>n</code> 种颜色之一（颜色编号为 <code>1</code> 到 <code>n</code> ）。有的房子去年夏天已经涂过颜色了，所以这些房子不可以被重新涂色。</p>
<p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 <code>houses = [1,2,2,3,3,2,1,1]</code> ，它包含 5 个街区 <code> [{1}, {2,2}, {3,3}, {2}, {1,1}]</code> 。）</p>
<p>给你一个数组 <code>houses</code> ，一个 <code>m * n</code> 的矩阵 <code>cost</code> 和一个整数 <code>target</code> ，其中：</p>
<ul>
<li><code>houses[i]</code>：是第 <code>i</code> 个房子的颜色，<strong>0</strong> 表示这个房子还没有被涂色。</li>
<li><code>cost[i][j]</code>：是将第 <code>i</code> 个房子涂成颜色 <code>j+1</code> 的花费。</li>
</ul>
<p>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 <code>target</code> 个街区。如果没有可用的涂色方案，请返回 <strong>-1</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
<strong>输出：</strong>9
<strong>解释：</strong>房子涂色方案为 [1,2,2,1,1]
此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。
涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
<strong>输出：</strong>11
<strong>解释：</strong>有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]
此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。
给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5
<strong>输出：</strong>5
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
<strong>输出：</strong>-1
<strong>解释：</strong>房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == houses.length == cost.length</code></li>
<li><code>n == cost[i].length</code></li>
<li><code>1 &lt;= m &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= target &lt;= m</code></li>
<li><code>0 &lt;= houses[i] &lt;= n</code></li>
<li><code>1 &lt;= cost[i][j] &lt;= 10^4</code></li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">1478. Allocate Mailboxes</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个房屋数组<code>houses</code> 和一个整数 <code>k</code> ，其中 <code>houses[i]</code> 是第 <code>i</code> 栋房子在一条街上的位置，现需要在这条街上安排 <code>k</code> 个邮筒。</p>
<p>请你返回每栋房子与离它最近的邮筒之间的距离的 <strong>最小 </strong>总和。</p>
<p>答案保证在 32 位有符号整数范围以内。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/13/sample_11_1816.png" style="height: 154px; width: 454px;"/></p>
<pre><strong>输入：</strong>houses = [1,4,8,10,20], k = 3
<strong>输出：</strong>5
<strong>解释：</strong>将邮筒分别安放在位置 3， 9 和 20 处。
每个房子到最近邮筒的距离和为 |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/13/sample_2_1816.png" style="height: 154px; width: 433px;"/></strong></p>
<pre><strong>输入：</strong>houses = [2,3,5,12,18], k = 2
<strong>输出：</strong>9
<strong>解释：</strong>将邮筒分别安放在位置 3 和 14 处。
每个房子到最近邮筒距离和为 |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>houses = [7,4,6,1], k = 1
<strong>输出：</strong>8
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>houses = [3,6,14,10], k = 4
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == houses.length</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= houses[i] &lt;= 10^4</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
<li>数组 <code>houses</code> 中的整数互不相同。</li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1483. Kth Ancestor of a Tree Node</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一棵树，树上有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n-1</code> 编号。树以父节点数组的形式给出，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点。树的根节点是编号为 <code>0</code> 的节点。</p>
<p>树节点的第 <em><code>k</code> </em>个祖先节点是从该节点到根节点路径上的第 <code>k</code> 个节点。</p>
<p>实现 <code>TreeAncestor</code> 类：</p>
<ul>
<li><code>TreeAncestor（int n， int[] parent）</code> 对树和父数组中的节点数初始化对象。</li>
<li><code>getKthAncestor</code><code>(int node, int k)</code> 返回节点 <code>node</code> 的第 <code>k</code> 个祖先节点。如果不存在这样的祖先节点，返回 <code>-1</code> 。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/14/1528_ex1.png"/></strong></p>
<pre><strong>输入：</strong>
["TreeAncestor","getKthAncestor","getKthAncestor","getKthAncestor"]
[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]

<strong>输出：</strong>
[null,1,0,-1]

<strong>解释：</strong>
TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);

treeAncestor.getKthAncestor(3, 1);  // 返回 1 ，它是 3 的父节点
treeAncestor.getKthAncestor(5, 2);  // 返回 0 ，它是 5 的祖父节点
treeAncestor.getKthAncestor(6, 3);  // 返回 -1 因为不存在满足要求的祖先节点
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>parent[0] == -1</code> 表示编号为 <code>0</code> 的节点是根节点。</li>
<li>对于所有的 <code>0 &lt; i &lt; n</code> ，<code>0 &lt;= parent[i] &lt; n</code> 总成立</li>
<li><code>0 &lt;= node &lt; n</code></li>
<li>至多查询 <code>5 * 10<sup>4</sup></code> 次</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************************************<div id="title">1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree</div>
**********************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>n</code> 个点的带权无向连通图，节点编号为 <code>0</code> 到 <code>n-1</code> ，同时还有一个数组 <code>edges</code> ，其中 <code>edges[i] = [from</code><code><sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> 表示在 <code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code> 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p>
<p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p>
<p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex1.png" style="height: 262px; width: 259px;"/></p>
<pre><strong>输入：</strong>n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
<strong>输出：</strong>[[0,1],[2,3,4,5]]
<strong>解释：</strong>上图描述了给定图。
下图是所有的最小生成树。
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/msts.png" style="height: 553px; width: 540px;"/>
注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。
边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。
</pre>
<p><strong>示例 2 ：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex2.png" style="height: 253px; width: 247px;"/></p>
<pre><strong>输入：</strong>n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
<strong>输出：</strong>[[],[0,1,2,3]]
<strong>解释：</strong>可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li>
<li><code>edges[i].length == 3</code></li>
<li><code>0 &lt;= from<sub>i</sub> &lt; to<sub>i</sub> &lt; n</code></li>
<li><code>1 &lt;= weight<sub>i</sub> &lt;= 1000</code></li>
<li>所有 <code>(from<sub>i</sub>, to<sub>i</sub>)</code> 数对都是互不相同的。</li>
</ul>
</div></div></div><br><br><hr><br>*************************<div id="title">1494. Parallel Courses II</div>
*************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数 <code>n</code> 表示某所大学里课程的数目，编号为 <code>1</code> 到 <code>n</code> ，数组 <code>relations</code> 中， <code>relations[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>  表示一个先修课的关系，也就是课程 <code>x<sub>i</sub></code> 必须在课程 <code>y<sub>i</sub></code><sub> </sub>之前上。同时你还有一个整数 <code>k</code> 。</p>
<p>在一个学期中，你 <strong>最多</strong> 可以同时上 <code>k</code> 门课，前提是这些课的先修课在之前的学期里已经上过了。</p>
<p>请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_1.png" style="height: 164px; width: 300px;"/></strong></p>
<pre><strong>输入：</strong>n = 4, relations = [[2,1],[3,1],[1,4]], k = 2
<strong>输出：</strong>3 
<strong>解释：</strong>上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_2.png" style="height: 234px; width: 300px;"/></strong></p>
<pre><strong>输入：</strong>n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2
<strong>输出：</strong>4 
<strong>解释：</strong>上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 11, relations = [], k = 2
<strong>输出：</strong>6
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 15</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
<li><code>0 &lt;= relations.length &lt;= n * (n-1) / 2</code></li>
<li><code>relations[i].length == 2</code></li>
<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n</code></li>
<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
<li>所有先修关系都是不同的，也就是说 <code>relations[i] != relations[j]</code> 。</li>
<li>题目输入的图是个有向无环图。</li>
</ul>
</div></div></div><br><br><hr><br>***************************<div id="title">1499. Max Value of Equation</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个数组 <code>points</code> 和一个整数 <code>k</code> 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，并且在 <code>1 &lt;= i &lt; j &lt;= points.length</code> 的前提下， <code>x<sub>i</sub> &lt; x<sub>j</sub></code> 总成立。</p>
<p>请你找出<em> </em><code>y<sub>i</sub> + y<sub>j</sub> + |x<sub>i</sub> - x<sub>j</sub>|</code> 的 <strong>最大值</strong>，其中 <code>|x<sub>i</sub> - x<sub>j</sub>| &lt;= k</code> 且 <code>1 &lt;= i &lt; j &lt;= points.length</code>。</p>
<p>题目测试数据保证至少存在一对能够满足 <code>|x<sub>i</sub> - x<sub>j</sub>| &lt;= k</code> 的点。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>points = [[1,3],[2,0],[5,10],[6,-10]], k = 1
<strong>输出：</strong>4
<strong>解释：</strong>前两个点满足 |x<sub>i</sub> - x<sub>j</sub>| &lt;= 1 ，代入方程计算，则得到值 3 + 0 + |1 - 2| = 4 。第三个和第四个点也满足条件，得到值 10 + -10 + |5 - 6| = 1 。
没有其他满足条件的点，所以返回 4 和 1 中最大的那个。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>points = [[0,0],[3,0],[9,2]], k = 3
<strong>输出：</strong>3
<strong>解释：</strong>只有前两个点满足 |x<sub>i</sub> - x<sub>j</sub>| &lt;= 3 ，代入方程后得到值 0 + 0 + |0 - 3| = 3 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= points.length &lt;= 10^5</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-10^8 &lt;= points[i][0], points[i][1] &lt;= 10^8</code></li>
<li><code>0 &lt;= k &lt;= 2 * 10^8</code></li>
<li>对于所有的<code>1 &lt;= i &lt; j &lt;= points.length</code> ，<code>points[i][0] &lt; points[j][0]</code> 都成立。也就是说，<code>x<sub>i</sub></code> 是严格递增的。</li>
</ul>
</div></div></div><br><br><hr><br>***********************************************************************<div id="title">1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits</div>
***********************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>num</code> 和一个整数 <code>k</code> 。其中，<code>num</code> 表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 <strong>数位</strong> 。</p>
<p>你可以交换这个整数相邻数位的数字 <strong>最多</strong> <code>k</code> 次。</p>
<p>请你返回你能得到的最小整数，并以字符串形式返回。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2020/06/17/q4_1.jpg" style="height:40px; width:500px"/></p>
<pre><strong>输入：</strong>num = "4321", k = 4
<strong>输出：</strong>"1342"
<strong>解释：</strong>4321 通过 4 次交换相邻数位得到最小整数的步骤如上图所示。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>num = "100", k = 1
<strong>输出：</strong>"010"
<strong>解释：</strong>输出可以包含前导 0 ，但输入保证不会有前导 0 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>num = "36789", k = 1000
<strong>输出：</strong>"36789"
<strong>解释：</strong>不需要做任何交换。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>num = "22", k = 22
<strong>输出：</strong>"22"
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>num = "9438957234785635408", k = 23
<strong>输出：</strong>"0345989723478563548"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num.length &lt;= 30000</code></li>
<li><code>num</code> 只包含 <strong>数字</strong> 且不含有<strong> 前导 0 </strong>。</li>
<li><code>1 &lt;= k &lt;= 10^9</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************<div id="title">1510. Stone Game IV</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。</p>
<p>一开始，有 <code>n</code> 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 <strong>任意</strong> 非零 <strong>平方数</strong> 个石子。</p>
<p>如果石子堆里没有石子了，则无法操作的玩家输掉游戏。</p>
<p>给你正整数 <code>n</code> ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>true
<strong>解释：</strong>Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>false
<strong>解释：</strong>Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -&gt; 1 -&gt; 0）。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 4
<strong>输出：</strong>true
<strong>解释：</strong>n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -&gt; 0）。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>n = 7
<strong>输出：</strong>false
<strong>解释：</strong>当 Bob 采取最优策略时，Alice 无法赢得比赛。
如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0）。
如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 6 -&gt; 2 -&gt; 1 -&gt; 0）。</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>n = 17
<strong>输出：</strong>false
<strong>解释：</strong>如果 Bob 采取最优策略，Alice 无法赢得胜利。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">1515. Best Position for a Service Centre</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 <strong>到所有客户的欧几里得距离的总和最小</strong> 。</p>
<p>给你一个数组 <code>positions</code> ，其中 <code>positions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示第 <code>i</code> 个客户在二维地图上的位置，返回到所有客户的 <strong>欧几里得距离的最小总和 。</strong></p>
<p>换句话说，请你为服务中心选址，该位置的坐标 <code>[x<sub>centre</sub>, y<sub>centre</sub>]</code> 需要使下面的公式取到最小值：</p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_edited.jpg"/></p>
<p>与真实值误差在 <code>10<sup>-5</sup></code>之内的答案将被视作正确答案。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e1.jpg"/></p>
<pre><strong>输入：</strong>positions = [[0,1],[1,0],[1,2],[2,1]]
<strong>输出：</strong>4.00000
<strong>解释：</strong>如图所示，你可以选 [x<sub>centre</sub>, y<sub>centre</sub>] = [1, 1] 作为新中心的位置，这样一来到每个客户的距离就都是 1，所有距离之和为 4 ，这也是可以找到的最小值。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e3.jpg"/></p>
<pre><strong>输入：</strong>positions = [[1,1],[3,3]]
<strong>输出：</strong>2.82843
<strong>解释：</strong>欧几里得距离可能的最小总和为 sqrt(2) + sqrt(2) = 2.82843
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= positions.length &lt;= 50</code></li>
<li><code>positions[i].length == 2</code></li>
<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************************<div id="title">1520. Maximum Number of Non-Overlapping Substrings</div>
**************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个只包含小写字母的字符串 <code>s</code> ，你需要找到 <code>s</code> 中最多数目的非空子字符串，满足如下条件：</p>
<ol>
<li>这些字符串之间互不重叠，也就是说对于任意两个子字符串 <code>s[i..j]</code> 和 <code>s[x..y]</code> ，要么 <code>j &lt; x</code> 要么 <code>i &gt; y</code> 。</li>
<li>如果一个子字符串包含字符 <code>char</code> ，那么 <code>s</code> 中所有 <code>char</code> 字符都应该在这个子字符串中。</li>
</ol>
<p>请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。</p>
<p>请注意，你可以以 <strong>任意</strong> 顺序返回最优解的子字符串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "adefaddaccc"
<strong>输出：</strong>["e","f","ccc"]
<strong>解释：</strong>下面为所有满足第二个条件的子字符串：
[
  "adefaddaccc"
  "adefadda",
  "ef",
  "e",
  "f",
  "ccc",
]
如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 1 。如果我们选择 "adefadda" ，剩下子字符串中我们只可以选择 "ccc" ，它是唯一不重叠的子字符串，所以答案为 2 。同时我们可以发现，选择 "ef" 不是最优的，因为它可以被拆分成 2 个子字符串。所以最优解是选择 ["e","f","ccc"] ，答案为 3 。不存在别的相同数目子字符串解。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "abbaccd"
<strong>输出：</strong>["d","bb","cc"]
<strong>解释：</strong>注意到解 ["d","abba","cc"] 答案也为 3 ，但它不是最优解，因为它的总长度更长。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s</code> 只包含小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*************************************************************<div id="title">1521. Find a Value of a Mysterious Function Closest to Target</div>
*************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/change.png" style="height: 312px; width: 635px;"/></p>
<p>Winston 构造了一个如上所示的函数 <code>func</code> 。他有一个整数数组 <code>arr</code> 和一个整数 <code>target</code> ，他想找到让 <code>|func(arr, l, r) - target|</code> 最小的 <code>l</code> 和 <code>r</code> 。</p>
<p>请你返回 <code>|func(arr, l, r) - target|</code> 的最小值。</p>
<p>请注意， <code>func</code> 的输入参数 <code>l</code> 和 <code>r</code> 需要满足 <code>0 &lt;= l, r &lt; arr.length</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>arr = [9,12,3,7,15], target = 5
<strong>输出：</strong>2
<strong>解释：</strong>所有可能的 [l,r] 数对包括 [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]]， Winston 得到的相应结果为 [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0] 。最接近 5 的值是 7 和 3，所以最小差值为 2 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>arr = [1000000,1000000,1000000], target = 1
<strong>输出：</strong>999999
<strong>解释：</strong>Winston 输入函数的所有可能 [l,r] 数对得到的函数值都为 1000000 ，所以最小差值为 999999 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>arr = [1,2,4,8,16], target = 0
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>1 &lt;= arr[i] &lt;= 10^6</code></li>
<li><code>0 &lt;= target &lt;= 10^7</code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************************************************<div id="title">1526. Minimum Number of Increments on Subarrays to Form a Target Array</div>
**********************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>target</code> 和一个数组 <code>initial</code> ，<code>initial</code> 数组与 <code>target</code>  数组有同样的维度，且一开始全部为 0 。</p>
<p>请你返回从 <code>initial</code> 得到  <code>target</code> 的最少操作次数，每次操作需遵循以下规则：</p>
<ul>
<li>在 <code>initial</code> 中选择 <strong>任意</strong> 子数组，并将子数组中每个元素增加 1 。</li>
</ul>
<p>答案保证在 32 位有符号整数以内。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>target = [1,2,3,2,1]
<strong>输出：</strong>3
<strong>解释：</strong>我们需要至少 3 次操作从 intial 数组得到 target 数组。
[0,0,0,0,0] 将下标为 0 到 4 的元素（包含二者）加 1 。
[1,1,1,1,1] 将下标为 1 到 3 的元素（包含二者）加 1 。
[1,2,2,2,1] 将下表为 2 的元素增加 1 。
[1,2,3,2,1] 得到了目标数组。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>target = [3,1,1,2]
<strong>输出：</strong>4
<strong>解释：</strong>(initial)[0,0,0,0] -&gt; [1,1,1,1] -&gt; [1,1,1,2] -&gt; [2,1,1,2] -&gt; [3,1,1,2] (target) 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>target = [3,1,5,4,2]
<strong>输出：</strong>7
<strong>解释：</strong>(initial)[0,0,0,0,0] -&gt; [1,1,1,1,1] -&gt; [2,1,1,1,1] -&gt; [3,1,1,1,1] 
                                  -&gt; [3,1,2,2,2] -&gt; [3,1,3,3,2] -&gt; [3,1,4,4,2] -&gt; [3,1,5,4,2] (target)。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>target = [1,1,1,1]
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target.length &lt;= 10^5</code></li>
<li><code>1 &lt;= target[i] &lt;= 10^5</code></li>
</ul>
</div></div></div><br><br><hr><br>***************************<div id="title">1531. String Compression II</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><a href="https://baike.baidu.com/item/%E8%A1%8C%E7%A8%8B%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81/2931940?fr=aladdin">行程长度编码</a> 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 <code>"aabccc"</code> ，将 <code>"aa"</code> 替换为 <code>"a2"</code> ，<code>"ccc"</code> 替换为` <code>"c3"</code> 。因此压缩后的字符串变为 <code>"a2bc3"</code> 。</p>
<p>注意，本问题中，压缩时没有在单个字符后附加计数 <code>'1'</code> 。</p>
<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你需要从字符串 <code>s</code> 中删除最多 <code>k</code> 个字符，以使 <code>s</code> 的行程长度编码长度最小。</p>
<p>请你返回删除最多 <code>k</code> 个字符后，<code>s</code> <strong>行程长度编码的最小长度</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "aaabcccd", k = 2
<strong>输出：</strong>4
<strong>解释：</strong>在不删除任何内容的情况下，压缩后的字符串是 "a3bc3d" ，长度为 6 。最优的方案是删除 'b' 和 'd'，这样一来，压缩后的字符串为 "a3c3" ，长度是 4 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "aabbaa", k = 2
<strong>输出：</strong>2
<strong>解释：</strong>如果删去两个 'b' 字符，那么压缩后的字符串是长度为 2 的 "a4" 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "aaaaaaaaaaa", k = 0
<strong>输出：</strong>3
<strong>解释：</strong>由于 k 等于 0 ，不能删去任何字符。压缩后的字符串是 "a11" ，长度为 3 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= s.length</code></li>
<li><code>s</code> 仅包含小写英文字母</li>
</ul>
</div></div></div><br><br><hr><br>***************************<div id="title">1537. Get the Maximum Score</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你有两个 <strong>有序</strong> 且数组内元素互不相同的数组 <code>nums1</code> 和 <code>nums2</code> 。</p>
<p>一条 <strong>合法路径</strong> 定义如下：</p>
<ul>
<li>选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。</li>
<li>从左到右遍历当前数组。</li>
<li>如果你遇到了 <code>nums1</code> 和 <code>nums2</code> 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。</li>
</ul>
<p>得分定义为合法路径中不同数字的和。</p>
<p>请你返回所有可能合法路径中的最大得分。</p>
<p>由于答案可能很大，请你将它对 10^9 + 7 取余后返回。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/sample_1_1893.png" style="height: 163px; width: 538px;"/></strong></p>
<pre><strong>输入：</strong>nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]
<strong>输出：</strong>30
<strong>解释：</strong>合法路径包括：
[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历）
[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]  （从 nums2 开始遍历）
最大得分为上图中的绿色路径 <strong>[2,4,6,8,10]</strong> 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums1 = [1,3,5,7,9], nums2 = [3,5,100]
<strong>输出：</strong>109
<strong>解释：</strong>最大得分由路径 <strong>[1,3,5,100]</strong> 得到。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]
<strong>输出：</strong>40
<strong>解释：</strong>nums1 和 nums2 之间无相同数字。
最大得分由路径 <strong>[6,7,8,9,10]</strong> 得到。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]
<strong>输出：</strong>61
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums2.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^7</code></li>
<li><code>nums1</code> 和 <code>nums2</code> 都是严格递增的数组。</li>
</ul>
</div></div></div><br><br><hr><br>************************************<div id="title">1542. Find Longest Awesome Substring</div>
************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> 。请返回 <code>s</code> 中最长的 <strong>超赞子字符串</strong> 的长度。</p>
<p>「超赞子字符串」需满足满足下述两个条件：</p>
<ul>
<li>该字符串是 <code>s</code> 的一个非空子字符串</li>
<li>进行任意次数的字符交换后，该字符串可以变成一个回文字符串</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "3242415"
<strong>输出：</strong>5
<strong>解释：</strong>"24241" 是最长的超赞子字符串，交换其中的字符后，可以得到回文 "24142"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "12345678"
<strong>输出：</strong>1
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "213123"
<strong>输出：</strong>6
<strong>解释：</strong>"213123" 是最长的超赞子字符串，交换其中的字符后，可以得到回文 "231132"
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>s = "00"
<strong>输出：</strong>2
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s</code> 仅由数字组成</li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1547. Minimum Cost to Cut a Stick</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一根长度为 <code>n</code> 个单位的木棍，棍上从 <code>0</code> 到 <code>n</code> 标记了若干位置。例如，长度为 <strong>6</strong> 的棍子可以标记如下：</p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/statement.jpg" style="height: 111px; width: 521px;"/></p>
<p>给你一个整数数组 <code>cuts</code> ，其中 <code>cuts[i]</code> 表示你需要将棍子切开的位置。</p>
<p>你可以按顺序完成切割，也可以根据需要更改切割的顺序。</p>
<p>每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。</p>
<p>返回切棍子的 <strong>最小总成本</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e1.jpg" style="height: 284px; width: 350px;"/></p>
<pre><strong>输入：</strong>n = 7, cuts = [1,3,4,5]
<strong>输出：</strong>16
<strong>解释：</strong>按 [1, 3, 4, 5] 的顺序切割的情况如下所示：
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e11.jpg" style="height: 284px; width: 350px;"/>
第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 = 20 。
而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 9, cuts = [5,6,1,4,2]
<strong>输出：</strong>22
<strong>解释：</strong>如果按给定的顺序切割，则总成本为 25 。总成本 &lt;= 25 的切割顺序很多，例如，[4, 6, 5, 2, 1] 的总成本 = 22，是所有可能方案中成本最小的。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10^6</code></li>
<li><code>1 &lt;= cuts.length &lt;= min(n - 1, 100)</code></li>
<li><code>1 &lt;= cuts[i] &lt;= n - 1</code></li>
<li><code>cuts</code> 数组中的所有整数都 <strong>互不相同</strong></li>
</ul>
</div></div></div><br><br><hr><br>*********************************************<div id="title">1553. Minimum Number of Days to Eat N Oranges</div>
*********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>厨房里总共有 <code>n</code> 个橘子，你决定每一天选择如下方式之一吃这些橘子：</p>
<ul>
<li>吃掉一个橘子。</li>
<li>如果剩余橘子数 <code>n</code> 能被 2 整除，那么你可以吃掉 <code>n/2</code> 个橘子。</li>
<li>如果剩余橘子数 <code>n</code> 能被 3 整除，那么你可以吃掉 <code>2*(n/3)</code> 个橘子。</li>
</ul>
<p>每天你只能从以上 3 种方案中选择一种方案。</p>
<p>请你返回吃掉所有 <code>n</code> 个橘子的最少天数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 10
<strong>输出：</strong>4
<strong>解释：</strong>你总共有 10 个橘子。
第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。
第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）
第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。
第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。
你需要至少 4 天吃掉 10 个橘子。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 6
<strong>输出：</strong>3
<strong>解释：</strong>你总共有 6 个橘子。
第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）
第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）
第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。
你至少需要 3 天吃掉 6 个橘子。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>1
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>n = 56
<strong>输出：</strong>6
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 2*10^9</code></li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">1563. Stone Game V</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>几块石子 <strong>排成一行</strong> ，每块石子都有一个关联值，关联值为整数，由数组 <code>stoneValue</code> 给出。</p>
<p>游戏中的每一轮：Alice 会将这行石子分成两个 <strong>非空行</strong>（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。</p>
<p>只 <strong>剩下一块石子</strong> 时，游戏结束。Alice 的分数最初为 <strong><code>0</code></strong> 。</p>
<p>返回 <strong>Alice 能够获得的最大分数</strong><em> 。</em></p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>stoneValue = [6,2,3,4,5,5]
<strong>输出：</strong>18
<strong>解释：</strong>在第一轮中，Alice 将行划分为 [6，2，3]，[4，5，5] 。左行的值是 11 ，右行的值是 14 。Bob 丢弃了右行，Alice 的分数现在是 11 。
在第二轮中，Alice 将行分成 [6]，[2，3] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 16（11 + 5）。
最后一轮 Alice 只能将行分成 [2]，[3] 。Bob 扔掉右行，Alice 的分数现在是 18（16 + 2）。游戏结束，因为这行只剩下一块石头了。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>stoneValue = [7,7,7,7,7,7,7]
<strong>输出：</strong>28
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>stoneValue = [4]
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stoneValue.length &lt;= 500</code></li>
<li><code>1 &lt;= stoneValue[i] &lt;= 10^6</code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************************<div id="title">1568. Minimum Number of Days to Disconnect Island</div>
*************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个大小为 <code>m x n</code> ，由若干 <code>0</code> 和 <code>1</code> 组成的二维网格 <code>grid</code> ，其中 <code>1</code> 表示陆地， <code>0</code> 表示水。<strong>岛屿</strong> 由水平方向或竖直方向上相邻的 <code>1</code> （陆地）连接形成。</p>
<p>如果 <strong>恰好只有一座岛屿 </strong>，则认为陆地是 <strong>连通的</strong> ；否则，陆地就是 <strong>分离的</strong> 。</p>
<p>一天内，可以将 <strong>任何单个</strong> 陆地单元（<code>1</code>）更改为水单元（<code>0</code>）。</p>
<p>返回使陆地分离的最少天数。</p>
<p> </p>
<p><strong class="example">示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/24/land1.jpg" style="width: 500px; height: 169px;"/>
<pre><strong>输入：</strong>grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
<strong>输出：</strong>2
<strong>解释：</strong>至少需要 2 天才能得到分离的陆地。
将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。</pre>
<p><strong class="example">示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/24/land2.jpg" style="width: 404px; height: 85px;"/>
<pre><strong>输入：</strong>grid = [[1,1]]
<strong>输出：</strong>2
<strong>解释：</strong>如果网格中都是水，也认为是分离的 ([[1,1]] -&gt; [[0,0]])，0 岛屿。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 30</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************************<div id="title">1569. Number of Ways to Reorder Array to Get Same BST</div>
*****************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个数组 <code>nums</code> 表示 <code>1</code> 到 <code>n</code> 的一个排列。我们按照元素在 <code>nums</code> 中的顺序依次插入一个初始为空的二叉查找树（BST）。请你统计将 <code>nums</code> 重新排序后，统计满足如下条件的方案数：重排后得到的二叉查找树与 <code>nums</code> 原本数字顺序得到的二叉查找树相同。</p>
<p>比方说，给你 <code>nums = [2,1,3]</code>，我们得到一棵 2 为根，1 为左孩子，3 为右孩子的树。数组 <code>[2,3,1]</code> 也能得到相同的 BST，但 <code>[3,2,1]</code> 会得到一棵不同的 BST 。</p>
<p>请你返回重排 <code>nums</code> 后，与原数组 <code>nums</code> 得到相同二叉查找树的方案数。</p>
<p>由于答案可能会很大，请将结果对<strong> </strong><code>10^9 + 7</code> 取余数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/bb.png" style="height: 101px; width: 121px;"/></p>
<pre><strong>输入：</strong>nums = [2,1,3]
<strong>输出：</strong>1
<strong>解释：</strong>我们将 nums 重排， [2,3,1] 能得到相同的 BST 。没有其他得到相同 BST 的方案了。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex1.png" style="height: 161px; width: 241px;"/></strong></p>
<pre><strong>输入：</strong>nums = [3,4,5,1,2]
<strong>输出：</strong>5
<strong>解释：</strong>下面 5 个数组会得到相同的 BST：
[3,1,2,4,5]
[3,1,4,2,5]
[3,1,4,5,2]
[3,4,1,2,5]
[3,4,1,5,2]
</pre>
<p><strong>示例 3：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex4.png" style="height: 161px; width: 121px;"/></strong></p>
<pre><strong>输入：</strong>nums = [1,2,3]
<strong>输出：</strong>0
<strong>解释：</strong>没有别的排列顺序能得到相同的 BST 。
</pre>
<p><strong>示例 4：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/abc.png" style="height: 161px; width: 241px;"/></strong></p>
<pre><strong>输入：</strong>nums = [3,1,2,5,4,6]
<strong>输出：</strong>19
</pre>
<p><strong>示例  5：</strong></p>
<pre><strong>输入：</strong>nums = [9,4,2,1,3,6,5,7,8,14,11,10,12,13,16,15,17,18]
<strong>输出：</strong>216212978
<strong>解释：</strong>得到相同 BST 的方案数是 3216212999。将它对 10^9 + 7 取余后得到 216212978。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
<li><code>nums</code> 中所有数 <strong>互不相同</strong> 。</li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">1575. Count All Possible Routes</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <strong>互不相同</strong> 的整数数组，其中 <code>locations[i]</code> 表示第 <code>i</code> 个城市的位置。同时给你 <code>start</code>，<code>finish</code> 和 <code>fuel</code> 分别表示出发城市、目的地城市和你初始拥有的汽油总量</p>
<p>每一步中，如果你在城市 <code>i</code> ，你可以选择任意一个城市 <code>j</code> ，满足  <code>j != i</code> 且 <code>0 &lt;= j &lt; locations.length</code> ，并移动到城市 <code>j</code> 。从城市 <code>i</code> 移动到 <code>j</code> 消耗的汽油量为 <code>|locations[i] - locations[j]|</code>，<code>|x|</code> 表示 <code>x</code> 的绝对值。</p>
<p>请注意， <code>fuel</code> 任何时刻都 <strong>不能</strong> 为负，且你 <strong>可以</strong> 经过任意城市超过一次（包括 <code>start</code> 和 <code>finish</code> ）。</p>
<p>请你返回从<em> </em><code>start</code> 到 <code>finish</code> 所有可能路径的数目。</p>
<p>由于答案可能很大， 请将它对 <code>10^9 + 7</code> 取余后返回。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5
<strong>输出：</strong>4
<strong>解释：</strong>以下为所有可能路径，每一条都用了 5 单位的汽油：
1 -&gt; 3
1 -&gt; 2 -&gt; 3
1 -&gt; 4 -&gt; 3
1 -&gt; 4 -&gt; 2 -&gt; 3
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>locations = [4,3,1], start = 1, finish = 0, fuel = 6
<strong>输出：</strong>5
<strong>解释：</strong>以下为所有可能的路径：
1 -&gt; 0，使用汽油量为 fuel = 1
1 -&gt; 2 -&gt; 0，使用汽油量为 fuel = 5
1 -&gt; 2 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 5
1 -&gt; 0 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 3
1 -&gt; 0 -&gt; 1 -&gt; 0 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 5
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>locations = [5,2,1], start = 0, finish = 2, fuel = 3
<strong>输出：</strong>0
<strong>解释：</strong>没有办法只用 3 单位的汽油从 0 到达 2 。因为最短路径需要 4 单位的汽油。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= locations.length &lt;= 100</code></li>
<li><code>1 &lt;= locations[i] &lt;= 10<sup>9</sup></code></li>
<li>所有 <code>locations</code> 中的整数 <strong>互不相同</strong> 。</li>
<li><code>0 &lt;= start, finish &lt; locations.length</code></li>
<li><code>1 &lt;= fuel &lt;= 200</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************************************<div id="title">1579. Remove Max Number of Edges to Keep Graph Fully Traversable</div>
****************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3  种类型的边：</p>
<ul>
<li>类型 1：只能由 Alice 遍历。</li>
<li>类型 2：只能由 Bob 遍历。</li>
<li>类型 3：Alice 和 Bob 都可以遍历。</li>
</ul>
<p>给你一个数组 <code>edges</code> ，其中 <code>edges[i] = [type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>]</code> 表示节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在类型为 <code>type<sub>i</sub></code> 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。</p>
<p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex1.png" style="height: 191px; width: 179px;"/></strong></p>
<pre><strong>输入：</strong>n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
<strong>输出：</strong>2
<strong>解释：</strong>如果删除<strong> </strong>[1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex2.png" style="height: 190px; width: 178px;"/></strong></p>
<pre><strong>输入：</strong>n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
<strong>输出：</strong>0
<strong>解释：</strong>注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。
</pre>
<p><strong>示例 3：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex3.png" style="height: 190px; width: 178px;"/></strong></p>
<pre><strong>输入：</strong>n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
<strong>输出：</strong>-1
<strong>解释：</strong>在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= edges.length &lt;= min(10^5, 3 * n * (n-1) / 2)</code></li>
<li><code>edges[i].length == 3</code></li>
<li><code>1 &lt;= edges[i][0] &lt;= 3</code></li>
<li><code>1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n</code></li>
<li>所有元组 <code>(type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>)</code> 互不相同</li>
</ul>
</div></div></div><br><br><hr><br>*********************************************************************<div id="title">1585. Check If String Is Transformable With Substring Sort Operations</div>
*********************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，请你通过若干次以下操作将字符串 <code>s</code> 转化成字符串 <code>t</code> ：</p>
<ul>
<li>选择 <code>s</code> 中一个 <strong>非空</strong> 子字符串并将它包含的字符就地 <strong>升序</strong> 排序。</li>
</ul>
<p>比方说，对下划线所示的子字符串进行操作可以由 <code>"1<strong>4234</strong>"</code> 得到 <code>"1<strong>2344</strong>"</code> 。</p>
<p>如果可以将字符串 <code>s</code> 变成 <code>t</code> ，返回 <code>true</code> 。否则，返回 <code>false</code> 。</p>
<p>一个 <strong>子字符串</strong> 定义为一个字符串中连续的若干字符。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "84532", t = "34852"
<strong>输出：</strong>true
<strong>解释：</strong>你可以按以下操作将 s 转变为 t ：
"84<strong>53</strong>2" （从下标 2 到下标 3）-&gt; "84<strong>35</strong>2"
"<strong>843</strong>52" （从下标 0 到下标 2） -&gt; "<strong>348</strong>52"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "34521", t = "23415"
<strong>输出：</strong>true
<strong>解释：</strong>你可以按以下操作将 s 转变为 t ：
"<strong>3452</strong>1" -&gt; "<strong>2345</strong>1"
"234<strong>51</strong>" -&gt; "234<strong>15</strong>"
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "12345", t = "12435"
<strong>输出：</strong>false
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>s = "1", t = "2"
<strong>输出：</strong>false
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>s.length == t.length</code></li>
<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
<li><code>s</code> 和 <code>t</code> 都只包含数字字符，即 <code>'0'</code> 到 <code>'9'</code> 。</li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">1591. Strange Printer II</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个奇怪的打印机，它有如下两个特殊的打印规则：</p>
<ul>
<li>每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。</li>
<li>一旦矩形根据上面的规则使用了一种颜色，那么 <strong>相同的颜色不能再被使用 </strong>。</li>
</ul>
<p>给你一个初始没有颜色的 <code>m x n</code> 的矩形 <code>targetGrid</code> ，其中 <code>targetGrid[row][col]</code> 是位置 <code>(row, col)</code> 的颜色。</p>
<p>如果你能按照上述规则打印出矩形<em> </em><code>targetGrid</code> ，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/19/sample_1_1929.png" style="height: 138px; width: 483px;"/></p>
<pre><strong>输入：</strong>targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
<strong>输出：</strong>true
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/19/sample_2_1929.png" style="height: 290px; width: 483px;"/></p>
<pre><strong>输入：</strong>targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]
<strong>输出：</strong>true
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>targetGrid = [[1,2,1],[2,1,2],[1,2,1]]
<strong>输出：</strong>false
<strong>解释：</strong>没有办法得到 targetGrid ，因为每一轮操作使用的颜色互不相同。</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>targetGrid = [[1,1,1],[3,1,3]]
<strong>输出：</strong>false
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == targetGrid.length</code></li>
<li><code>n == targetGrid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 60</code></li>
<li><code>1 &lt;= targetGrid[row][col] &lt;= 60</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************************<div id="title">1595. Minimum Cost to Connect Two Groups of Points</div>
**************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两组点，其中第一组中有 <code>size<sub>1</sub></code> 个点，第二组中有 <code>size<sub>2</sub></code> 个点，且 <code>size<sub>1</sub> &gt;= size<sub>2</sub></code> 。</p>
<p>任意两点间的连接成本 <code>cost</code> 由大小为 <code>size<sub>1</sub> x size<sub>2</sub></code> 矩阵给出，其中 <code>cost[i][j]</code> 是第一组中的点 <code>i</code> 和第二组中的点 <code>j</code> 的连接成本。<strong>如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。</strong>换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。</p>
<p>返回连通两组点所需的最小成本。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/20/ex1.jpg" style="height: 243px; width: 322px;"/></p>
<pre><strong>输入：</strong>cost = [[15, 96], [36, 2]]
<strong>输出：</strong>17
<strong>解释：</strong>连通两组点的最佳方法是：
1--A
2--B
总成本为 17 。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/20/ex2.jpg" style="height: 403px; width: 322px;"/></p>
<pre><strong>输入：</strong>cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]
<strong>输出：</strong>4
<strong>解释：</strong>连通两组点的最佳方法是：
1--A
2--B
2--C
3--A
最小成本为 4 。
请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]
<strong>输出：</strong>10
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>size<sub>1</sub> == cost.length</code></li>
<li><code>size<sub>2</sub> == cost[i].length</code></li>
<li><code>1 &lt;= size<sub>1</sub>, size<sub>2</sub> &lt;= 12</code></li>
<li><code>size<sub>1</sub> &gt;= size<sub>2</sub></code></li>
<li><code>0 &lt;= cost[i][j] &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************************<div id="title">1601. Maximum Number of Achievable Transfer Requests</div>
****************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>我们有 <code>n</code> 栋楼，编号从 <code>0</code> 到 <code>n - 1</code> 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。</p>
<p>给你一个数组 <code>requests</code> ，其中 <code>requests[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> ，表示一个员工请求从编号为 <code>from<sub>i</sub></code> 的楼搬到编号为 <code>to<sub>i</sub></code><sub> </sub>的楼。</p>
<p>一开始 <strong>所有楼都是满的</strong>，所以从请求列表中选出的若干个请求是可行的需要满足 <strong>每栋楼员工净变化为 0 </strong>。意思是每栋楼 <strong>离开</strong> 的员工数目 <strong>等于</strong> 该楼 <strong>搬入</strong> 的员工数数目。比方说 <code>n = 3</code> 且两个员工要离开楼 <code>0</code> ，一个员工要离开楼 <code>1</code> ，一个员工要离开楼 <code>2</code> ，如果该请求列表可行，应该要有两个员工搬入楼 <code>0</code> ，一个员工搬入楼 <code>1</code> ，一个员工搬入楼 <code>2</code> 。</p>
<p>请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/move1.jpg" style="height: 406px; width: 600px;"/></p>
<pre><strong>输入：</strong>n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
<strong>输出：</strong>5
<strong>解释：</strong>请求列表如下：
从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。
从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。
从楼 2 离开的员工为 z ，且他想要搬到楼 0 。
从楼 3 离开的员工为 c ，且他想要搬到楼 4 。
没有员工从楼 4 离开。
我们可以让 x 和 b 交换他们的楼，以满足他们的请求。
我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。
所以最多可以满足 5 个请求。</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/move2.jpg" style="height: 327px; width: 450px;"/></p>
<pre><strong>输入：</strong>n = 3, requests = [[0,0],[1,2],[2,1]]
<strong>输出：</strong>3
<strong>解释：</strong>请求列表如下：
从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。
从楼 1 离开的员工为 y ，且他想要搬到楼 2 。
从楼 2 离开的员工为 z ，且他想要搬到楼 1 。
我们可以满足所有的请求。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]
<strong>输出：</strong>4
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= requests.length &lt;= 16</code></li>
<li><code>requests[i].length == 2</code></li>
<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************************************<div id="title">1606. Find Servers That Handled Most Number of Requests</div>
*******************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你有 <code>k</code> 个服务器，编号为 <code>0</code> 到 <code>k-1</code> ，它们可以同时处理多个请求组。每个服务器有无穷的计算能力但是 <strong>不能同时处理超过一个请求</strong> 。请求分配到服务器的规则如下：</p>
<ul>
<li>第 <code>i</code> （序号从 0 开始）个请求到达。</li>
<li>如果所有服务器都已被占据，那么该请求被舍弃（完全不处理）。</li>
<li>如果第 <code>(i % k)</code> 个服务器空闲，那么对应服务器会处理该请求。</li>
<li>否则，将请求安排给下一个空闲的服务器（服务器构成一个环，必要的话可能从第 0 个服务器开始继续找下一个空闲的服务器）。比方说，如果第 <code>i</code> 个服务器在忙，那么会查看第 <code>(i+1)</code> 个服务器，第 <code>(i+2)</code> 个服务器等等。</li>
</ul>
<p>给你一个 <strong>严格递增</strong> 的正整数数组 <code>arrival</code> ，表示第 <code>i</code> 个任务的到达时间，和另一个数组 <code>load</code> ，其中 <code>load[i]</code> 表示第 <code>i</code> 个请求的工作量（也就是服务器完成它所需要的时间）。你的任务是找到 <strong>最繁忙的服务器</strong> 。最繁忙定义为一个服务器处理的请求数是所有服务器里最多的。</p>
<p>请你返回包含所有 <strong>最繁忙服务器</strong> 序号的列表，你可以以任意顺序返回这个列表。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/03/load-1.png" style="height: 221px; width: 389px;"/></p>
<pre><strong>输入：</strong>k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] 
<strong>输出：</strong>[1] 
<strong>解释：</strong>
所有服务器一开始都是空闲的。
前 3 个请求分别由前 3 台服务器依次处理。
请求 3 进来的时候，服务器 0 被占据，所以它被安排到下一台空闲的服务器，也就是服务器 1 。
请求 4 进来的时候，由于所有服务器都被占据，该请求被舍弃。
服务器 0 和 2 分别都处理了一个请求，服务器 1 处理了两个请求。所以服务器 1 是最忙的服务器。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>k = 3, arrival = [1,2,3,4], load = [1,2,1,2]
<strong>输出：</strong>[0]
<strong>解释：</strong>
前 3 个请求分别被前 3 个服务器处理。
请求 3 进来，由于服务器 0 空闲，它被服务器 0 处理。
服务器 0 处理了两个请求，服务器 1 和 2 分别处理了一个请求。所以服务器 0 是最忙的服务器。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>k = 3, arrival = [1,2,3], load = [10,12,11]
<strong>输出：</strong>[0,1,2]
<strong>解释：</strong>每个服务器分别处理了一个请求，所以它们都是最忙的服务器。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]
<strong>输出：</strong>[1]
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>k = 1, arrival = [1], load = [1]
<strong>输出：</strong>[0]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= arrival.length, load.length &lt;= 10<sup>5</sup></code></li>
<li><code>arrival.length == load.length</code></li>
<li><code>1 &lt;= arrival[i], load[i] &lt;= 10<sup>9</sup></code></li>
<li><code>arrival</code> 保证 <strong>严格递增</strong> 。</li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">1610. Maximum Number of Visible Points</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个点数组 <code>points</code> 和一个表示角度的整数 <code>angle</code> ，你的位置是 <code>location</code> ，其中 <code>location = [pos<sub>x</sub>, pos<sub>y</sub>]</code> 且 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 都表示 X-Y 平面上的整数坐标。</p>
<p>最开始，你面向东方进行观测。你 <strong>不能</strong> 进行移动改变位置，但可以通过 <strong>自转</strong> 调整观测角度。换句话说，<code>pos<sub>x</sub></code> 和 <code>pos<sub>y</sub></code> 不能改变。你的视野范围的角度用 <code>angle</code> 表示， 这决定了你观测任意方向时可以多宽。设 <code>d</code> 为你逆时针自转旋转的度数，那么你的视野就是角度范围 <code>[d - angle/2, d + angle/2]</code> 所指示的那片区域。</p>
<video autoplay="" controls="" height="360" muted="" style="max-width:100%;height:auto;" width="750"><source src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/angle.mp4" type="video/mp4"/>Your browser does not support the video tag or this video format.</video>
<p>对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 <strong>位于你的视野中</strong> ，那么你就可以看到它。</p>
<p>同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。</p>
<p>返回你能看到的点的最大数目。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/89a07e9b-00ab-4967-976a-c723b2aa8656.png" style="height: 300px; width: 400px;"/></p>
<pre><strong>输入：</strong>points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]
<strong>输出：</strong>3
<strong>解释：</strong>阴影区域代表你的视野。在你的视野中，所有的点都清晰可见，尽管 [2,2] 和 [3,3]在同一条直线上，你仍然可以看到 [3,3] 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]
<strong>输出：</strong>4
<strong>解释：</strong>在你的视野中，所有的点都清晰可见，包括你所在位置的那个点。</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/5010bfd3-86e6-465f-ac64-e9df941d2e49.png" style="height: 348px; width: 690px;"/></p>
<pre><strong>输入：</strong>points = [[1,0],[2,1]], angle = 13, location = [1,1]
<strong>输出：</strong>1
<strong>解释：</strong>如图所示，你只能看到两点之一。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= points.length &lt;= 10<sup>5</sup></code></li>
<li><code>points[i].length == 2</code></li>
<li><code>location.length == 2</code></li>
<li><code>0 &lt;= angle &lt; 360</code></li>
<li><code>0 &lt;= pos<sub>x</sub>, pos<sub>y</sub>, x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>******************************************************<div id="title">1611. Minimum One Bit Operations to Make Integers Zero</div>
******************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数 <code>n</code>，你需要重复执行多次下述操作将其转换为 <code>0</code> ：</p>
<ul>
<li>翻转 <code>n</code> 的二进制表示中最右侧位（第 <code>0</code> 位）。</li>
<li>如果第 <code>(i-1)</code> 位为 <code>1</code> 且从第 <code>(i-2)</code> 位到第 <code>0</code> 位都为 <code>0</code>，则翻转 <code>n</code> 的二进制表示中的第 <code>i</code> 位。</li>
</ul>
<p>返回将 <code>n</code> 转换为 <code>0</code> 的最小操作次数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>2
<strong>解释：</strong>3 的二进制表示为 "11"
"<strong>1</strong>1" -&gt; "<strong>0</strong>1" ，执行的是第 2 种操作，因为第 0 位为 1 。
"0<strong>1</strong>" -&gt; "0<strong>0</strong>" ，执行的是第 1 种操作。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 6
<strong>输出：</strong>4
<strong>解释：</strong>6 的二进制表示为 "110".
"<strong>1</strong>10" -&gt; "<strong>0</strong>10" ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。
"01<strong>0</strong>" -&gt; "01<strong>1</strong>" ，执行的是第 1 种操作。
"0<strong>1</strong>1" -&gt; "0<strong>0</strong>1" ，执行的是第 2 种操作，因为第 0 位为 1 。
"00<strong>1</strong>" -&gt; "00<strong>0</strong>" ，执行的是第 1 种操作。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************************<div id="title">1617. Count Subtrees With Max Distance Between Cities</div>
*****************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你 <code>n</code> 个城市，编号为从 <code>1</code> 到 <code>n</code> 。同时给你一个大小为 <code>n-1</code> 的数组 <code>edges</code> ，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示城市 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条双向边。题目保证任意城市之间只有唯一的一条路径。换句话说，所有城市形成了一棵 <strong>树</strong> 。</p>
<p>一棵 <strong>子树</strong> 是城市的一个子集，且子集中任意城市之间可以通过子集中的其他城市和边到达。两个子树被认为不一样的条件是至少有一个城市在其中一棵子树中存在，但在另一棵子树中不存在。</p>
<p>对于 <code>d</code> 从 <code>1</code> 到 <code>n-1</code> ，请你找到城市间 <strong>最大距离</strong> 恰好为 <code>d</code> 的所有子树数目。</p>
<p>请你返回一个大小为 <code>n-1</code> 的数组，其中第<em> </em><code>d</code><em> </em>个元素（<strong>下标从 1 开始</strong>）是城市间 <strong>最大距离</strong> 恰好等于 <code>d</code> 的子树数目。</p>
<p><strong>请注意</strong>，两个城市间距离定义为它们之间需要经过的边的数目。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/p1.png" style="width: 161px; height: 181px;"/></strong></p>
<pre><b>输入：</b>n = 4, edges = [[1,2],[2,3],[2,4]]
<b>输出：</b>[3,4,0]
<strong>解释：
</strong>子树 {1,2}, {2,3} 和 {2,4} 最大距离都是 1 。
子树 {1,2,3}, {1,2,4}, {2,3,4} 和 {1,2,3,4} 最大距离都为 2 。
不存在城市间最大距离为 3 的子树。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>n = 2, edges = [[1,2]]
<b>输出：</b>[1]
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>n = 3, edges = [[1,2],[2,3]]
<b>输出：</b>[2,1]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 15</code></li>
<li><code>edges.length == n-1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
<li>题目保证 <code>(u<sub>i</sub>, v<sub>i</sub>)</code> 所表示的边互不相同。</li>
</ul>
</div></div></div><br><br><hr><br>********************<div id="title">1622. Fancy Sequence</div>
********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>请你实现三个 API <code>append</code>，<code>addAll</code> 和 <code>multAll</code> 来实现奇妙序列。</p>
<p>请实现 <code>Fancy</code> 类 ：</p>
<ul>
<li><code>Fancy()</code> 初始化一个空序列对象。</li>
<li><code>void append(val)</code> 将整数 <code>val</code> 添加在序列末尾。</li>
<li><code>void addAll(inc)</code> 将所有序列中的现有数值都增加 <code>inc</code> 。</li>
<li><code>void multAll(m)</code> 将序列中的所有现有数值都乘以整数 <code>m</code> 。</li>
<li><code>int getIndex(idx)</code> 得到下标为 <code>idx</code> 处的数值（下标从 0 开始），并将结果对 <code>10<sup>9</sup> + 7</code> 取余。如果下标大于等于序列的长度，请返回 <code>-1</code> 。</li>
</ul>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>
["Fancy", "append", "addAll", "append", "multAll", "getIndex", "addAll", "append", "multAll", "getIndex", "getIndex", "getIndex"]
[[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]]
<strong>输出：</strong>
[null, null, null, null, null, 10, null, null, null, 26, 34, 20]

<strong>解释：</strong>
Fancy fancy = new Fancy();
fancy.append(2);   // 奇妙序列：[2]
fancy.addAll(3);   // 奇妙序列：[2+3] -&gt; [5]
fancy.append(7);   // 奇妙序列：[5, 7]
fancy.multAll(2);  // 奇妙序列：[5*2, 7*2] -&gt; [10, 14]
fancy.getIndex(0); // 返回 10
fancy.addAll(3);   // 奇妙序列：[10+3, 14+3] -&gt; [13, 17]
fancy.append(10);  // 奇妙序列：[13, 17, 10]
fancy.multAll(2);  // 奇妙序列：[13*2, 17*2, 10*2] -&gt; [26, 34, 20]
fancy.getIndex(0); // 返回 26
fancy.getIndex(1); // 返回 34
fancy.getIndex(2); // 返回 20
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= val, inc, m &lt;= 100</code></li>
<li><code>0 &lt;= idx &lt;= 10<sup>5</sup></code></li>
<li>总共最多会有 <code>10<sup>5</sup></code> 次对 <code>append</code>，<code>addAll</code>，<code>multAll</code> 和 <code>getIndex</code> 的调用。</li>
</ul>
</div></div></div><br><br><hr><br>***************************************<div id="title">1627. Graph Connectivity With Threshold</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有 <code>n</code> 座城市，编号从 <code>1</code> 到 <code>n</code> 。编号为 <code>x</code> 和 <code>y</code> 的两座城市直接连通的前提是： <code>x</code> 和 <code>y</code> 的公因数中，至少有一个 <strong>严格大于</strong> 某个阈值 <code>threshold</code> 。更正式地说，如果存在整数 <code>z</code> ，且满足以下所有条件，则编号 <code>x</code> 和 <code>y</code> 的城市之间有一条道路：</p>
<ul>
<li><code>x % z == 0</code></li>
<li><code>y % z == 0</code></li>
<li><code>z &gt; threshold</code></li>
</ul>
<p>给你两个整数 <code>n</code> 和 <code>threshold</code> ，以及一个待查询数组，请你判断每个查询<code> queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 指向的城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 是否连通（即，它们之间是否存在一条路径）。</p>
<p>返回数组 <code>answer</code> ，其中<code>answer.length == queries.length</code> 。如果第 <code>i</code> 个查询中指向的城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 连通，则 <code>answer[i]</code> 为 <code>true</code> ；如果不连通，则 <code>answer[i]</code> 为 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/ex1.jpg" style="width: 382px; height: 181px;"/></p>
<p> </p>
<pre><strong>输入：</strong>n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]
<strong>输出：</strong>[false,false,true]
<strong>解释：</strong>每个数的因数如下：
1:   1
2:   1, 2
3:   1, <strong>3</strong>
4:   1, 2, <strong>4</strong>
5:   1, <strong>5</strong>
6:   1, 2, <strong>3</strong>, <strong>6</strong>
所有大于阈值的的因数已经加粗标识，只有城市 3 和 6 共享公约数 3 ，因此结果是： 
[1,4]   1 与 4 不连通
[2,5]   2 与 5 不连通
[3,6]   3 与 6 连通，存在路径 3--6
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/tmp.jpg" style="width: 532px; height: 302px;"/></p>
<p> </p>
<pre><strong>输入：</strong>n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]
<strong>输出：</strong>[true,true,true,true,true]
<strong>解释：</strong>每个数的因数与上一个例子相同。但是，由于阈值为 0 ，所有的因数都大于阈值。因为所有的数字共享公因数 1 ，所以所有的城市都互相连通。
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/16/ex3.jpg" style="width: 282px; height: 282px;"/></p>
<p> </p>
<pre><strong>输入：</strong>n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]
<strong>输出：</strong>[false,false,false,false,false]
<strong>解释：</strong>只有城市 2 和 4 共享的公约数 2 严格大于阈值 1 ，所以只有这两座城市是连通的。
注意，同一对节点 [x, y] 可以有多个查询，并且查询 [x，y] 等同于查询 [y，x] 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>
<li><code>0 &lt;= threshold &lt;= n</code></li>
<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= cities</code></li>
<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
</ul>
</div></div></div><br><br><hr><br>********************************<div id="title">1632. Rank Transform of a Matrix</div>
********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> ，请你返回一个新的矩阵<em> </em><code>answer</code> ，其中<em> </em><code>answer[row][col]</code> 是 <code>matrix[row][col]</code> 的秩。</p>
<p>每个元素的 <b>秩</b> 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p>
<ul>
<li>秩是从 1 开始的一个整数。</li>
<li>如果两个元素 <code>p</code> 和 <code>q</code> 在 <strong>同一行</strong> 或者 <strong>同一列</strong> ，那么：
	<ul>
<li>如果 <code>p &lt; q</code> ，那么 <code>rank(p) &lt; rank(q)</code></li>
<li>如果 <code>p == q</code> ，那么 <code>rank(p) == rank(q)</code></li>
<li>如果 <code>p &gt; q</code> ，那么 <code>rank(p) &gt; rank(q)</code></li>
</ul>
</li>
<li><b>秩</b> 需要越 <strong>小</strong> 越好。</li>
</ul>
<p>题目保证按照上面规则 <code>answer</code> 数组是唯一的。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank1.jpg" style="width: 442px; height: 162px;"/>
<pre><b>输入：</b>matrix = [[1,2],[3,4]]
<b>输出：</b>[[1,2],[2,3]]
<strong>解释：</strong>
matrix[0][0] 的秩为 1 ，因为它是所在行和列的最小整数。
matrix[0][1] 的秩为 2 ，因为 matrix[0][1] &gt; matrix[0][0] 且 matrix[0][0] 的秩为 1 。
matrix[1][0] 的秩为 2 ，因为 matrix[1][0] &gt; matrix[0][0] 且 matrix[0][0] 的秩为 1 。
matrix[1][1] 的秩为 3 ，因为 matrix[1][1] &gt; matrix[0][1]， matrix[1][1] &gt; matrix[1][0] 且 matrix[0][1] 和 matrix[1][0] 的秩都为 2 。
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank2.jpg" style="width: 442px; height: 162px;"/>
<pre><b>输入：</b>matrix = [[7,7],[7,7]]
<b>输出：</b>[[1,1],[1,1]]
</pre>
<p><strong>示例 3：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank3.jpg" style="width: 601px; height: 322px;"/>
<pre><b>输入：</b>matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]
<b>输出：</b>[[4,2,3],[1,3,4],[5,1,6],[1,3,4]]
</pre>
<p><strong>示例 4：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank4.jpg" style="width: 601px; height: 242px;"/>
<pre><b>输入：</b>matrix = [[7,3,6],[1,4,5],[9,8,2]]
<b>输出：</b>[[5,1,4],[1,2,3],[6,3,1]]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 500</code></li>
<li><code>-10<sup>9</sup> &lt;= matrix[row][col] &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***************************************************************<div id="title">1639. Number of Ways to Form a Target String Given a Dictionary</div>
***************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串列表 <code>words</code> 和一个目标字符串 <code>target</code> 。<code>words</code> 中所有字符串都 <strong>长度相同</strong>  。</p>
<p>你的目标是使用给定的 <code>words</code> 字符串列表按照下述规则构造 <code>target</code> ：</p>
<ul>
<li>从左到右依次构造 <code>target</code> 的每一个字符。</li>
<li>为了得到 <code>target</code> 第 <code>i</code> 个字符（下标从 <strong>0</strong> 开始），当 <code>target[i] = words[j][k]</code> 时，你可以使用 <code>words</code> 列表中第 <code>j</code> 个字符串的第 <code>k</code> 个字符。</li>
<li>一旦你使用了 <code>words</code> 中第 <code>j</code> 个字符串的第 <code>k</code> 个字符，你不能再使用 <code>words</code> 字符串列表中任意单词的第 <code>x</code> 个字符（<code>x &lt;= k</code>）。也就是说，所有单词下标小于等于 <code>k</code> 的字符都不能再被使用。</li>
<li>请你重复此过程直到得到目标字符串 <code>target</code> 。</li>
</ul>
<p><strong>请注意</strong>， 在构造目标字符串的过程中，你可以按照上述规定使用 <code>words</code> 列表中 <strong>同一个字符串</strong> 的 <strong>多个字符</strong> 。</p>
<p>请你返回使用 <code>words</code> 构造 <code>target</code> 的方案数。由于答案可能会很大，请对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>
<p>（译者注：此题目求的是有多少个不同的 <code>k</code> 序列，详情请见示例。）</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>words = ["acca","bbbb","caca"], target = "aba"
<b>输出：</b>6
<b>解释：</b>总共有 6 种方法构造目标串。
"aba" -&gt; 下标为 0 ("<strong>a</strong>cca")，下标为 1 ("b<strong>b</strong>bb")，下标为 3 ("cac<strong>a</strong>")
"aba" -&gt; 下标为 0 ("<strong>a</strong>cca")，下标为 2 ("bb<strong>b</strong>b")，下标为 3 ("cac<strong>a</strong>")
"aba" -&gt; 下标为 0 ("<strong>a</strong>cca")，下标为 1 ("b<strong>b</strong>bb")，下标为 3 ("acc<strong>a</strong>")
"aba" -&gt; 下标为 0 ("<strong>a</strong>cca")，下标为 2 ("bb<strong>b</strong>b")，下标为 3 ("acc<strong>a</strong>")
"aba" -&gt; 下标为 1 ("c<strong>a</strong>ca")，下标为 2 ("bb<strong>b</strong>b")，下标为 3 ("acc<strong>a</strong>")
"aba" -&gt; 下标为 1 ("c<strong>a</strong>ca")，下标为 2 ("bb<strong>b</strong>b")，下标为 3 ("cac<strong>a</strong>")
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>words = ["abba","baab"], target = "bab"
<b>输出：</b>4
<b>解释：</b>总共有 4 种不同形成 target 的方法。
"bab" -&gt; 下标为 0 ("<strong>b</strong>aab")，下标为 1 ("b<strong>a</strong>ab")，下标为 2 ("ab<strong>b</strong>a")
"bab" -&gt; 下标为 0 ("<strong>b</strong>aab")，下标为 1 ("b<strong>a</strong>ab")，下标为 3 ("baa<strong>b</strong>")
"bab" -&gt; 下标为 0 ("<strong>b</strong>aab")，下标为 2 ("ba<strong>a</strong>b")，下标为 3 ("baa<strong>b</strong>")
"bab" -&gt; 下标为 1 ("a<strong>b</strong>ba")，下标为 2 ("ba<strong>a</strong>b")，下标为 3 ("baa<strong>b</strong>")
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>words = ["abcd"], target = "abcd"
<b>输出：</b>1
</pre>
<p><strong>示例 4：</strong></p>
<pre><b>输入：</b>words = ["abab","baba","abba","baab"], target = "abba"
<b>输出：</b>16
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>
<li><code>words</code> 中所有单词长度相同。</li>
<li><code>1 &lt;= target.length &lt;= 1000</code></li>
<li><code>words[i]</code> 和 <code>target</code> 都仅包含小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">1643. Kth Smallest Instructions</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>Bob 站在单元格 <code>(0, 0)</code> ，想要前往目的地 <code>destination</code> ：<code>(row, column)</code> 。他只能向 <strong>右</strong> 或向 <strong>下</strong> 走。你可以为 Bob 提供导航 <strong>指令</strong> 来帮助他到达目的地 <code>destination</code> 。</p>
<p><strong>指令</strong> 用字符串表示，其中每个字符：</p>
<ul>
<li><code>'H'</code> ，意味着水平向右移动</li>
<li><code>'V'</code> ，意味着竖直向下移动</li>
</ul>
<p>能够为 Bob 导航到目的地 <code>destination</code> 的指令可以有多种，例如，如果目的地 <code>destination</code> 是 <code>(2, 3)</code>，<code>"HHHVV"</code> 和 <code>"HVHVH"</code> 都是有效<strong> 指令</strong> 。</p>
<ul>
</ul>
<p>然而，Bob 很挑剔。因为他的幸运数字是 <code>k</code>，他想要遵循 <strong>按字典序排列后的第 <code>k</code> 条最小指令 </strong>的导航前往目的地 <code>destination</code> 。<code>k</code>  的编号 <strong>从 1 开始</strong> 。</p>
<p>给你一个整数数组 <code>destination</code> 和一个整数 <code>k</code> ，请你返回可以为<em> </em>Bob<em> </em>提供前往目的地 <code>destination</code> 导航的<strong> 按字典序排列后的第 <code>k</code> 条最小指令 </strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex1.png" style="width: 300px;"/></p>
<pre><strong>输入：</strong>destination = [2,3], k = 1
<strong>输出：</strong>"HHHVV"
<strong>解释：</strong>能前往 (2, 3) 的所有导航指令 <strong>按字典序排列后</strong> 如下所示：
["HHHVV", "HHVHV", "HHVVH", "HVHHV", "HVHVH", "HVVHH", "VHHHV", "VHHVH", "VHVHH", "VVHHH"].
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex2.png" style="width: 300px; height: 229px;"/></strong></p>
<pre><strong>输入：</strong>destination = [2,3], k = 2
<strong>输出：</strong>"HHVHV"
</pre>
<p><strong>示例 3：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex3.png" style="width: 300px; height: 229px;"/></strong></p>
<pre><strong>输入：</strong>destination = [2,3], k = 3
<strong>输出：</strong>"HHVVH"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>destination.length == 2</code></li>
<li><code>1 &lt;= row, column &lt;= 15</code></li>
<li><code>1 &lt;= k &lt;= nCr(row + column, row)</code>，其中 <code>nCr(a, b)</code> 表示组合数，即从 <code>a</code> 个物品中选 <code>b</code> 个物品的不同方案数。</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">1649. Create Sorted Array through Instructions</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>instructions</code> ，你需要根据 <code>instructions</code> 中的元素创建一个有序数组。一开始你有一个空的数组 <code>nums</code> ，你需要 <strong>从左到右</strong> 遍历 <code>instructions</code> 中的元素，将它们依次插入 <code>nums</code> 数组中。每一次插入操作的 <strong>代价</strong> 是以下两者的 <strong>较小值</strong> ：</p>
<ul>
<li><code>nums</code> 中 <strong>严格小于 </strong> <code>instructions[i]</code> 的数字数目。</li>
<li><code>nums</code> 中 <strong>严格大于 </strong> <code>instructions[i]</code> 的数字数目。</li>
</ul>
<p>比方说，如果要将 <code>3</code> 插入到 <code>nums = [1,2,3,5]</code> ，那么插入操作的 <strong>代价</strong> 为 <code>min(2, 1)</code> (元素 <code>1</code> 和  <code>2</code> 小于 <code>3</code> ，元素 <code>5</code> 大于 <code>3</code> ），插入后 <code>nums</code> 变成 <code>[1,2,3,3,5]</code> 。</p>
<p>请你返回将 <code>instructions</code> 中所有元素依次插入 <code>nums</code> 后的 <strong>总最小代价 </strong>。由于答案会很大，请将它对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 后返回。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>instructions = [1,5,6,2]
<b>输出：</b>1
<b>解释：</b>一开始 nums = [] 。
插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。
插入 5 ，代价为 min(1, 0) = 0 ，现在 nums = [1,5] 。
插入 6 ，代价为 min(2, 0) = 0 ，现在 nums = [1,5,6] 。
插入 2 ，代价为 min(1, 2) = 1 ，现在 nums = [1,2,5,6] 。
总代价为 0 + 0 + 0 + 1 = 1 。</pre>
<p><strong>示例 2:</strong></p>
<pre><b>输入：</b>instructions = [1,2,3,6,5,4]
<b>输出：</b>3
<b>解释：</b>一开始 nums = [] 。
插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。
插入 2 ，代价为 min(1, 0) = 0 ，现在 nums = [1,2] 。
插入 3 ，代价为 min(2, 0) = 0 ，现在 nums = [1,2,3] 。
插入 6 ，代价为 min(3, 0) = 0 ，现在 nums = [1,2,3,6] 。
插入 5 ，代价为 min(3, 1) = 1 ，现在 nums = [1,2,3,5,6] 。
插入 4 ，代价为 min(3, 2) = 2 ，现在 nums = [1,2,3,4,5,6] 。
总代价为 0 + 0 + 0 + 0 + 1 + 2 = 3 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>instructions = [1,3,3,3,2,4,2,1,2]
<b>输出：</b>4
<b>解释：</b>一开始 nums = [] 。
插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。
插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3] 。
插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3] 。
插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3,3] 。
插入 2 ，代价为 min(1, 3) = 1 ，现在 nums = [1,2,3,3,3] 。
插入 4 ，代价为 min(5, 0) = 0 ，现在 nums = [1,2,3,3,3,4] 。
​​​​​插入 2 ，代价为 min(1, 4) = 1 ，现在 nums = [1,2,2,3,3,3,4] 。
插入 1 ，代价为 min(0, 6) = 0 ，现在 nums = [1,1,2,2,3,3,3,4] 。
插入 2 ，代价为 min(2, 4) = 2 ，现在 nums = [1,1,2,2,2,3,3,3,4] 。
总代价为 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= instructions.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= instructions[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***********************************<div id="title">1655. Distribute Repeating Integers</div>
***********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，这个数组中至多有 <code>50</code> 个不同的值。同时你有 <code>m</code> 个顾客的订单 <code>quantity</code> ，其中，整数 <code>quantity[i]</code> 是第 <code>i</code> 位顾客订单的数目。请你判断是否能将 <code>nums</code> 中的整数分配给这些顾客，且满足：</p>
<ul>
<li>第 <code>i</code> 位顾客 <strong>恰好 </strong>有 <code>quantity[i]</code> 个整数。</li>
<li>第 <code>i</code> 位顾客拿到的整数都是 <strong>相同的</strong> 。</li>
<li>每位顾客都满足上述两个要求。</li>
</ul>
<p>如果你可以分配 <code>nums</code> 中的整数满足上面的要求，那么请返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [1,2,3,4], quantity = [2]
<b>输出：</b>false
<strong>解释：</strong>第 0 位顾客没办法得到两个相同的整数。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [1,2,3,3], quantity = [2]
<b>输出：</b>true
<b>解释：</b>第 0 位顾客得到 [3,3] 。整数 [1,2] 都没有被使用。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>nums = [1,1,2,2], quantity = [2,2]
<b>输出：</b>true
<b>解释：</b>第 0 位顾客得到 [1,1] ，第 1 位顾客得到 [2,2] 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>m == quantity.length</code></li>
<li><code>1 &lt;= m &lt;= 10</code></li>
<li><code>1 &lt;= quantity[i] &lt;= 10<sup>5</sup></code></li>
<li><code>nums</code> 中至多有 <code>50</code> 个不同的数字。</li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">1659. Maximize Grid Happiness</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你四个整数 <code>m</code>、<code>n</code>、<code>introvertsCount</code> 和 <code>extrovertsCount</code> 。有一个 <code>m x n</code> 网格，和两种类型的人：内向的人和外向的人。总共有 <code>introvertsCount</code> 个内向的人和 <code>extrovertsCount</code> 个外向的人。</p>
<p>请你决定网格中应当居住多少人，并为每个人分配一个网格单元。 注意，<strong>不必</strong> 让所有人都生活在网格中。</p>
<p>每个人的 <strong>幸福感</strong> 计算如下：</p>
<ul>
<li>内向的人 <strong>开始</strong> 时有 <code>120</code> 个幸福感，但每存在一个邻居（内向的或外向的）他都会 <strong>失去</strong>  <code>30</code> 个幸福感。</li>
<li>外向的人 <strong>开始</strong> 时有 <code>40</code> 个幸福感，每存在一个邻居（内向的或外向的）他都会 <strong>得到</strong>  <code>20</code> 个幸福感。</li>
</ul>
<p>邻居是指居住在一个人所在单元的上、下、左、右四个直接相邻的单元中的其他人。</p>
<p><strong>网格幸福感</strong> 是每个人幸福感的 <strong>总和</strong> 。 返回 <strong>最大可能的网格幸福感</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/15/grid_happiness.png" style="width: 261px; height: 121px;"/>
<pre><strong>输入：</strong>m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2
<strong>输出：</strong>240
<strong>解释：</strong>假设网格坐标 (row, column) 从 1 开始编号。
将内向的人放置在单元 (1,1) ，将外向的人放置在单元 (1,3) 和 (2,3) 。
- 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (0 * 30)（0 位邻居）= 120
- 位于 (1,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60
- 位于 (2,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60
网格幸福感为：120 + 60 + 60 = 240
上图展示该示例对应网格中每个人的幸福感。内向的人在浅绿色单元中，而外向的人在浅紫色单元中。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1
<strong>输出：</strong>260
<strong>解释：</strong>将内向的人放置在单元 (1,1) 和 (3,1) ，将外向的人放置在单元 (2,1) 。
- 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90
- 位于 (2,1) 的外向的人的幸福感：40（初始幸福感）+ (2 * 20)（2 位邻居）= 80
- 位于 (3,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90
网格幸福感为 90 + 80 + 90 = 260
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0
<strong>输出：</strong>240
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 5</code></li>
<li><code>0 &lt;= introvertsCount, extrovertsCount &lt;= min(m * n, 6)</code></li>
</ul>
</div></div></div><br><br><hr><br>********************************************<div id="title">1665. Minimum Initial Energy to Finish Tasks</div>
********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个任务数组 <code>tasks</code> ，其中 <code>tasks[i] = [actual<sub>i</sub>, minimum<sub>i</sub>]</code> ：</p>
<ul>
<li><code>actual<sub>i</sub></code> 是完成第 <code>i</code> 个任务 <strong>需要耗费</strong> 的实际能量。</li>
<li><code>minimum<sub>i</sub></code> 是开始第 <code>i</code> 个任务前需要达到的最低能量。</li>
</ul>
<p>比方说，如果任务为 <code>[10, 12]</code> 且你当前的能量为 <code>11</code> ，那么你不能开始这个任务。如果你当前的能量为 <code>13</code> ，你可以完成这个任务，且完成它后剩余能量为 <code>3</code> 。</p>
<p>你可以按照 <strong>任意顺序</strong> 完成任务。</p>
<p>请你返回完成所有任务的 <strong>最少</strong> 初始能量。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>tasks = [[1,2],[2,4],[4,8]]
<b>输出：</b>8
<strong>解释：</strong>
一开始有 8 能量，我们按照如下顺序完成任务：
    - 完成第 3 个任务，剩余能量为 8 - 4 = 4 。
    - 完成第 2 个任务，剩余能量为 4 - 2 = 2 。
    - 完成第 1 个任务，剩余能量为 2 - 1 = 1 。
注意到尽管我们有能量剩余，但是如果一开始只有 7 能量是不能完成所有任务的，因为我们无法开始第 3 个任务。</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]
<b>输出：</b>32
<strong>解释：</strong>
一开始有 32 能量，我们按照如下顺序完成任务：
    - 完成第 1 个任务，剩余能量为 32 - 1 = 31 。
    - 完成第 2 个任务，剩余能量为 31 - 2 = 29 。
    - 完成第 3 个任务，剩余能量为 29 - 10 = 19 。
    - 完成第 4 个任务，剩余能量为 19 - 10 = 9 。
    - 完成第 5 个任务，剩余能量为 9 - 8 = 1 。</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]
<b>输出：</b>27
<strong>解释：</strong>
一开始有 27 能量，我们按照如下顺序完成任务：
    - 完成第 5 个任务，剩余能量为 27 - 5 = 22 。
    - 完成第 2 个任务，剩余能量为 22 - 2 = 20 。
    - 完成第 3 个任务，剩余能量为 20 - 3 = 17 。
    - 完成第 1 个任务，剩余能量为 17 - 1 = 16 。
    - 完成第 4 个任务，剩余能量为 16 - 4 = 12 。
    - 完成第 6 个任务，剩余能量为 12 - 6 = 6 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= actual<sub>​i</sub> &lt;= minimum<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************************************<div id="title">1671. Minimum Number of Removals to Make Mountain Array</div>
*******************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>我们定义 <code>arr</code> 是 <b>山形数组</b> 当且仅当它满足：</p>
<ul>
<li><code>arr.length &gt;= 3</code></li>
<li>存在某个下标 <code>i</code> （<strong>从 0 开始</strong>） 满足 <code>0 &lt; i &lt; arr.length - 1</code> 且：
	<ul>
<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>
<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>
</ul>
</li>
</ul>
<p>给你整数数组 <code>nums</code>​ ，请你返回将 <code>nums</code> 变成 <strong>山形状数组</strong> 的​ <strong>最少</strong> 删除次数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [1,3,1]
<b>输出：</b>0
<b>解释：</b>数组本身就是山形数组，所以我们不需要删除任何元素。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [2,1,1,5,6,2,3,1]
<b>输出：</b>3
<b>解释：</b>一种方法是将下标为 0，1 和 5 的元素删除，剩余元素为 [1,5,6,3,1] ，是山形数组。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
<li>题目保证 <code>nums</code> 删除一些元素后一定能得到山形数组。</li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1675. Minimize Deviation in Array</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个由 <code>n</code> 个正整数组成的数组 <code>nums</code> 。</p>
<p>你可以对数组的任意元素执行任意次数的两类操作：</p>
<ul>
<li>如果元素是<strong> 偶数</strong> ，<strong>除以</strong> <code>2</code>
<ul>
<li>例如，如果数组是 <code>[1,2,3,4]</code> ，那么你可以对最后一个元素执行此操作，使其变成 <code>[1,2,3,<strong>2</strong>]</code></li>
</ul>
</li>
<li>如果元素是 <strong>奇数</strong> ，<strong>乘上</strong> <code>2</code>
<ul>
<li>例如，如果数组是 <code>[1,2,3,4]</code> ，那么你可以对第一个元素执行此操作，使其变成 <code>[<strong>2</strong>,2,3,4]</code></li>
</ul>
</li>
</ul>
<p>数组的 <strong>偏移量</strong> 是数组中任意两个元素之间的 <strong>最大差值</strong> 。</p>
<p>返回数组在执行某些操作之后可以拥有的 <strong>最小偏移量</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,3,4]
<strong>输出：</strong>1
<strong>解释：</strong>你可以将数组转换为 [1,2,3,<strong>2</strong>]，然后转换成 [<strong>2</strong>,2,3,2]，偏移量是 3 - 2 = 1
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [4,1,5,20,3]
<strong>输出：</strong>3
<strong>解释：</strong>两次操作后，你可以将数组转换为 [4,<strong>2</strong>,5,<strong>5</strong>,3]，偏移量是 5 - 2 = 3
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [2,10,8]
<strong>输出：</strong>3
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>2 &lt;= n &lt;= 5 * 10<sup><span style="font-size: 10.8333px;">4</span></sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">1681. Minimum Incompatibility</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code>​​​ 和一个整数 <code>k</code> 。你需要将这个数组划分到 <code>k</code> 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。</p>
<p>一个子集的 <strong>不兼容性</strong> 是该子集里面最大值和最小值的差。</p>
<p>请你返回将数组分成 <code>k</code> 个子集后，各子集 <strong>不兼容性 </strong>的<strong> 和</strong> 的 <strong>最小值</strong> ，如果无法分成分成 <code>k</code> 个子集，返回 <code>-1</code> 。</p>
<p>子集的定义是数组中一些数字的集合，对数字顺序没有要求。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [1,2,1,4], k = 2
<b>输出：</b>4
<b>解释：</b>最优的分配是 [1,2] 和 [1,4] 。
不兼容性和为 (2-1) + (4-1) = 4 。
注意到 [1,1] 和 [2,4] 可以得到更小的和，但是第一个集合有 2 个相同的元素，所以不可行。</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [6,3,8,1,3,1,2,2], k = 4
<b>输出：</b>6
<b>解释：</b>最优的子集分配为 [1,2]，[2,3]，[6,8] 和 [1,3] 。
不兼容性和为 (2-1) + (3-2) + (8-6) + (3-1) = 6 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>nums = [5,3,3,6,3,3], k = 3
<b>输出：</b>-1
<b>解释：</b>没办法将这些数字分配到 3 个子集且满足每个子集里没有相同数字。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li>
<li><code>nums.length</code> 能被 <code>k</code> 整除。</li>
<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
</ul>
</div></div></div><br><br><hr><br>********************************************<div id="title">1687. Delivering Boxes from Storage to Ports</div>
********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 <strong>箱子数目的限制</strong> 和 <strong>总重量的限制</strong> 。</p>
<p>给你一个箱子数组 <code>boxes</code> 和三个整数 <code>portsCount</code>, <code>maxBoxes</code> 和 <code>maxWeight</code> ，其中 <code>boxes[i] = [ports<sub>​​i</sub>​, weight<sub>i</sub>]</code> 。</p>
<ul>
<li><code>ports<sub>​​i</sub></code> 表示第 <code>i</code> 个箱子需要送达的码头， <code>weights<sub>i</sub></code> 是第 <code>i</code> 个箱子的重量。</li>
<li><code>portsCount</code> 是码头的数目。</li>
<li><code>maxBoxes</code> 和 <code>maxWeight</code> 分别是卡车每趟运输箱子数目和重量的限制。</li>
</ul>
<p>箱子需要按照 <strong>数组顺序</strong> 运输，同时每次运输需要遵循以下步骤：</p>
<ul>
<li>卡车从 <code>boxes</code> 队列中按顺序取出若干个箱子，但不能违反 <code>maxBoxes</code> 和 <code>maxWeight</code> 限制。</li>
<li>对于在卡车上的箱子，我们需要 <strong>按顺序</strong> 处理它们，卡车会通过 <strong>一趟行程</strong> 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 <strong>额外行程</strong> ，箱子也会立马被卸货。</li>
<li>卡车上所有箱子都被卸货后，卡车需要 <strong>一趟行程</strong> 回到仓库，从箱子队列里再取出一些箱子。</li>
</ul>
<p>卡车在将所有箱子运输并卸货后，最后必须回到仓库。</p>
<p>请你返回将所有箱子送到相应码头的 <b>最少行程</b> 次数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3
<b>输出：</b>4
<b>解释：</b>最优策略如下：
- 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。
所以总行程数为 4 。
注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6
<b>输出：</b>6
<b>解释：</b>最优策略如下：
- 卡车首先运输第一个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第二、第三、第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第五个箱子，到达码头 3 ，回到仓库，总共 2 趟行程。
总行程数为 2 + 2 + 2 = 6 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7
<b>输出：</b>6
<b>解释：</b>最优策略如下：
- 卡车运输第一和第二个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第三和第四个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第五和第六个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
总行程数为 2 + 2 + 2 = 6 。
</pre>
<p><strong>示例 4：</strong></p>
<pre><b>输入：</b>boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7
<b>输出：</b>14
<b>解释：</b>最优策略如下：
- 卡车运输第一个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第二个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第三和第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第五个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。
- 卡车运输第六和第七个箱子，到达码头 3 ，然后去码头 4 ，然后回到仓库，总共 3 趟行程。
- 卡车运输第八和第九个箱子，到达码头 1 ，然后去码头 5 ，然后回到仓库，总共 3 趟行程。
总行程数为 2 + 2 + 2 + 2 + 3 + 3 = 14 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= boxes.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= portsCount, maxBoxes, maxWeight &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= ports<sub>​​i</sub> &lt;= portsCount</code></li>
<li><code>1 &lt;= weights<sub>i</sub> &lt;= maxWeight</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">1691. Maximum Height by Stacking Cuboids </div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你 <code>n</code> 个长方体 <code>cuboids</code> ，其中第 <code>i</code> 个长方体的长宽高表示为 <code>cuboids[i] = [width<sub>i</sub>, length<sub>i</sub>, height<sub>i</sub>]</code>（<strong>下标从 0 开始</strong>）。请你从 <code>cuboids</code> 选出一个 <strong>子集</strong> ，并将它们堆叠起来。</p>
<p>如果 <code>width<sub>i</sub> &lt;= width<sub>j</sub></code> 且 <code>length<sub>i</sub> &lt;= length<sub>j</sub></code> 且 <code>height<sub>i</sub> &lt;= height<sub>j</sub></code> ，你就可以将长方体 <code>i</code> 堆叠在长方体 <code>j</code> 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。</p>
<p>返回 <strong>堆叠长方体</strong> <code>cuboids</code> 可以得到的 <strong>最大高度</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/12/image.jpg" style="width: 420px; height: 299px;"/></strong></p>
<pre><strong>输入：</strong>cuboids = [[50,45,20],[95,37,53],[45,23,12]]
<strong>输出：</strong>190
<strong>解释：</strong>
第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。
第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。
第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。
总高度是 95 + 50 + 45 = 190 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>cuboids = [[38,25,45],[76,35,3]]
<strong>输出：</strong>76
<strong>解释：</strong>
无法将任何长方体放在另一个上面。
选择第 1 个长方体然后旋转它，使 35x3 的一面朝下，其高度为 76 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]
<strong>输出：</strong>102
<strong>解释：</strong>
重新排列长方体后，可以看到所有长方体的尺寸都相同。
你可以把 11x7 的一面朝下，这样它们的高度就是 17 。
堆叠长方体的最大高度为 6 * 17 = 102 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == cuboids.length</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= width<sub>i</sub>, length<sub>i</sub>, height<sub>i</sub> &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************************<div id="title">1697. Checking Existence of Edge Length Limited Paths</div>
*****************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>n</code> 个点组成的无向图边集 <code>edgeList</code> ，其中 <code>edgeList[i] = [u<sub>i</sub>, v<sub>i</sub>, dis<sub>i</sub>]</code> 表示点 <code>u<sub>i</sub></code> 和点 <code>v<sub>i</sub></code> 之间有一条长度为 <code>dis<sub>i</sub></code> 的边。请注意，两个点之间可能有 <strong>超过一条边 </strong>。</p>
<p>给你一个查询数组<code>queries</code> ，其中 <code>queries[j] = [p<sub>j</sub>, q<sub>j</sub>, limit<sub>j</sub>]</code> ，你的任务是对于每个查询 <code>queries[j]</code> ，判断是否存在从 <code>p<sub>j</sub></code> 到 <code>q<sub>j</sub></code><sub> </sub>的路径，且这条路径上的每一条边都 <strong>严格小于</strong> <code>limit<sub>j</sub></code> 。</p>
<p>请你返回一个 <b>布尔数组</b><em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer.length == queries.length</code> ，当 <code>queries[j]</code> 的查询结果为 <code>true</code> 时， <code>answer</code> 第<em> </em><code>j</code> 个值为<em> </em><code>true</code><em> </em>，否则为 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/h.png" style="width: 267px; height: 262px;"/>
<pre><b>输入：</b>n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
<b>输出：</b>[false,true]
<b>解释：</b>上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。
对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。
对于第二个查询，有一条路径（0 -&gt; 1 -&gt; 2）两条边都小于 5 ，所以这个查询我们返回 true 。
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/q.png" style="width: 390px; height: 358px;"/>
<pre><b>输入：</b>n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
<b>输出：</b>[true,false]
<b>解释：</b>上图为给定数据。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= edgeList.length, queries.length &lt;= 10<sup>5</sup></code></li>
<li><code>edgeList[i].length == 3</code></li>
<li><code>queries[j].length == 3</code></li>
<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub>, p<sub>j</sub>, q<sub>j</sub> &lt;= n - 1</code></li>
<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
<li><code>p<sub>j</sub> != q<sub>j</sub></code></li>
<li><code>1 &lt;= dis<sub>i</sub>, limit<sub>j</sub> &lt;= 10<sup>9</sup></code></li>
<li>两个点之间可能有 <strong>多条</strong> 边。</li>
</ul>
</div></div></div><br><br><hr><br>***************************************************<div id="title">1703. Minimum Adjacent Swaps for K Consecutive Ones</div>
***************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。 <code>nums</code> 仅包含 <code>0</code> 和 <code>1</code> 。每一次移动，你可以选择 <strong>相邻</strong> 两个数字并将它们交换。</p>
<p>请你返回使 <code>nums</code> 中包含 <code>k</code> 个 <strong>连续 </strong><code>1</code> 的 <strong>最少</strong> 交换次数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [1,0,0,1,0,1], k = 2
<b>输出：</b>1
<b>解释：</b>在第一次操作时，nums 可以变成 [1,0,0,0,<strong>1</strong>,<strong>1</strong>] 得到连续两个 1 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [1,0,0,0,0,0,1,1], k = 3
<b>输出：</b>5
<b>解释：</b>通过 5 次操作，最左边的 1 可以移到右边直到 nums 变为 [0,0,0,0,0,<strong>1</strong>,<strong>1</strong>,<strong>1</strong>] 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>nums = [1,1,0,1], k = 2
<b>输出：</b>0
<b>解释：</b>nums 已经有连续 2 个 1 了。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>nums[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>
<li><code>1 &lt;= k &lt;= sum(nums)</code></li>
</ul>
</div></div></div><br><br><hr><br>********************************************<div id="title">1707. Maximum XOR With an Element From Array</div>
********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个由非负整数组成的数组 <code>nums</code> 。另有一个查询数组 <code>queries</code> ，其中 <code>queries[i] = [x<sub>i</sub>, m<sub>i</sub>]</code> 。</p>
<p>第 <code>i</code> 个查询的答案是 <code>x<sub>i</sub></code> 和任何 <code>nums</code> 数组中不超过 <code>m<sub>i</sub></code> 的元素按位异或（<code>XOR</code>）得到的最大值。换句话说，答案是 <code>max(nums[j] XOR x<sub>i</sub>)</code> ，其中所有 <code>j</code> 均满足 <code>nums[j] &lt;= m<sub>i</sub></code> 。如果 <code>nums</code> 中的所有元素都大于 <code>m<sub>i</sub></code>，最终答案就是 <code>-1</code> 。</p>
<p>返回一个整数数组<em> </em><code>answer</code><em> </em>作为查询的答案，其中<em> </em><code>answer.length == queries.length</code><em> </em>且<em> </em><code>answer[i]</code><em> </em>是第<em> </em><code>i</code><em> </em>个查询的答案。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
<strong>输出：</strong>[3,3,7]
<strong>解释：</strong>
1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。
2) 1 XOR 2 = 3.
3) 5 XOR 2 = 7.
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
<strong>输出：</strong>[15,-1,5]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length, queries.length &lt;= 10<sup>5</sup></code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>0 &lt;= nums[j], x<sub>i</sub>, m<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">1713. Minimum Operations to Make a Subsequence</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个数组 <code>target</code> ，包含若干 <strong>互不相同</strong> 的整数，以及另一个整数数组 <code>arr</code> ，<code>arr</code> <strong>可能</strong> 包含重复元素。</p>
<p>每一次操作中，你可以在 <code>arr</code> 的任意位置插入任一整数。比方说，如果 <code>arr = [1,4,1,2]</code> ，那么你可以在中间添加 <code>3</code> 得到 <code>[1,4,<strong>3</strong>,1,2]</code> 。你可以在数组最开始或最后面添加整数。</p>
<p>请你返回 <strong>最少</strong> 操作次数，使得<em> </em><code>target</code><em> </em>成为 <code>arr</code> 的一个子序列。</p>
<p>一个数组的 <strong>子序列</strong> 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,<strong>2</strong>,3,<strong>7</strong>,2,1,<strong>4</strong>]</code> 的子序列（加粗元素），但 <code>[2,4,2]</code> 不是子序列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>target = [5,1,3], <code>arr</code> = [9,4,2,3,4]
<b>输出：</b>2
<b>解释：</b>你可以添加 5 和 1 ，使得 arr 变为 [<strong>5</strong>,9,4,<strong>1</strong>,2,3,4] ，target 为 arr 的子序列。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>target = [6,4,8,1,3,2], <code>arr</code> = [4,7,6,2,3,8,6,1]
<b>输出：</b>3
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target.length, arr.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= target[i], arr[i] &lt;= 10<sup>9</sup></code></li>
<li><code>target</code> 不包含任何重复元素。</li>
</ul>
</div></div></div><br><br><hr><br>******************************************<div id="title">1719. Number Of Ways To Reconstruct A Tree</div>
******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个数组 <code>pairs</code> ，其中 <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，并且满足：</p>
<ul>
<li><code>pairs</code> 中没有重复元素</li>
<li><code>x<sub>i</sub> &lt; y<sub>i</sub></code></li>
</ul>
<p>令 <code>ways</code> 为满足下面条件的有根树的方案数：</p>
<ul>
<li>树所包含的所有节点值都在 <code>pairs</code> 中。</li>
<li>一个数对 <code>[x<sub>i</sub>, y<sub>i</sub>]</code> 出现在 <code>pairs</code> 中 <strong>当且仅当</strong><strong> </strong><code>x<sub>i</sub></code> 是 <code>y<sub>i</sub></code> 的祖先或者 <code>y<sub>i</sub></code> 是 <code>x<sub>i</sub></code><sub> </sub>的祖先。</li>
<li><strong>注意：</strong>构造出来的树不一定是二叉树。</li>
</ul>
<p>两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。</p>
<p>请你返回：</p>
<ul>
<li>如果 <code>ways == 0</code> ，返回 <code>0</code> 。</li>
<li>如果 <code>ways == 1</code> ，返回 <code>1</code> 。</li>
<li>如果 <code>ways &gt; 1</code> ，返回 <code>2</code> 。</li>
</ul>
<p>一棵 <strong>有根树</strong> 指的是只有一个根节点的树，所有边都是从根往外的方向。</p>
<p>我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 <strong>祖先</strong> 。根节点没有祖先。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/trees2.png" style="width: 208px; height: 221px;"/>
<pre><b>输入：</b>pairs = [[1,2],[2,3]]
<b>输出：</b>1
<b>解释：</b>如上图所示，有且只有一个符合规定的有根树。
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/tree.png" style="width: 234px; height: 241px;"/>
<pre><b>输入：</b>pairs = [[1,2],[2,3],[1,3]]
<b>输出：</b>2
<b>解释：</b>有多个符合规定的有根树，其中三个如上图所示。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>pairs = [[1,2],[2,3],[2,4],[1,5]]
<b>输出：</b>0
<b>解释：</b>没有符合规定的有根树。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= pairs.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= x<sub>i </sub>&lt; y<sub>i</sub> &lt;= 500</code></li>
<li><code>pairs</code> 中的元素互不相同。</li>
</ul>
</div></div></div><br><br><hr><br>******************************************<div id="title">1723. Find Minimum Time to Finish All Jobs</div>
******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>jobs</code> ，其中 <code>jobs[i]</code> 是完成第 <code>i</code> 项工作要花费的时间。</p>
<p>请你将这些工作分配给 <code>k</code> 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 <strong>工作时间</strong> 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 <strong>最大工作时间</strong> 得以 <strong>最小化</strong> 。</p>
<p>返回分配方案中尽可能 <strong>最小</strong> 的 <strong>最大工作时间</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>jobs = [3,2,3], k = 3
<strong>输出：</strong>3
<strong>解释：</strong>给每位工人分配一项工作，最大工作时间是 3 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>jobs = [1,2,4,7,8], k = 2
<strong>输出：</strong>11
<strong>解释：</strong>按下述方式分配工作：
1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）
2 号工人：4、7（工作时间 = 4 + 7 = 11）
最大工作时间是 11 。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= jobs.length &lt;= 12</code></li>
<li><code>1 &lt;= jobs[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**********************<div id="title">1728. Cat and Mouse II</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一只猫和一只老鼠在玩一个叫做猫和老鼠的游戏。</p>
<p>它们所处的环境设定是一个 <code>rows x cols</code> 的方格 <code>grid</code> ，其中每个格子可能是一堵墙、一块地板、一位玩家（猫或者老鼠）或者食物。</p>
<ul>
<li>玩家由字符 <code>'C'</code> （代表猫）和 <code>'M'</code> （代表老鼠）表示。</li>
<li>地板由字符 <code>'.'</code> 表示，玩家可以通过这个格子。</li>
<li>墙用字符 <code>'#'</code> 表示，玩家不能通过这个格子。</li>
<li>食物用字符 <code>'F'</code> 表示，玩家可以通过这个格子。</li>
<li>字符 <code>'C'</code> ， <code>'M'</code> 和 <code>'F'</code> 在 <code>grid</code> 中都只会出现一次。</li>
</ul>
<p>猫和老鼠按照如下规则移动：</p>
<ul>
<li>老鼠 <strong>先移动</strong> ，然后两名玩家轮流移动。</li>
<li>每一次操作时，猫和老鼠可以跳到上下左右四个方向之一的格子，他们不能跳过墙也不能跳出 <code>grid</code> 。</li>
<li><code>catJump</code> 和 <code>mouseJump</code> 是猫和老鼠分别跳一次能到达的最远距离，它们也可以跳小于最大距离的长度。</li>
<li>它们可以停留在原地。</li>
<li>老鼠可以跳跃过猫的位置。</li>
</ul>
<p>游戏有 4 种方式会结束：</p>
<ul>
<li>如果猫跟老鼠处在相同的位置，那么猫获胜。</li>
<li>如果猫先到达食物，那么猫获胜。</li>
<li>如果老鼠先到达食物，那么老鼠获胜。</li>
<li>如果老鼠不能在 1000 次操作以内到达食物，那么猫获胜。</li>
</ul>
<p>给你 <code>rows x cols</code> 的矩阵 <code>grid</code> 和两个整数 <code>catJump</code> 和 <code>mouseJump</code> ，双方都采取最优策略，如果老鼠获胜，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/sample_111_1955.png" style="width: 580px; height: 239px;"/></strong></p>
<pre><b>输入：</b>grid = ["####F","#C...","M...."], catJump = 1, mouseJump = 2
<b>输出：</b>true
<b>解释：</b>猫无法抓到老鼠，也没法比老鼠先到达食物。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/sample_2_1955.png" style="width: 580px; height: 175px;"/></p>
<pre><b>输入：</b>grid = ["M.C...F"], catJump = 1, mouseJump = 4
<b>输出：</b>true
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>grid = ["M.C...F"], catJump = 1, mouseJump = 3
<b>输出：</b>false
</pre>
<p><strong>示例 4：</strong></p>
<pre><b>输入：</b>grid = ["C...#","...#F","....#","M...."], catJump = 2, mouseJump = 5
<b>输出：</b>false
</pre>
<p><strong>示例 5：</strong></p>
<pre><b>输入：</b>grid = [".M...","..#..","#..#.","C#.#.","...#F"], catJump = 3, mouseJump = 1
<b>输出：</b>true
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>rows == grid.length</code></li>
<li><code>cols = grid[i].length</code></li>
<li><code>1 &lt;= rows, cols &lt;= 8</code></li>
<li><code>grid[i][j]</code> 只包含字符 <code>'C'</code> ，<code>'M'</code> ，<code>'F'</code> ，<code>'.'</code> 和 <code>'#'</code> 。</li>
<li><code>grid</code> 中只包含一个 <code>'C'</code> ，<code>'M'</code> 和 <code>'F'</code> 。</li>
<li><code>1 &lt;= catJump, mouseJump &lt;= 8</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************************<div id="title">1735. Count Ways to Make Array With Product</div>
*******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [n<sub>i</sub>, k<sub>i</sub>]</code> 。第 <code>i</code> 个查询 <code>queries[i]</code> 要求构造长度为 <code>n<sub>i</sub></code> 、每个元素都是正整数的数组，且满足所有元素的乘积为 <code>k<sub>i</sub></code><sub> </sub>，请你找出有多少种可行的方案。由于答案可能会很大，方案数需要对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 。</p>
<p>请你返回一个整数数组<em> </em><code>answer</code>，满足<em> </em><code>answer.length == queries.length</code> ，其中<em> </em><code>answer[i]</code>是第<em> </em><code>i</code> 个查询的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>queries = [[2,6],[5,1],[73,660]]
<b>输出：</b>[4,1,50734910]
<b>解释：</b>每个查询之间彼此独立。
[2,6]：总共有 4 种方案得到长度为 2 且乘积为 6 的数组：[1,6]，[2,3]，[3,2]，[6,1]。
[5,1]：总共有 1 种方案得到长度为 5 且乘积为 1 的数组：[1,1,1,1,1]。
[73,660]：总共有 1050734917 种方案得到长度为 73 且乘积为 660 的数组。1050734917 对 10<sup>9</sup> + 7 取余得到 50734910 。
</pre>
<p><strong>示例 2 ：</strong></p>
<pre><b>输入：</b>queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]
<b>输出：</b>[1,2,3,10,5]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup> </code></li>
<li><code>1 &lt;= n<sub>i</sub>, k<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>********************<div id="title">1739. Building Boxes</div>
********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一个立方体房间，其长度、宽度和高度都等于 <code>n</code> 个单位。请你在房间里放置 <code>n</code> 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：</p>
<ul>
<li>你可以把盒子放在地板上的任何地方。</li>
<li>如果盒子 <code>x</code> 需要放置在盒子 <code>y</code> 的顶部，那么盒子 <code>y</code> 竖直的四个侧面都 <strong>必须</strong> 与另一个盒子或墙相邻。</li>
</ul>
<p>给你一个整数 <code>n</code> ，返回接触地面的盒子的 <strong>最少</strong> 可能数量<em>。</em></p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/3-boxes.png" style="width: 135px; height: 143px;"/></p>
<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>3
<strong>解释：</strong>上图是 3 个盒子的摆放位置。
这些盒子放在房间的一角，对应左侧位置。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/4-boxes.png" style="width: 135px; height: 179px;"/></p>
<pre><strong>输入：</strong>n = 4
<strong>输出：</strong>3
<strong>解释：</strong>上图是 3 个盒子的摆放位置。
这些盒子放在房间的一角，对应左侧位置。
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/10-boxes.png" style="width: 271px; height: 257px;"/></p>
<pre><strong>输入：</strong>n = 10
<strong>输出：</strong>6
<strong>解释：</strong>上图是 10 个盒子的摆放位置。
这些盒子放在房间的一角，对应后方位置。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>********************************<div id="title">1745. Palindrome Partitioning IV</div>
********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> ，如果可以将它分割成三个 <strong>非空</strong> 回文子字符串，那么返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p>当一个字符串正着读和反着读是一模一样的，就称其为 <strong>回文字符串</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>s = "abcbdd"
<b>输出：</b>true
<strong>解释：</strong>"abcbdd" = "a" + "bcb" + "dd"，三个子字符串都是回文的。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>s = "bcbddxy"
<b>输出：</b>false
<strong>解释：</strong>s 没办法被分割成 3 个回文子字符串。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code>​​​​​​ 只包含小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>******************************************************<div id="title">1751. Maximum Number of Events That Can Be Attended II</div>
******************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>events</code> 数组，其中 <code>events[i] = [startDay<sub>i</sub>, endDay<sub>i</sub>, value<sub>i</sub>]</code> ，表示第 <code>i</code> 个会议在 <code>startDay<sub>i</sub></code><sub> </sub>天开始，第 <code>endDay<sub>i</sub></code> 天结束，如果你参加这个会议，你能得到价值 <code>value<sub>i</sub></code> 。同时给你一个整数 <code>k</code> 表示你能参加的最多会议数目。</p>
<p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 <strong>完整</strong> 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p>
<p>请你返回能得到的会议价值 <strong>最大和</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60048-pm.png" style="width: 400px; height: 103px;"/></p>
<pre><b>输入：</b>events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
<b>输出：</b>7
<strong>解释：</strong>选择绿色的活动会议 0 和 1，得到总价值和为 4 + 3 = 7 。</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60150-pm.png" style="width: 400px; height: 103px;"/></p>
<pre><b>输入：</b>events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
<b>输出：</b>10
<b>解释：</b>参加会议 2 ，得到价值和为 10 。
你没法再参加别的会议了，因为跟会议 2 有重叠。你 <strong>不</strong> 需要参加满 k 个会议。</pre>
<p><strong>示例 3：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60703-pm.png" style="width: 400px; height: 126px;"/></strong></p>
<pre><b>输入：</b>events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
<b>输出：</b>9
<b>解释：</b>尽管会议互不重叠，你只能参加 3 个会议，所以选择价值最大的 3 个会议。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= events.length</code></li>
<li><code>1 &lt;= k * events.length &lt;= 10<sup>6</sup></code></li>
<li><code>1 &lt;= startDay<sub>i</sub> &lt;= endDay<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
<li><code>1 &lt;= value<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">1755. Closest Subsequence Sum</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 和一个目标值 <code>goal</code> 。</p>
<p>你需要从 <code>nums</code> 中选出一个子序列，使子序列元素总和最接近 <code>goal</code> 。也就是说，如果子序列元素和为 <code>sum</code> ，你需要 <strong>最小化绝对差</strong> <code>abs(sum - goal)</code> 。</p>
<p>返回 <code>abs(sum - goal)</code> 可能的 <strong>最小值</strong> 。</p>
<p>注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [5,-7,3,5], goal = 6
<strong>输出：</strong>0
<strong>解释：</strong>选择整个数组作为选出的子序列，元素和为 6 。
子序列和与目标值相等，所以绝对差为 0 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [7,-9,15,-2], goal = -5
<strong>输出：</strong>1
<strong>解释：</strong>选出子序列 [7,-9,-2] ，元素和为 -4 。
绝对差为 abs(-4 - (-5)) = abs(1) = 1 ，是可能的最小值。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,3], goal = -7
<strong>输出：</strong>7
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 40</code></li>
<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
<li><code>-10<sup>9</sup> &lt;= goal &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***************************************************<div id="title">1761. Minimum Degree of a Connected Trio in a Graph</div>
***************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个无向图，整数 <code>n</code> 表示图中节点的数目，<code>edges</code> 数组表示图中的边，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> ，表示 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条无向边。</p>
<p>一个 <strong>连通三元组</strong> 指的是 <strong>三个</strong> 节点组成的集合且这三个点之间 <strong>两两</strong> 有边。</p>
<p><strong>连通三元组的度数</strong> 是所有满足此条件的边的数目：一个顶点在这个三元组内，而另一个顶点不在这个三元组内。</p>
<p>请你返回所有连通三元组中度数的 <strong>最小值</strong> ，如果图中没有连通三元组，那么返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/14/trios1.png" style="width: 388px; height: 164px;"/>
<pre><b>输入：</b>n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]
<b>输出：</b>3
<b>解释：</b>只有一个三元组 [1,2,3] 。构成度数的边在上图中已被加粗。
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/14/trios2.png" style="width: 388px; height: 164px;"/>
<pre><b>输入：</b>n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]
<b>输出：</b>0
<b>解释：</b>有 3 个三元组：
1) [1,4,3]，度数为 0 。
2) [2,5,6]，度数为 2 。
3) [5,6,7]，度数为 2 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 400</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>1 &lt;= edges.length &lt;= n * (n-1) / 2</code></li>
<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
<li>图中没有重复的边。</li>
</ul>
</div></div></div><br><br><hr><br>**********************<div id="title">1766. Tree of Coprimes</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>n</code> 个节点的树（也就是一个无环连通无向图），节点编号从 <code>0</code> 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条边，每个节点有一个值。树的 <strong>根节点</strong> 为 0 号点。</p>
<p>给你一个整数数组 <code>nums</code> 和一个二维数组 <code>edges</code> 来表示这棵树。<code>nums[i]</code> 表示第 <code>i</code> 个点的值，<code>edges[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> 表示节点 <code>u<sub>j</sub></code> 和节点 <code>v<sub>j</sub></code> 在树中有一条边。</p>
<p>当 <code>gcd(x, y) == 1</code> ，我们称两个数 <code>x</code> 和 <code>y</code> 是 <strong>互质的</strong> ，其中 <code>gcd(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的 <strong>最大公约数</strong> 。</p>
<p>从节点 <code>i</code> 到 <strong>根</strong> 最短路径上的点都是节点 <code>i</code> 的祖先节点。一个节点 <strong>不是</strong> 它自己的祖先节点。</p>
<p>请你返回一个大小为 <code>n</code> 的数组 <code>ans</code> ，其中<em> </em><code>ans[i]</code>是离节点 <code>i</code> 最近的祖先节点且满足<em> </em><code>nums[i]</code> 和<em> </em><code>nums[ans[i]]</code> 是 <strong>互质的</strong> ，如果不存在这样的祖先节点，<code>ans[i]</code> 为 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/20/untitled-diagram.png" style="width: 191px; height: 281px;"/></strong></p>
<pre><b>输入：</b>nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]
<b>输出：</b>[-1,0,0,1]
<b>解释：</b>上图中，每个节点的值在括号中表示。
- 节点 0 没有互质祖先。
- 节点 1 只有一个祖先节点 0 。它们的值是互质的（gcd(2,3) == 1）。
- 节点 2 有两个祖先节点，分别是节点 1 和节点 0 。节点 1 的值与它的值不是互质的（gcd(3,3) == 3）但节点 0 的值是互质的(gcd(2,3) == 1)，所以节点 0 是最近的符合要求的祖先节点。
- 节点 3 有两个祖先节点，分别是节点 1 和节点 0 。它与节点 1 互质（gcd(3,2) == 1），所以节点 1 是离它最近的符合要求的祖先节点。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/20/untitled-diagram1.png" style="width: 441px; height: 291px;"/></p>
<pre><strong>输入：</strong>nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
<b>输出：</b>[-1,0,-1,0,0,0,-1]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>nums.length == n</code></li>
<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>edges[j].length == 2</code></li>
<li><code>0 &lt;= u<sub>j</sub>, v<sub>j</sub> &lt; n</code></li>
<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************************************<div id="title">1770. Maximum Score from Performing Multiplication Operations</div>
*************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个长度分别 <code>n</code> 和 <code>m</code> 的整数数组 <code>nums</code> 和 <code>multipliers</code><strong> </strong>，其中 <code>n &gt;= m</code> ，数组下标 <strong>从 1 开始</strong> 计数。</p>
<p>初始时，你的分数为 <code>0</code> 。你需要执行恰好 <code>m</code> 步操作。在第 <code>i</code> 步操作（<strong>从 1 开始</strong> 计数）中，需要：</p>
<ul>
<li>选择数组 <code>nums</code> <strong>开头处或者末尾处</strong> 的整数 <code>x</code> 。</li>
<li>你获得 <code>multipliers[i] * x</code> 分，并累加到你的分数中。</li>
<li>将 <code>x</code> 从数组 <code>nums</code> 中移除。</li>
</ul>
<p>在执行<em> </em><code>m</code> 步操作后，返回 <strong>最大</strong> 分数<em>。</em></p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,3], multipliers = [3,2,1]
<strong>输出：</strong>14
<strong>解释：</strong>一种最优解决方案如下：
- 选择末尾处的整数 3 ，[1,2,<strong>3</strong>] ，得 3 * 3 = 9 分，累加到分数中。
- 选择末尾处的整数 2 ，[1,<strong>2</strong>] ，得 2 * 2 = 4 分，累加到分数中。
- 选择末尾处的整数 1 ，[<strong>1</strong>] ，得 1 * 1 = 1 分，累加到分数中。
总分数为 9 + 4 + 1 = 14 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
<strong>输出：</strong>102
<strong>解释：</strong>一种最优解决方案如下：
- 选择开头处的整数 -5 ，[<strong>-5</strong>,-3,-3,-2,7,1] ，得 -5 * -10 = 50 分，累加到分数中。
- 选择开头处的整数 -3 ，[<strong>-3</strong>,-3,-2,7,1] ，得 -3 * -5 = 15 分，累加到分数中。
- 选择开头处的整数 -3 ，[<strong>-3</strong>,-2,7,1] ，得 -3 * 3 = -9 分，累加到分数中。
- 选择末尾处的整数 1 ，[-2,7,<strong>1</strong>] ，得 1 * 4 = 4 分，累加到分数中。
- 选择末尾处的整数 7 ，[-2,<strong>7</strong>] ，得 7 * 6 = 42 分，累加到分数中。
总分数为 50 + 15 - 9 + 4 + 42 = 102 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>m == multipliers.length</code></li>
<li><code>1 &lt;= m &lt;= 10<sup>3</sup></code></li>
<li><code>m &lt;= n &lt;= 10<sup>5</sup></code><code> </code></li>
<li><code>-1000 &lt;= nums[i], multipliers[i] &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************************<div id="title">1771. Maximize Palindrome Length From Subsequences</div>
**************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> ，请你按下述方法构造一个字符串：</p>
<ul>
<li>从 <code>word1</code> 中选出某个 <strong>非空</strong> 子序列 <code>subsequence1</code> 。</li>
<li>从 <code>word2</code> 中选出某个 <strong>非空</strong> 子序列 <code>subsequence2</code> 。</li>
<li>连接两个子序列 <code>subsequence1 + subsequence2</code> ，得到字符串。</li>
</ul>
<p>返回可按上述方法构造的最长 <strong>回文串</strong> 的 <strong>长度</strong> 。如果无法构造回文串，返回 <code>0</code> 。</p>
<p>字符串 <code>s</code> 的一个 <strong>子序列</strong> 是通过从 <code>s</code> 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。</p>
<p><strong>回文串</strong> 是正着读和反着读结果一致的字符串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>word1 = "cacb", word2 = "cbba"
<strong>输出：</strong>5
<strong>解释：</strong>从 word1 中选出 "ab" ，从 word2 中选出 "cba" ，得到回文串 "abcba" 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>word1 = "ab", word2 = "ab"
<strong>输出：</strong>3
<strong>解释：</strong>从 word1 中选出 "ab" ，从 word2 中选出 "a" ，得到回文串 "aba" 。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>word1 = "aa", word2 = "bb"
<strong>输出：</strong>0
<strong>解释：</strong>无法按题面所述方法构造回文串，所以返回 0 。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word1.length, word2.length &lt;= 1000</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">1776. Car Fleet II</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在一条单车道上有 <code>n</code> 辆车，它们朝着同样的方向行驶。给你一个长度为 <code>n</code> 的数组 <code>cars</code> ，其中 <code>cars[i] = [position<sub>i</sub>, speed<sub>i</sub>]</code> ，它表示：</p>
<ul>
<li><code>position<sub>i</sub></code> 是第 <code>i</code> 辆车和道路起点之间的距离（单位：米）。题目保证 <code>position<sub>i</sub> &lt; position<sub>i+1</sub></code><sub> </sub>。</li>
<li><code>speed<sub>i</sub></code> 是第 <code>i</code> 辆车的初始速度（单位：米/秒）。</li>
</ul>
<p>简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 <strong>最慢</strong> 一辆车的速度。</p>
<p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 <code>answer[i]</code> 为 <code>-1</code> 。答案精度误差需在 <code>10<sup>-5</sup></code> 以内。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>cars = [[1,2],[2,1],[4,3],[7,2]]
<b>输出：</b>[1.00000,-1.00000,3.00000,-1.00000]
<b>解释：</b>经过恰好 1 秒以后，第一辆车会与第二辆车相遇，并形成一个 1 m/s 的车队。经过恰好 3 秒以后，第三辆车会与第四辆车相遇，并形成一个 2 m/s 的车队。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>cars = [[3,4],[5,4],[6,3],[9,1]]
<b>输出：</b>[2.00000,1.00000,1.50000,-1.00000]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= cars.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= position<sub>i</sub>, speed<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
<li><code>position<sub>i</sub> &lt; position<sub>i+1</sub></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">1782. Count Pairs Of Nodes</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个无向图，无向图由整数 <code>n</code>  ，表示图中节点的数目，和 <code>edges</code> 组成，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条无向边。同时给你一个代表查询的整数数组 <code>queries</code> 。</p>
<p>第 <code>j</code> 个查询的答案是满足如下条件的点对 <code>(a, b)</code> 的数目：</p>
<ul>
<li><code>a &lt; b</code></li>
<li><code>cnt</code> 是与 <code>a</code> <strong>或者 </strong><code>b</code> 相连的边的数目，且 <code>cnt</code> <strong>严格大于 </strong><code>queries[j]</code> 。</li>
</ul>
<p>请你返回一个数组 <code>answers</code> ，其中 <code>answers.length == queries.length</code> 且 <code>answers[j]</code> 是第 <code>j</code> 个查询的答案。</p>
<p>请注意，图中可能会有 <strong>重复边</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://pic.leetcode-cn.com/1614828447-GMnLVg-image.png" style="width: 310px; height: 278px;"/>
<pre><b>输入：</b>n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
<b>输出：</b>[6,5]
<b>解释：</b>每个点对中，与至少一个点相连的边的数目如上图所示。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]
<b>输出：</b>[10,10,9,8,6]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>
<li><code>1 &lt;= queries.length &lt;= 20</code></li>
<li><code>0 &lt;= queries[j] &lt; edges.length</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************************<div id="title">1787. Make the XOR of All Segments Equal to Zero</div>
************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code>​​​ 和一个整数 <code>k</code>​​​​​ 。区间 <code>[left, right]</code>（<code>left &lt;= right</code>）的 <strong>异或结果</strong> 是对下标位于 <code>left</code> 和 <code>right</code>（包括 <code>left</code> 和 <code>right</code> ）之间所有元素进行 <code>XOR</code> 运算的结果：<code>nums[left] XOR nums[left+1] XOR ... XOR nums[right]</code> 。</p>
<p>返回数组中 <strong>要更改的最小元素数</strong> ，以使所有长度为 <code>k</code> 的区间异或结果等于零。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,0,3,0], k = 1
<strong>输出：</strong>3
<strong>解释：</strong>将数组 [<strong>1</strong>,<strong>2</strong>,0,<strong>3</strong>,0] 修改为 [<strong>0</strong>,<strong>0</strong>,0,<strong>0</strong>,0]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [3,4,5,2,1,7,3,4,7], k = 3
<strong>输出：</strong>3
<strong>解释：</strong>将数组 [3,4,<strong>5</strong>,<strong>2</strong>,<strong>1</strong>,7,3,4,7] 修改为 [3,4,<strong>7</strong>,<strong>3</strong>,<strong>4</strong>,7,3,4,7]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,4,1,2,5,1,2,6], k = 3
<strong>输出：</strong>3
<strong>解释：</strong>将数组[1,2,<strong>4,</strong>1,2,<strong>5</strong>,1,2,<strong>6</strong>] 修改为 [1,2,<strong>3</strong>,1,2,<strong>3</strong>,1,2,<strong>3</strong>]</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 2000</code></li>
<li><code>​​​​​​0 &lt;= nums[i] &lt; 2<sup>10</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">1793. Maximum Score of a Good Subarray</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> <strong>（下标从 0 开始）</strong>和一个整数 <code>k</code> 。</p>
<p>一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。</p>
<p>请你返回 <strong>好</strong> 子数组的最大可能 <strong>分数</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [1,4,3,7,4,5], k = 3
<b>输出：</b>15
<b>解释：</b>最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [5,5,4,5,4,1,1,1], k = 0
<b>输出：</b>20
<b>解释：</b>最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>0 &lt;= k &lt; nums.length</code></li>
</ul>
</div></div></div><br><br><hr><br>***************************************<div id="title">1799. Maximize Score After N Operations</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你 <code>nums</code> ，它是一个大小为 <code>2 * n</code> 的正整数数组。你必须对这个数组执行 <code>n</code> 次操作。</p>
<p>在第 <code>i</code> 次操作时（操作编号从 <strong>1</strong> 开始），你需要：</p>
<ul>
<li>选择两个元素 <code>x</code> 和 <code>y</code> 。</li>
<li>获得分数 <code>i * gcd(x, y)</code> 。</li>
<li>将 <code>x</code> 和 <code>y</code> 从 <code>nums</code> 中删除。</li>
</ul>
<p>请你返回 <code>n</code> 次操作后你能获得的分数和最大为多少。</p>
<p>函数 <code>gcd(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的最大公约数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [1,2]
<b>输出：</b>1
<b>解释：</b>最优操作是：
(1 * gcd(1, 2)) = 1
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [3,4,6,8]
<b>输出：</b>11
<b>解释：</b>最优操作是：
(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>nums = [1,2,3,4,5,6]
<b>输出：</b>14
<b>解释：</b>最优操作是：
(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 7</code></li>
<li><code>nums.length == 2 * n</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************<div id="title">1803. Count Pairs With XOR in a Range</div>
*************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> （下标 <strong>从 0 开始</strong> 计数）以及两个整数：<code>low</code> 和 <code>high</code> ，请返回 <strong>漂亮数对</strong> 的数目。</p>
<p><strong>漂亮数对</strong> 是一个形如 <code>(i, j)</code> 的数对，其中 <code>0 &lt;= i &lt; j &lt; nums.length</code> 且 <code>low &lt;= (nums[i] XOR nums[j]) &lt;= high</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,4,2,7], low = 2, high = 6
<strong>输出：</strong>6
<strong>解释：</strong>所有漂亮数对 (i, j) 列出如下：
    - (0, 1): nums[0] XOR nums[1] = 5 
    - (0, 2): nums[0] XOR nums[2] = 3
    - (0, 3): nums[0] XOR nums[3] = 6
    - (1, 2): nums[1] XOR nums[2] = 6
    - (1, 3): nums[1] XOR nums[3] = 3
    - (2, 3): nums[2] XOR nums[3] = 5
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [9,8,4,2,1], low = 5, high = 14
<strong>输出：</strong>8
<strong>解释：</strong>所有漂亮数对 (i, j) 列出如下：
​​​​​    - (0, 2): nums[0] XOR nums[2] = 13
    - (0, 3): nums[0] XOR nums[3] = 11
    - (0, 4): nums[0] XOR nums[4] = 8
    - (1, 2): nums[1] XOR nums[2] = 12
    - (1, 3): nums[1] XOR nums[3] = 10
    - (1, 4): nums[1] XOR nums[4] = 9
    - (2, 3): nums[2] XOR nums[3] = 6
    - (2, 4): nums[2] XOR nums[4] = 5</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= low &lt;= high &lt;= 2 * 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">1808. Maximize Number of Nice Divisors</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个正整数 <code>primeFactors</code> 。你需要构造一个正整数 <code>n</code> ，它满足以下条件：</p>
<ul>
<li><code>n</code> 质因数（质因数需要考虑重复的情况）的数目 <strong>不超过 </strong><code>primeFactors</code> 个。</li>
<li><code>n</code> 好因子的数目最大化。如果 <code>n</code> 的一个因子可以被 <code>n</code> 的每一个质因数整除，我们称这个因子是 <strong>好因子</strong> 。比方说，如果 <code>n = 12</code> ，那么它的质因数为 <code>[2,2,3]</code> ，那么 <code>6</code> 和 <code>12</code> 是好因子，但 <code>3</code> 和 <code>4</code> 不是。</li>
</ul>
<p>请你返回 <code>n</code> 的好因子的数目。由于答案可能会很大，请返回答案对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 的结果。</p>
<p>请注意，一个质数的定义是大于 <code>1</code> ，且不能被分解为两个小于该数的自然数相乘。一个数 <code>n</code> 的质因子是将 <code>n</code> 分解为若干个质因子，且它们的乘积为 <code>n</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>primeFactors = 5
<strong>输出：</strong>6
<b>解释：</b>200 是一个可行的 n 。
它有 5 个质因子：[2,2,2,5,5] ，且有 6 个好因子：[10,20,40,50,100,200] 。
不存在别的 n 有至多 5 个质因子，且同时有更多的好因子。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>primeFactors = 8
<b>输出：</b>18
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= primeFactors &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***************************************************<div id="title">1815. Maximum Number of Groups Getting Fresh Donuts</div>
***************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一个甜甜圈商店，每批次都烤 <code>batchSize</code> 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 <strong>所有</strong> 甜甜圈都必须已经全部销售完毕。给你一个整数 <code>batchSize</code> 和一个整数数组 <code>groups</code> ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 <code>groups[i]</code> 表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。</p>
<p>当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。</p>
<p>你可以随意安排每批顾客到来的顺序。请你返回在此前提下，<strong>最多</strong> 有多少组人会感到开心。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>batchSize = 3, groups = [1,2,3,4,5,6]
<b>输出：</b>4
<b>解释：</b>你可以将这些批次的顾客顺序安排为 [6,2,4,5,1,3] 。那么第 1，2，4，6 组都会感到开心。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>batchSize = 4, groups = [1,3,2,5,2,2,1,6]
<b>输出：</b>4
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= batchSize &lt;= 9</code></li>
<li><code>1 &lt;= groups.length &lt;= 30</code></li>
<li><code>1 &lt;= groups[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************************<div id="title">1819. Number of Different Subsequences GCDs</div>
*******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个由正整数组成的数组 <code>nums</code> 。</p>
<p>数字序列的 <strong>最大公约数</strong> 定义为序列中所有整数的共有约数中的最大整数。</p>
<ul>
<li>例如，序列 <code>[4,6,16]</code> 的最大公约数是 <code>2</code> 。</li>
</ul>
<p>数组的一个 <strong>子序列</strong> 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。</p>
<ul>
<li>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,<strong>2</strong>,4,1,<strong>5</strong>,<strong>10</strong>]</code> 的一个子序列。</li>
</ul>
<p>计算并返回 <code>nums</code> 的所有 <strong>非空</strong> 子序列中 <strong>不同</strong> 最大公约数的 <strong>数目</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/03/image-1.png"/>
<pre><strong>输入：</strong>nums = [6,10,3]
<strong>输出：</strong>5
<strong>解释：</strong>上图显示了所有的非空子序列与各自的最大公约数。
不同的最大公约数为 6 、10 、3 、2 和 1 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [5,15,40,5,6]
<strong>输出：</strong>7
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">1825. Finding MK Average</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个整数 <code>m</code> 和 <code>k</code> ，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 <b>MK 平均值</b> 。</p>
<p><strong>MK 平均值</strong> 按照如下步骤计算：</p>
<ol>
<li>如果数据流中的整数少于 <code>m</code> 个，<strong>MK 平均值</strong> 为 <code>-1</code> ，否则将数据流中最后 <code>m</code> 个元素拷贝到一个独立的容器中。</li>
<li>从这个容器中删除最小的 <code>k</code> 个数和最大的 <code>k</code> 个数。</li>
<li>计算剩余元素的平均值，并 <strong>向下取整到最近的整数</strong> 。</li>
</ol>
<p>请你实现 <code>MKAverage</code> 类：</p>
<ul>
<li><code>MKAverage(int m, int k)</code> 用一个空的数据流和两个整数 <code>m</code> 和 <code>k</code> 初始化 <strong>MKAverage</strong> 对象。</li>
<li><code>void addElement(int num)</code> 往数据流中插入一个新的元素 <code>num</code> 。</li>
<li><code>int calculateMKAverage()</code> 对当前的数据流计算并返回 <strong>MK 平均数</strong> ，结果需 <strong>向下取整到最近的整数</strong> 。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>
["MKAverage", "addElement", "addElement", "calculateMKAverage", "addElement", "calculateMKAverage", "addElement", "addElement", "addElement", "calculateMKAverage"]
[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]
<strong>输出：</strong>
[null, null, null, -1, null, 3, null, null, null, 5]

<strong>解释：</strong>
MKAverage obj = new MKAverage(3, 1); 
obj.addElement(3);        // 当前元素为 [3]
obj.addElement(1);        // 当前元素为 [3,1]
obj.calculateMKAverage(); // 返回 -1 ，因为 m = 3 ，但数据流中只有 2 个元素
obj.addElement(10);       // 当前元素为 [3,1,10]
obj.calculateMKAverage(); // 最后 3 个元素为 [3,1,10]
                          // 删除最小以及最大的 1 个元素后，容器为 <code>[3]
                          // [3] 的平均值等于 3/1 = 3 ，故返回 3
obj.addElement(5);        // 当前元素为 [3,1,10,5]
obj.addElement(5);        // 当前元素为 [3,1,10,5,5]
obj.addElement(5);        // 当前元素为 [3,1,10,5,5,5]
obj.calculateMKAverage(); // 最后 3 个元素为 [5,5,5]
                          // </code>删除最小以及最大的 1 个元素后，容器为 <code>[5]<code>
                          // </code>[5] 的平均值等于 5/1 = 5 ，故返回 5<code>
</code></code></pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= m &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= k*2 &lt; m</code></li>
<li><code>1 &lt;= num &lt;= 10<sup>5</sup></code></li>
<li><code>addElement</code> 与 <code>calculateMKAverage</code> 总操作次数不超过 <code>10<sup>5</sup></code> 次。</li>
</ul>
</div></div></div><br><br><hr><br>********************************************************<div id="title">1830. Minimum Number of Operations to Make String Sorted</div>
********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> （<strong>下标从 0 开始</strong>）。你需要对 <code>s</code> 执行以下操作直到它变为一个有序字符串：</p>
<ol>
<li>找到 <strong>最大下标</strong> <code>i</code> ，使得 <code>1 &lt;= i &lt; s.length</code> 且 <code>s[i] &lt; s[i - 1]</code> 。</li>
<li>找到 <strong>最大下标</strong> <code>j</code> ，使得 <code>i &lt;= j &lt; s.length</code> 且对于所有在闭区间 <code>[i, j]</code> 之间的 <code>k</code> 都有 <code>s[k] &lt; s[i - 1]</code> 。</li>
<li>交换下标为 <code>i - 1</code>​​​​ 和 <code>j</code>​​​​ 处的两个字符。</li>
<li>将下标 <code>i</code> 开始的字符串后缀反转。</li>
</ol>
<p>请你返回将字符串变成有序的最少操作次数。由于答案可能会很大，请返回它对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>s = "cba"
<b>输出：</b>5
<b>解释：</b>模拟过程如下所示：
操作 1：i=2，j=2。交换 s[1] 和 s[2] 得到 s="cab" ，然后反转下标从 2 开始的后缀字符串，得到 s="cab" 。
操作 2：i=1，j=2。交换 s[0] 和 s[2] 得到 s="bac" ，然后反转下标从 1 开始的后缀字符串，得到 s="bca" 。
操作 3：i=2，j=2。交换 s[1] 和 s[2] 得到 s="bac" ，然后反转下标从 2 开始的后缀字符串，得到 s="bac" 。
操作 4：i=1，j=1。交换 s[0] 和 s[1] 得到 s="abc" ，然后反转下标从 1 开始的后缀字符串，得到 s="acb" 。
操作 5：i=2，j=2。交换 s[1] 和 s[2] 得到 s="abc" ，然后反转下标从 2 开始的后缀字符串，得到 s="abc" 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>s = "aabaa"
<b>输出：</b>2
<b>解释：</b>模拟过程如下所示：
操作 1：i=3，j=4。交换 s[2] 和 s[4] 得到 s="aaaab" ，然后反转下标从 3 开始的后缀字符串，得到 s="aaaba" 。
操作 2：i=4，j=4。交换 s[3] 和 s[4] 得到 s="aaaab" ，然后反转下标从 4 开始的后缀字符串，得到 s="aaaab" 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>s = "cdbea"
<b>输出：</b>63</pre>
<p><strong>示例 4：</strong></p>
<pre><b>输入：</b>s = "leetcodeleetcodeleetcode"
<b>输出：</b>982157772
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3000</code></li>
<li><code>s</code>​ 只包含小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*******************************************<div id="title">1835. Find XOR Sum of All Pairs Bitwise AND</div>
*******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>列表的 <strong>异或和</strong>（<strong>XOR sum</strong>）指对所有元素进行按位 <code>XOR</code> 运算的结果。如果列表中仅有一个元素，那么其 <strong>异或和</strong> 就等于该元素。</p>
<ul>
<li>例如，<code>[1,2,3,4]</code> 的 <strong>异或和</strong> 等于 <code>1 XOR 2 XOR 3 XOR 4 = 4</code> ，而 <code>[3]</code> 的 <strong>异或和</strong> 等于 <code>3</code> 。</li>
</ul>
<p>给你两个下标 <strong>从 0 开始</strong> 计数的数组 <code>arr1</code> 和 <code>arr2</code> ，两数组均由非负整数组成。</p>
<p>根据每个 <code>(i, j)</code> 数对，构造一个由 <code>arr1[i] AND arr2[j]</code>（按位 <code>AND</code> 运算）结果组成的列表。其中 <code>0 &lt;= i &lt; arr1.length</code> 且 <code>0 &lt;= j &lt; arr2.length</code> 。</p>
<p>返回上述列表的 <strong>异或和</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>arr1 = [1,2,3], arr2 = [6,5]
<strong>输出：</strong>0
<strong>解释：</strong>列表 = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1] ，
异或和 = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>arr1 = [12], arr2 = [4]
<strong>输出：</strong>4
<strong>解释：</strong>列表 = [12 AND 4] = [4] ，异或和 = 4 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr1.length, arr2.length &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= arr1[i], arr2[j] &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">1840. Maximum Building Height</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在一座城市里，你需要建 <code>n</code> 栋新的建筑。这些新的建筑会从 <code>1</code> 到 <code>n</code> 编号排成一列。</p>
<p>这座城市对这些新建筑有一些规定：</p>
<ul>
<li>每栋建筑的高度必须是一个非负整数。</li>
<li>第一栋建筑的高度 <strong>必须</strong> 是 <code>0</code> 。</li>
<li>任意两栋相邻建筑的高度差 <strong>不能超过</strong>  <code>1</code> 。</li>
</ul>
<p>除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组 <code>restrictions</code> 的形式给出，其中 <code>restrictions[i] = [id<sub>i</sub>, maxHeight<sub>i</sub>]</code> ，表示建筑 <code>id<sub>i</sub></code> 的高度 <strong>不能超过</strong> <code>maxHeight<sub>i</sub></code> 。</p>
<p>题目保证每栋建筑在 <code>restrictions</code> 中<strong> 至多出现一次</strong> ，同时建筑 <code>1</code> <strong>不会</strong> 出现在 <code>restrictions</code> 中。</p>
<p>请你返回 <strong>最高</strong> 建筑能达到的 <strong>最高高度</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex1-1.png" style="width: 400px; height: 253px;"/>
<pre><b>输入：</b>n = 5, restrictions = [[2,1],[4,1]]
<b>输出：</b>2
<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。
我们可以使建筑高度分别为 [0,1,2,1,2] ，最高建筑的高度为 2 。</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex2.png" style="width: 500px; height: 269px;"/>
<pre><b>输入：</b>n = 6, restrictions = []
<b>输出：</b>5
<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。
我们可以使建筑高度分别为 [0,1,2,3,4,5] ，最高建筑的高度为 5 。
</pre>
<p><strong>示例 3：</strong></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex3.png" style="width: 500px; height: 187px;"/>
<pre><b>输入：</b>n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]
<b>输出：</b>5
<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。
我们可以使建筑高度分别为 [0,1,2,3,3,4,4,5,4,3] ，最高建筑的高度为 5 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10<sup>9</sup></code></li>
<li><code>0 &lt;= restrictions.length &lt;= min(n - 1, 10<sup>5</sup>)</code></li>
<li><code>2 &lt;= id<sub>i</sub> &lt;= n</code></li>
<li><code>id<sub>i</sub></code> 是 <strong>唯一的</strong> 。</li>
<li><code>0 &lt;= maxHeight<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">1847. Closest Room</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个酒店里有 <code>n</code> 个房间，这些房间用二维整数数组 <code>rooms</code> 表示，其中 <code>rooms[i] = [roomId<sub>i</sub>, size<sub>i</sub>]</code> 表示有一个房间号为 <code>roomId<sub>i</sub></code> 的房间且它的面积为 <code>size<sub>i</sub></code> 。每一个房间号 <code>roomId<sub>i</sub></code> 保证是 <strong>独一无二</strong> 的。</p>
<p>同时给你 <code>k</code> 个查询，用二维数组 <code>queries</code> 表示，其中 <code>queries[j] = [preferred<sub>j</sub>, minSize<sub>j</sub>]</code> 。第 <code>j</code> 个查询的答案是满足如下条件的房间 <code>id</code> ：</p>
<ul>
<li>房间的面积 <b>至少</b> 为 <code>minSize<sub>j</sub></code> ，且</li>
<li><code>abs(id - preferred<sub>j</sub>)</code> 的值 <strong>最小</strong> ，其中 <code>abs(x)</code> 是 <code>x</code> 的绝对值。</li>
</ul>
<p>如果差的绝对值有 <strong>相等</strong> 的，选择 <strong>最小</strong> 的 <code>id</code> 。如果 <strong>没有满足条件的房间</strong> ，答案为 <code>-1</code> 。</p>
<p>请你返回长度为 <code>k</code> 的数组 <code>answer</code> ，其中<em> </em><code>answer[j]</code> 为第 <code>j</code> 个查询的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]
<b>输出：</b>[3,-1,3]
<strong>解释：</strong>查询的答案如下：
查询 [3,1] ：房间 3 的面积为 2 ，大于等于 1 ，且号码是最接近 3 的，为 abs(3 - 3) = 0 ，所以答案为 3 。
查询 [3,3] ：没有房间的面积至少为 3 ，所以答案为 -1 。
查询 [5,2] ：房间 3 的面积为 2 ，大于等于 2 ，且号码是最接近 5 的，为 abs(3 - 5) = 2 ，所以答案为 3 。</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]
<b>输出：</b>[2,1,3]
<strong>解释：</strong>查询的答案如下：
查询 [2,3] ：房间 2 的面积为 3 ，大于等于 3 ，且号码是最接近的，为 abs(2 - 2) = 0 ，所以答案为 2 。
查询 [2,4] ：房间 1 和 3 的面积都至少为 4 ，答案为 1 因为它房间编号更小。
查询 [2,5] ：房间 3 是唯一面积大于等于 5 的，所以答案为 3 。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == rooms.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>k == queries.length</code></li>
<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
<li><code>1 &lt;= roomId<sub>i</sub>, preferred<sub>j</sub> &lt;= 10<sup>7</sup></code></li>
<li><code>1 &lt;= size<sub>i</sub>, minSize<sub>j</sub> &lt;= 10<sup>7</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>********************************************<div id="title">1851. Minimum Interval to Include Each Query</div>
********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> 表示第 <code>i</code> 个区间开始于 <code>left<sub>i</sub></code> 、结束于 <code>right<sub>i</sub></code>（包含两侧取值，<strong>闭区间</strong>）。区间的 <strong>长度</strong> 定义为区间中包含的整数数目，更正式地表达是 <code>right<sub>i</sub> - left<sub>i</sub> + 1</code> 。</p>
<p>再给你一个整数数组 <code>queries</code> 。第 <code>j</code> 个查询的答案是满足 <code>left<sub>i</sub> &lt;= queries[j] &lt;= right<sub>i</sub></code> 的 <strong>长度最小区间 <code>i</code> 的长度</strong> 。如果不存在这样的区间，那么答案是 <code>-1</code> 。</p>
<p>以数组形式返回对应查询的所有答案。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
<strong>输出：</strong>[3,3,1,4]
<strong>解释：</strong>查询处理如下：
- Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。
- Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。
- Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。
- Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]
<strong>输出：</strong>[2,-1,4,6]
<strong>解释：</strong>查询处理如下：
- Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。
- Query = 19：不存在包含 19 的区间，答案为 -1 。
- Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。
- Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>1 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt;= 10<sup>7</sup></code></li>
<li><code>1 &lt;= queries[j] &lt;= 10<sup>7</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************************<div id="title">1857. Largest Color Value in a Directed Graph</div>
*********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <strong>有向图</strong> ，它含有 <code>n</code> 个节点和 <code>m</code> 条边。节点编号从 <code>0</code> 到 <code>n - 1</code> 。</p>
<p>给你一个字符串 <code>colors</code> ，其中 <code>colors[i]</code> 是小写英文字母，表示图中第 <code>i</code> 个节点的 <b>颜色</b> （下标从 <strong>0</strong> 开始）。同时给你一个二维数组 <code>edges</code> ，其中 <code>edges[j] = [a<sub>j</sub>, b<sub>j</sub>]</code> 表示从节点 <code>a<sub>j</sub></code> 到节点 <code>b<sub>j</sub></code><sub> </sub>有一条 <strong>有向边</strong> 。</p>
<p>图中一条有效 <strong>路径</strong> 是一个点序列 <code>x<sub>1</sub> -&gt; x<sub>2</sub> -&gt; x<sub>3</sub> -&gt; ... -&gt; x<sub>k</sub></code> ，对于所有 <code>1 &lt;= i &lt; k</code> ，从 <code>x<sub>i</sub></code> 到 <code>x<sub>i+1</sub></code> 在图中有一条有向边。路径的 <strong>颜色值</strong> 是路径中 <strong>出现次数最多</strong> 颜色的节点数目。</p>
<p>请你返回给定图中有效路径里面的 <strong>最大颜色值</strong><strong> 。</strong>如果图中含有环，请返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet1.png" style="width: 400px; height: 182px;"/></p>
<pre><b>输入：</b>colors = "abaca", edges = [[0,1],[0,2],[2,3],[3,4]]
<b>输出：</b>3
<b>解释：</b>路径 0 -&gt; 2 -&gt; 3 -&gt; 4 含有 3 个颜色为 <code>"a" 的节点（上图中的红色节点）。</code>
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/04/21/leet2.png" style="width: 85px; height: 85px;"/></p>
<pre><b>输入：</b>colors = "a", edges = [[0,0]]
<b>输出：</b>-1
<b>解释：</b>从 0 到 0 有一个环。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == colors.length</code></li>
<li><code>m == edges.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= m &lt;= 10<sup>5</sup></code></li>
<li><code>colors</code> 只含有小写英文字母。</li>
<li><code>0 &lt;= a<sub>j</sub>, b<sub>j</sub> &lt; n</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">1862. Sum of Floored Pairs</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> ，请你返回所有下标对 <code>0 &lt;= i, j &lt; nums.length</code> 的 <code>floor(nums[i] / nums[j])</code> 结果之和。由于答案可能会很大，请你返回答案对<code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>
<p>函数 <code>floor()</code> 返回输入数字的整数部分。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [2,5,9]
<b>输出：</b>10
<strong>解释：</strong>
floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0
floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1
floor(5 / 2) = 2
floor(9 / 2) = 4
floor(9 / 5) = 1
我们计算每一个数对商向下取整的结果并求和得到 10 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [7,7,7,7,7,7,7]
<b>输出：</b>49
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************************************<div id="title">1866. Number of Ways to Rearrange Sticks With K Sticks Visible</div>
**************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有 <code>n</code> 根长度互不相同的木棍，长度为从 <code>1</code> 到 <code>n</code> 的整数。请你将这些木棍排成一排，并满足从左侧 <strong>可以看到</strong> <strong>恰好</strong> <code>k</code> 根木棍。从左侧 <strong>可以看到</strong> 木棍的前提是这个木棍的 <strong>左侧</strong> 不存在比它 <strong>更长的</strong> 木棍。</p>
<ul>
<li>例如，如果木棍排列为 <code>[<em><strong>1</strong></em>,<em><strong>3</strong></em>,2,<em><strong>5</strong></em>,4]</code> ，那么从左侧可以看到的就是长度分别为 <code>1</code>、<code>3</code> 、<code>5</code> 的木棍。</li>
</ul>
<p>给你 <code>n</code> 和 <code>k</code> ，返回符合题目要求的排列 <strong>数目</strong> 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 3, k = 2
<strong>输出：</strong>3
<strong>解释：</strong>[<strong><em>1</em></strong>,<strong><em>3</em></strong>,2], [<em><strong>2</strong></em>,<em><strong>3</strong></em>,1] 和 [<em><strong>2</strong></em>,1,<em><strong>3</strong></em>] 是仅有的能满足恰好 2 根木棍可以看到的排列。
可以看到的木棍已经用粗体+斜体标识。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 5, k = 5
<strong>输出：</strong>1
<strong>解释：</strong>[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>] 是唯一一种能满足全部 5 根木棍可以看到的排列。
可以看到的木棍已经用粗体+斜体标识。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 20, k = 11
<strong>输出：</strong>647427950
<strong>解释：</strong>总共有 647427950 (mod 10<sup>9 </sup>+ 7) 种能满足恰好有 11 根木棍可以看到的排列。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</div></div></div><br><br><hr><br>*********************<div id="title">1872. Stone Game VIII</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>Alice 和 Bob 玩一个游戏，两人轮流操作， <strong>Alice 先手</strong> 。</p>
<p>总共有 <code>n</code> 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 <strong>大于 1</strong> ，他将执行以下操作：</p>
<ol>
<li>选择一个整数 <code>x &gt; 1</code> ，并且 <strong>移除</strong> 最左边的 <code>x</code> 个石子。</li>
<li>将<strong> 移除</strong> 的石子价值之 <strong>和</strong> 累加到该玩家的分数中。</li>
<li>将一个 <strong>新的石子</strong> 放在最左边，且新石子的值为被移除石子值之和。</li>
</ol>
<p>当只剩下 <strong>一个</strong> 石子时，游戏结束。</p>
<p>Alice 和 Bob 的 <strong>分数之差</strong> 为 <code>(Alice 的分数 - Bob 的分数)</code> 。 Alice 的目标是<strong> 最大化</strong> 分数差，Bob 的目标是 <strong>最小化</strong> 分数差。</p>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>stones</code> ，其中 <code>stones[i]</code> 是 <strong>从左边起</strong> 第 <code>i</code> 个石子的价值。请你返回在双方都采用 <strong>最优</strong> 策略的情况下，Alice 和 Bob 的 <strong>分数之差</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>stones = [-1,2,-3,4,-5]
<b>输出：</b>5
<strong>解释：</strong>
- Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。
- Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。
两者分数之差为 2 - (-3) = 5 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>stones = [7,-6,5,10,5,-2,-6]
<b>输出：</b>13
<b>解释：</b>
- Alice 移除所有石子，得分增加 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 ，并且将一个价值为 13 的石子放在最左边。stones = [13] 。
两者分数之差为 13 - 0 = 13 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>stones = [-10,-12]
<b>输出：</b>-22
<strong>解释：</strong>
- Alice 只有一种操作，就是移除所有石子。得分增加 (-10) + (-12) = -22 ，并且将一个价值为 -22 的石子放在最左边。stones = [-22] 。
两者分数之差为 (-22) - 0 = -22 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == stones.length</code></li>
<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>-10<sup>4</sup> &lt;= stones[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***********************************<div id="title">1879. Minimum XOR Sum of Two Arrays</div>
***********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们长度都为 <code>n</code> 。</p>
<p>两个数组的 <strong>异或值之和</strong> 为 <code>(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])</code> （<strong>下标从 0 开始</strong>）。</p>
<ul>
<li>比方说，<code>[1,2,3]</code> 和 <code>[3,2,1]</code> 的 <strong>异或值之和</strong> 等于 <code>(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4</code> 。</li>
</ul>
<p>请你将 <code>nums2</code> 中的元素重新排列，使得 <strong>异或值之和</strong> <strong>最小</strong> 。</p>
<p>请你返回重新排列之后的 <strong>异或值之和</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums1 = [1,2], nums2 = [2,3]
<b>输出：</b>2
<b>解释：</b>将 <code>nums2</code> 重新排列得到 <code>[3,2] 。</code>
异或值之和为 (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2 。</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums1 = [1,0,3], nums2 = [5,3,4]
<b>输出：</b>8
<b>解释：</b>将 <code>nums2 重新排列得到</code> <code>[5,4,3] 。</code>
异或值之和为 (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length</code></li>
<li><code>n == nums2.length</code></li>
<li><code>1 &lt;= n &lt;= 14</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>************************************************<div id="title">1883. Minimum Skips to Arrive at Meeting On Time</div>
************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数 <code>hoursBefore</code> ，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经 <code>n</code> 条道路。道路的长度用一个长度为 <code>n</code> 的整数数组 <code>dist</code> 表示，其中 <code>dist[i]</code> 表示第 <code>i</code> 条道路的长度（单位：<strong>千米</strong>）。另给你一个整数 <code>speed</code> ，表示你在道路上前进的速度（单位：<strong>千米每小时</strong>）。</p>
<p>当你通过第 <code>i</code> 条路之后，就必须休息并等待，直到 <strong>下一个整数小时</strong> 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。</p>
<ul>
<li>例如，如果你通过一条道路用去 <code>1.4</code> 小时，那你必须停下来等待，到 <code>2</code> 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 <code>2</code> 小时，就无需等待，可以直接继续。</li>
</ul>
<p>然而，为了能准时到达，你可以选择 <strong>跳过</strong> 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。</p>
<ul>
<li>例如，假设通过第 <code>1</code> 条道路用去 <code>1.4</code> 小时，且通过第 <code>2</code> 条道路用去 <code>0.6</code> 小时。跳过第 <code>1</code> 条道路的休息时间意味着你将会在恰好 <code>2</code> 小时完成通过第 <code>2</code> 条道路，且你能够立即开始通过第 <code>3</code> 条道路。</li>
</ul>
<p>返回准时抵达会议现场所需要的 <strong>最小跳过次数</strong> ，如果 <strong>无法准时参会</strong> ，返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>dist = [1,3,2], speed = 4, hoursBefore = 2
<strong>输出：</strong>1
<strong>解释：</strong>
不跳过任何休息时间，你将用 (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 小时才能抵达会议现场。
可以跳过第 1 次休息时间，共用 ((1/4 + <strong>0</strong>) + (3/4 + 0)) + (2/4) = 1.5 小时抵达会议现场。
注意，第 2 次休息时间缩短为 0 ，由于跳过第 1 次休息时间，你是在整数小时处完成通过第 2 条道路。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>dist = [7,3,5,5], speed = 2, hoursBefore = 10
<strong>输出：</strong>2
<strong>解释：</strong>
不跳过任何休息时间，你将用 (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 小时才能抵达会议现场。
可以跳过第 1 次和第 3 次休息时间，共用 ((7/2 + <strong>0</strong>) + (3/2 + 0)) + ((5/2 + <strong>0</strong>) + (5/2)) = 10 小时抵达会议现场。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>dist = [7,3,5,5], speed = 1, hoursBefore = 10
<strong>输出：</strong>-1
<strong>解释：</strong>即使跳过所有的休息时间，也无法准时参加会议。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == dist.length</code></li>
<li><code>1 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= dist[i] &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= speed &lt;= 10<sup>6</sup></code></li>
<li><code>1 &lt;= hoursBefore &lt;= 10<sup>7</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">1889. Minimum Space Wasted From Packaging</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你 <code>n</code> 个包裹，你需要把它们装在箱子里，<strong>每个箱子装一个包裹</strong>。总共有 <code>m</code> 个供应商提供 <strong>不同尺寸</strong> 的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸 <strong>小于等于</strong> 一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。</p>
<p>包裹的尺寸用一个整数数组 <code>packages</code> 表示，其中 <code>packages[i]</code> 是第 <code>i</code> 个包裹的尺寸。供应商用二维数组 <code>boxes</code> 表示，其中 <code>boxes[j]</code> 是第 <code>j</code> 个供应商提供的所有箱子尺寸的数组。</p>
<p>你想要选择 <strong>一个供应商</strong> 并只使用该供应商提供的箱子，使得 <strong>总浪费空间最小</strong> 。对于每个装了包裹的箱子，我们定义 <strong>浪费的</strong> 空间等于 <code>箱子的尺寸 - 包裹的尺寸</code> 。<strong>总浪费空间</strong> 为 <strong>所有</strong> 箱子中浪费空间的总和。</p>
<ul>
<li>比方说，如果你想要用尺寸数组为 <code>[4,8]</code> 的箱子装下尺寸为 <code>[2,3,5]</code> 的包裹，你可以将尺寸为 <code>2</code> 和 <code>3</code> 的两个包裹装入两个尺寸为 <code>4</code> 的箱子中，同时把尺寸为 <code>5</code> 的包裹装入尺寸为 <code>8</code> 的箱子中。总浪费空间为 <code>(4-2) + (4-3) + (8-5) = 6</code> 。</li>
</ul>
<p>请你选择 <strong>最优</strong> 箱子供应商，使得 <strong>总浪费空间最小</strong> 。如果 <strong>无法</strong> 将所有包裹放入箱子中，请你返回 <code>-1</code> 。由于答案可能会 <strong>很大</strong> ，请返回它对<strong> </strong><code>10<sup>9</sup> + 7</code> <b>取余</b> 的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>packages = [2,3,5], boxes = [[4,8],[2,8]]
<b>输出：</b>6
<b>解释：</b>选择第一个供应商最优，用两个尺寸为 4 的箱子和一个尺寸为 8 的箱子。
总浪费空间为 (4-2) + (4-3) + (8-5) = 6 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]
<b>输出：</b>-1
<b>解释：</b>没有箱子能装下尺寸为 5 的包裹。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]
<b>输出：</b>9
<b>解释：</b>选择第三个供应商最优，用两个尺寸为 5 的箱子，两个尺寸为 10 的箱子和两个尺寸为 14 的箱子。
总浪费空间为 (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == packages.length</code></li>
<li><code>m == boxes.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= m &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= packages[i] &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= boxes[j].length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= boxes[j][k] &lt;= 10<sup>5</sup></code></li>
<li><code>sum(boxes[j].length) &lt;= 10<sup>5</sup></code></li>
<li><code>boxes[j]</code> 中的元素 <strong>互不相同</strong> 。</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************************<div id="title">1896. Minimum Cost to Change the Final Value of Expression</div>
**********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <strong>有效的</strong> 布尔表达式，用字符串 <code>expression</code> 表示。这个字符串包含字符 <code>'1'</code>，<code>'0'</code>，<code>'&amp;'</code>（按位 <strong>与</strong> 运算），<code>'|'</code>（按位 <strong>或</strong> 运算），<code>'('</code> 和 <code>')'</code> 。</p>
<ul>
<li>比方说，<code>"()1|1"</code> 和 <code>"(1)&amp;()"</code> <strong>不是有效</strong> 布尔表达式。而 <code>"1"</code>， <code>"(((1))|(0))"</code> 和 <code>"1|(0&amp;(1))"</code> 是 <strong>有效</strong> 布尔表达式。</li>
</ul>
<p>你的目标是将布尔表达式的 <strong>值</strong> <strong>反转 </strong>（也就是将 <code>0</code> 变为 <code>1</code> ，或者将 <code>1</code> 变为 <code>0</code>），请你返回达成目标需要的 <strong>最少操作</strong> 次数。</p>
<ul>
<li>比方说，如果表达式 <code>expression = "1|1|(0&amp;0)&amp;1"</code> ，它的 <strong>值</strong> 为 <code>1|1|(0&amp;0)&amp;1 = 1|1|0&amp;1 = 1|0&amp;1 = 1&amp;1 = 1</code> 。我们想要执行操作将 <strong>新的</strong> 表达式的值变成 <code>0</code> 。</li>
</ul>
<p>可执行的 <strong>操作</strong> 如下：</p>
<ul>
<li>将一个 <code>'1'</code> 变成一个 <code>'0'</code> 。</li>
<li>将一个 <code>'0'</code> 变成一个 <code>'1'</code> 。</li>
<li>将一个 <code>'&amp;'</code> 变成一个 <code>'|'</code> 。</li>
<li>将一个 <code>'|'</code> 变成一个 <code>'&amp;'</code> 。</li>
</ul>
<p><strong>注意：</strong><code>'&amp;'</code> 的 <strong>运算优先级</strong> 与 <code>'|'</code> <strong>相同</strong> 。计算表达式时，括号优先级 <strong>最高</strong> ，然后按照 <strong>从左到右</strong> 的顺序运算。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>expression = "1&amp;(0|1)"
<b>输出：</b>1
<b>解释：</b>我们可以将 "1&amp;(0<strong>|</strong>1)" 变成 "1&amp;(0<strong>&amp;</strong>1)" ，执行的操作为将一个 '|' 变成一个 '&amp;' ，执行了 1 次操作。
新表达式的值为 0 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>expression = "(0&amp;0)&amp;(0&amp;0&amp;0)"
<b>输出：</b>3
<b>解释：</b>我们可以将 "(0<strong>&amp;0</strong>)<strong>&amp;</strong>(0&amp;0&amp;0)" 变成 "(0<strong>|1</strong>)<strong>|</strong>(0&amp;0&amp;0)" ，执行了 3 次操作。
新表达式的值为 1 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>expression = "(0|(1|0&amp;1))"
<b>输出：</b>1
<b>解释：</b>我们可以将 "(0|(<strong>1</strong>|0&amp;1))" 变成 "(0|(<strong>0</strong>|0&amp;1))" ，执行了 1 次操作。
新表达式的值为 0 。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= expression.length &lt;= 10<sup>5</sup></code></li>
<li><code>expression</code> 只包含 <code>'1'</code>，<code>'0'</code>，<code>'&amp;'</code>，<code>'|'</code>，<code>'('</code> 和 <code>')'</code></li>
<li>所有括号都有与之匹配的对应括号。</li>
<li>不会有空的括号（也就是说 <code>"()"</code> 不是 <code>expression</code> 的子字符串）。</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************************<div id="title">1900. The Earliest and Latest Rounds Where Players Compete</div>
**********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><code>n</code> 名运动员参与一场锦标赛，所有运动员站成一排，并根据 <strong>最开始的</strong> 站位从 <code>1</code> 到 <code>n</code> 编号（运动员 <code>1</code> 是这一排中的第一个运动员，运动员 <code>2</code> 是第二个运动员，依此类推）。</p>
<p>锦标赛由多个回合组成（从回合 <code>1</code> 开始）。每一回合中，这一排从前往后数的第 <code>i</code> 名运动员需要与从后往前数的第 <code>i</code> 名运动员比拼，获胜者将会进入下一回合。如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。</p>
<ul>
<li>例如，当前回合中，运动员 <code>1, 2, 4, 6, 7</code> 站成一排

	<ul>
<li>运动员 <code>1</code> 需要和运动员 <code>7</code> 比拼</li>
<li>运动员 <code>2</code> 需要和运动员 <code>6</code> 比拼</li>
<li>运动员 <code>4</code> 轮空晋级下一回合</li>
</ul>
</li>
</ul>
<p>每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。</p>
<p>编号为 <code>firstPlayer</code> 和 <code>secondPlayer</code> 的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以 <strong>裁定</strong> 谁是这一回合的获胜者。</p>
<p>给你三个整数 <code>n</code>、<code>firstPlayer</code> 和 <code>secondPlayer</code> 。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的 <strong>最早</strong> 回合数和 <strong>最晚</strong> 回合数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 11, firstPlayer = 2, secondPlayer = 4
<strong>输出：</strong>[3,4]
<strong>解释：</strong>
一种能够产生最早回合数的情景是：
回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
回合 2：2, 3, 4, 5, 6, 11
回合 3：2, 3, 4
一种能够产生最晚回合数的情景是：
回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
回合 2：1, 2, 3, 4, 5, 6
回合 3：1, 2, 4
回合 4：2, 4
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 5, firstPlayer = 1, secondPlayer = 5
<strong>输出：</strong>[1,1]
<strong>解释：</strong>两名最佳运动员 1 和 5 将会在回合 1 进行比拼。
不存在使他们在其他回合进行比拼的可能。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 28</code></li>
<li><code>1 &lt;= firstPlayer &lt; secondPlayer &lt;= n</code></li>
</ul>
</div></div></div><br><br><hr><br>********************************<div id="title">1912. Design Movie Rental System</div>
********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你有一个电影租借公司和 <code>n</code> 个电影商店。你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。同时系统还能生成一份当前被借出电影的报告。</p>
<p>所有电影用二维整数数组 <code>entries</code> 表示，其中 <code>entries[i] = [shop<sub>i</sub>, movie<sub>i</sub>, price<sub>i</sub>]</code> 表示商店 <code>shop<sub>i</sub></code> 有一份电影 <code>movie<sub>i</sub></code> 的拷贝，租借价格为 <code>price<sub>i</sub></code> 。每个商店有 <strong>至多一份</strong> 编号为 <code>movie<sub>i</sub></code> 的电影拷贝。</p>
<p>系统需要支持以下操作：</p>
<ul>
<li><strong>Search：</strong>找到拥有指定电影且 <strong>未借出</strong> 的商店中 <strong>最便宜的 5 个</strong> 。商店需要按照 <strong>价格</strong> 升序排序，如果价格相同，则 <code>shop<sub>i</sub></code> <strong>较小</strong> 的商店排在前面。如果查询结果少于 5 个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。</li>
<li><strong>Rent：</strong>从指定商店借出指定电影，题目保证指定电影在指定商店 <strong>未借出</strong> 。</li>
<li><strong>Drop：</strong>在指定商店返还 <strong>之前已借出</strong> 的指定电影。</li>
<li><strong>Report：</strong>返回 <strong>最便宜的 5 部已借出电影</strong> （可能有重复的电影 ID），将结果用二维列表 <code>res</code> 返回，其中 <code>res[j] = [shop<sub>j</sub>, movie<sub>j</sub>]</code> 表示第 <code>j</code> 便宜的已借出电影是从商店 <code>shop<sub>j</sub></code> 借出的电影 <code>movie<sub>j</sub></code> 。<code>res</code> 中的电影需要按 <strong>价格</strong> 升序排序；如果价格相同，则<strong> </strong><code>shop<sub>j</sub></code> <strong>较小</strong> 的排在前面；如果仍然相同，则 <code>movie<sub>j</sub></code> <strong>较小 </strong>的排在前面。如果当前借出的电影小于 5 部，则将它们全部返回。如果当前没有借出电影，则返回一个空的列表。</li>
</ul>
<p>请你实现 <code>MovieRentingSystem</code> 类：</p>
<ul>
<li><code>MovieRentingSystem(int n, int[][] entries)</code> 将 <code>MovieRentingSystem</code> 对象用 <code>n</code> 个商店和 <code>entries</code> 表示的电影列表初始化。</li>
<li><code>List&lt;Integer&gt; search(int movie)</code> 如上所述，返回 <strong>未借出</strong> 指定 <code>movie</code> 的商店列表。</li>
<li><code>void rent(int shop, int movie)</code> 从指定商店 <code>shop</code> 借出指定电影 <code>movie</code> 。</li>
<li><code>void drop(int shop, int movie)</code> 在指定商店 <code>shop</code> 返还之前借出的电影 <code>movie</code> 。</li>
<li><code>List&lt;List&lt;Integer&gt;&gt; report()</code> 如上所述，返回最便宜的 <strong>已借出</strong> 电影列表。</li>
</ul>
<p><strong>注意：</strong>测试数据保证 <code>rent</code> 操作中指定商店拥有 <strong>未借出 </strong>的指定电影，且 <code>drop</code> 操作指定的商店 <strong>之前已借出</strong> 指定电影。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>
["MovieRentingSystem", "search", "rent", "rent", "report", "drop", "search"]
[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]
<strong>输出：</strong>
[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]

<strong>解释：</strong>
MovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);
movieRentingSystem.search(1);  // 返回 [1, 0, 2] ，商店 1，0 和 2 有未借出的 ID 为 1 的电影。商店 1 最便宜，商店 0 和 2 价格相同，所以按商店编号排序。
movieRentingSystem.rent(0, 1); // 从商店 0 借出电影 1 。现在商店 0 未借出电影编号为 [2,3] 。
movieRentingSystem.rent(1, 2); // 从商店 1 借出电影 2 。现在商店 1 未借出的电影编号为 [1] 。
movieRentingSystem.report();   // 返回 [[0, 1], [1, 2]] 。商店 0 借出的电影 1 最便宜，然后是商店 1 借出的电影 2 。
movieRentingSystem.drop(1, 2); // 在商店 1 返还电影 2 。现在商店 1 未借出的电影编号为 [1,2] 。
movieRentingSystem.search(2);  // 返回 [0, 1] 。商店 0 和 1 有未借出的 ID 为 2 的电影。商店 0 最便宜，然后是商店 1 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 3 * 10<sup>5</sup></code></li>
<li><code>1 &lt;= entries.length &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= shop<sub>i</sub> &lt; n</code></li>
<li><code>1 &lt;= movie<sub>i</sub>, price<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
<li>每个商店 <strong>至多</strong> 有一份电影 <code>movie<sub>i</sub></code> 的拷贝。</li>
<li><code>search</code>，<code>rent</code>，<code>drop</code> 和 <code>report</code> 的调用 <strong>总共</strong> 不超过 <code>10<sup>5</sup></code> 次。</li>
</ul>
</div></div></div><br><br><hr><br>************************************************<div id="title">1916. Count Ways to Build Rooms in an Ant Colony</div>
************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你是一只蚂蚁，负责为蚁群构筑 <code>n</code> 间编号从 <code>0</code> 到 <code>n-1</code> 的新房间。给你一个 <strong>下标从 0 开始</strong> 且长度为 <code>n</code> 的整数数组 <code>prevRoom</code> 作为扩建计划。其中，<code>prevRoom[i]</code> 表示在构筑房间 <code>i</code> 之前，你必须先构筑房间 <code>prevRoom[i]</code> ，并且这两个房间必须 <strong>直接</strong> 相连。房间 <code>0</code> 已经构筑完成，所以 <code>prevRoom[0] = -1</code> 。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 <code>0</code> 可以访问到每个房间。</p>
<p>你一次只能构筑 <strong>一个</strong> 房间。你可以在 <strong>已经构筑好的</strong> 房间之间自由穿行，只要这些房间是 <strong>相连的</strong> 。如果房间 <code>prevRoom[i]</code> 已经构筑完成，那么你就可以构筑房间 <code>i</code>。</p>
<p>返回你构筑所有房间的 <strong>不同顺序的数目</strong> 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/19/d1.JPG" style="width: 200px; height: 212px;"/>
<pre><strong>输入：</strong><code>prevRoom</code> = [-1,0,1]
<strong>输出：</strong>1
<strong>解释：</strong>仅有一种方案可以完成所有房间的构筑：0 → 1 → 2
</pre>
<p><strong>示例 2：</strong></p>
<strong><img alt="" src="https://assets.leetcode.com/uploads/2021/06/19/d2.JPG" style="width: 200px; height: 239px;"/></strong>
<pre><strong>输入：</strong><code>prevRoom</code> = [-1,0,0,1,2]
<strong>输出：</strong>6
<strong>解释：
</strong>有 6 种不同顺序：
0 → 1 → 3 → 2 → 4
0 → 2 → 4 → 1 → 3
0 → 1 → 2 → 3 → 4
0 → 1 → 2 → 4 → 3
0 → 2 → 1 → 3 → 4
0 → 2 → 1 → 4 → 3
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == prevRoom.length</code></li>
<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>prevRoom[0] == -1</code></li>
<li>对于所有的 <code>1 &lt;= i &lt; n</code> ，都有 <code>0 &lt;= prevRoom[i] &lt; n</code></li>
<li>题目保证所有房间都构筑完成后，从房间 <code>0</code> 可以访问到每个房间</li>
</ul>
</div></div></div><br><br><hr><br>****************************<div id="title">1923. Longest Common Subpath</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个国家由 <code>n</code> 个编号为 <code>0</code> 到 <code>n - 1</code> 的城市组成。在这个国家里，<strong>每两个</strong> 城市之间都有一条道路连接。</p>
<p>总共有 <code>m</code> 个编号为 <code>0</code> 到 <code>m - 1</code> 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 <strong>重复</strong> 出现，但同一个城市在一条路径中不会连续出现。</p>
<p>给你一个整数 <code>n</code> 和二维数组 <code>paths</code> ，其中 <code>paths[i]</code> 是一个整数数组，表示第 <code>i</code> 个朋友走过的路径，请你返回 <strong>每一个</strong> 朋友都走过的 <strong>最长公共子路径</strong> 的长度，如果不存在公共子路径，请你返回 <code>0</code> 。</p>
<p>一个 <strong>子路径</strong> 指的是一条路径中连续的城市序列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>n = 5, paths = [[0,1,<strong>2,3</strong>,4],
                     [<strong>2,3</strong>,4],
                     [4,0,1,<strong>2,3</strong>]]
<b>输出：</b>2
<b>解释：</b>最长公共子路径为 [2,3] 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>n = 3, paths = [[0],[1],[2]]
<b>输出：</b>0
<b>解释：</b>三条路径没有公共子路径。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>n = 5, paths = [[<strong>0</strong>,1,2,3,4],
                     [4,3,2,1,<strong>0</strong>]]
<b>输出：</b>1
<b>解释：</b>最长公共子路径为 [0]，[1]，[2]，[3] 和 [4] 。它们长度都为 1 。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>m == paths.length</code></li>
<li><code>2 &lt;= m &lt;= 10<sup>5</sup></code></li>
<li><code>sum(paths[i].length) &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= paths[i][j] &lt; n</code></li>
<li><code>paths[i]</code> 中同一个城市不会连续重复出现。</li>
</ul>
</div></div></div><br><br><hr><br>***********************************************<div id="title">1928. Minimum Cost to Reach Destination in Time</div>
***********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个国家有 <code>n</code> 个城市，城市编号为 <code>0</code> 到 <code>n - 1</code> ，题目保证 <strong>所有城市</strong> 都由双向道路 <b>连接在一起</b> 。道路由二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> 表示城市 <code>x<sub>i</sub></code> 和 <code>y<sub>i</sub></code> 之间有一条双向道路，耗费时间为 <code>time<sub>i</sub></code> 分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。</p>
<p>每次经过一个城市时，你需要付通行费。通行费用一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的整数数组 <code>passingFees</code> 表示，其中 <code>passingFees[j]</code> 是你经过城市 <code>j</code> 需要支付的费用。</p>
<p>一开始，你在城市 <code>0</code> ，你想要在 <code>maxTime</code> <strong>分钟以内</strong> （包含 <code>maxTime</code> 分钟）到达城市 <code>n - 1</code> 。旅行的 <strong>费用</strong> 为你经过的所有城市 <strong>通行费之和</strong> （<strong>包括</strong> 起点和终点城市的通行费）。</p>
<p>给你 <code>maxTime</code>，<code>edges</code> 和 <code>passingFees</code> ，请你返回完成旅行的 <strong>最小费用</strong> ，如果无法在 <code>maxTime</code> 分钟以内完成旅行，请你返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/leetgraph1-1.png" style="width: 371px; height: 171px;"/></p>
<pre><b>输入：</b>maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
<b>输出：</b>11
<b>解释：</b>最优路径为 0 -&gt; 1 -&gt; 2 -&gt; 5 ，总共需要耗费 30 分钟，需要支付 11 的通行费。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/copy-of-leetgraph1-1.png" style="width: 371px; height: 171px;"/></strong></p>
<pre><b>输入：</b>maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
<b>输出：</b>48
<b>解释：</b>最优路径为 0 -&gt; 3 -&gt; 4 -&gt; 5 ，总共需要耗费 26 分钟，需要支付 48 的通行费。
你不能选择路径 0 -&gt; 1 -&gt; 2 -&gt; 5 ，因为这条路径耗费的时间太长。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
<b>输出：</b>-1
<b>解释：</b>无法在 25 分钟以内从城市 0 到达城市 5 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= maxTime &lt;= 1000</code></li>
<li><code>n == passingFees.length</code></li>
<li><code>2 &lt;= n &lt;= 1000</code></li>
<li><code>n - 1 &lt;= edges.length &lt;= 1000</code></li>
<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>
<li><code>1 &lt;= time<sub>i</sub> &lt;= 1000</code></li>
<li><code>1 &lt;= passingFees[j] &lt;= 1000</code> </li>
<li>图中两个节点之间可能有多条路径。</li>
<li>图中不含有自环。</li>
</ul>
</div></div></div><br><br><hr><br>*************************************************<div id="title">1931. Painting a Grid With Three Different Colors</div>
*************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个整数 <code>m</code> 和 <code>n</code> 。构造一个 <code>m x n</code> 的网格，其中每个单元格最开始是白色。请你用 <strong>红、绿、蓝</strong> 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p>
<p>涂色方案需要满足：<strong>不存在相邻两个单元格颜色相同的情况</strong> 。返回网格涂色的方法数。因为答案可能非常大， 返回 <strong>对 </strong><code>10<sup>9</sup> + 7</code><strong> 取余</strong> 的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/22/colorthegrid.png" style="width: 200px; height: 50px;"/>
<pre><strong>输入：</strong>m = 1, n = 1
<strong>输出：</strong>3
<strong>解释：</strong>如上图所示，存在三种可能的涂色方案。
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/22/copy-of-colorthegrid.png" style="width: 321px; height: 121px;"/>
<pre><strong>输入：</strong>m = 1, n = 2
<strong>输出：</strong>6
<strong>解释：</strong>如上图所示，存在六种可能的涂色方案。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>m = 5, n = 5
<strong>输出：</strong>580986
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m &lt;= 5</code></li>
<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************<div id="title">1932. Merge BSTs to Create Single BST</div>
*************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你 <code>n</code> 个 <strong>二叉搜索树的根节点</strong> ，存储在数组 <code>trees</code> 中（<strong>下标从 0 开始</strong>），对应 <code>n</code> 棵不同的二叉搜索树。<code>trees</code> 中的每棵二叉搜索树 <strong>最多有 3 个节点</strong> ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p>
<ul>
<li>选择两个 <strong>不同的</strong> 下标 <code>i</code> 和 <code>j</code> ，要求满足在 <code>trees[i]</code> 中的某个 <strong>叶节点</strong> 的值等于 <code>trees[j]</code> 的 <strong>根节点的值</strong> 。</li>
<li>用 <code>trees[j]</code> 替换 <code>trees[i]</code> 中的那个叶节点。</li>
<li>从 <code>trees</code> 中移除 <code>trees[j]</code> 。</li>
</ul>
<p>如果在执行 <code>n - 1</code> 次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 <strong>根节点</strong> ；如果无法构造一棵有效的二叉搜索树<em>，</em>返回<em> </em><code>null</code> 。</p>
<p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p>
<ul>
<li>任意节点的左子树中的值都 <strong>严格小于</strong> 此节点的值。</li>
<li>任意节点的右子树中的值都 <strong>严格大于</strong> 此节点的值。</li>
</ul>
<p>叶节点是不含子节点的节点。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d1.png"/>
<pre><strong>输入：</strong>trees = [[2,1],[3,2,5],[5,4]]
<strong>输出：</strong>[3,2,5,1,null,4]
<strong>解释：</strong>
第一步操作中，选出 i=1 和 j=0 ，并将 trees[0] 合并到 trees[1] 中。
删除 trees[0] ，trees = [[3,2,5,1],[5,4]] 。
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram.png"/>
在第二步操作中，选出 i=0 和 j=1 ，将 trees[1] 合并到 trees[0] 中。
删除 trees[1] ，trees = [[3,2,5,1,null,4]] 。
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram-2.png"/>
结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d2.png"/>
<pre><strong>输入：</strong>trees = [[5,3,8],[3,2,6]]
<strong>输出：</strong>[]
<strong>解释：</strong>
选出 i=0 和 j=1 ，然后将 trees[1] 合并到 trees[0] 中。
删除 trees[1] ，trees = [[5,3,8,2,6]] 。
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram-3.png"/>
结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 null 。
</pre>
<p><strong>示例 3：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d3.png"/>
<pre><strong>输入：</strong>trees = [[5,4],[3]]
<strong>输出：</strong>[]
<strong>解释：</strong>无法执行任何操作。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == trees.length</code></li>
<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
<li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li>
<li>输入数据的每个节点可能有子节点但不存在子节点的子节点</li>
<li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li>
<li>输入中的所有树都是 <strong>有效的二叉树搜索树</strong> 。</li>
<li><code>1 &lt;= TreeNode.val &lt;= 5 * 10<sup>4</sup></code>.</li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">1938. Maximum Genetic Difference Query</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一棵 <code>n</code> 个节点的有根树，节点编号从 <code>0</code> 到 <code>n - 1</code> 。每个节点的编号表示这个节点的 <strong>独一无二的基因值</strong> （也就是说节点 <code>x</code> 的基因值为 <code>x</code>）。两个基因值的 <strong>基因差</strong> 是两者的 <strong>异或和</strong> 。给你整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。如果节点 <code>x</code> 是树的 <strong>根</strong> ，那么 <code>parents[x] == -1</code> 。</p>
<p>给你查询数组 <code>queries</code> ，其中 <code>queries[i] = [node<sub>i</sub>, val<sub>i</sub>]</code> 。对于查询 <code>i</code> ，请你找到 <code>val<sub>i</sub></code> 和 <code>p<sub>i</sub></code> 的 <strong>最大基因差</strong> ，其中 <code>p<sub>i</sub></code> 是节点 <code>node<sub>i</sub></code> 到根之间的任意节点（包含 <code>node<sub>i</sub></code> 和根节点）。更正式的，你想要最大化 <code>val<sub>i</sub> XOR p<sub>i</sub></code><sub> </sub>。</p>
<p>请你返回数组<em> </em><code>ans</code> ，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/c1.png" style="width: 118px; height: 163px;"/>
<pre><b>输入：</b>parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]
<b>输出：</b>[2,3,7]
<strong>解释：</strong>查询数组处理如下：
- [0,2]：最大基因差的对应节点为 0 ，基因差为 2 XOR 0 = 2 。
- [3,2]：最大基因差的对应节点为 1 ，基因差为 2 XOR 1 = 3 。
- [2,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/29/c2.png" style="width: 256px; height: 221px;"/>
<pre><b>输入：</b>parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]
<b>输出：</b>[6,14,7]
<strong>解释：</strong>查询数组处理如下：
- [4,6]：最大基因差的对应节点为 0 ，基因差为 6 XOR 0 = 6 。
- [1,15]：最大基因差的对应节点为 1 ，基因差为 15 XOR 1 = 14 。
- [0,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= parents.length &lt;= 10<sup>5</sup></code></li>
<li>对于每个 <strong>不是</strong> 根节点的 <code>i</code> ，有 <code>0 &lt;= parents[i] &lt;= parents.length - 1</code> 。</li>
<li><code>parents[root] == -1</code></li>
<li><code>1 &lt;= queries.length &lt;= 3 * 10<sup>4</sup></code></li>
<li><code>0 &lt;= node<sub>i</sub> &lt;= parents.length - 1</code></li>
<li><code>0 &lt;= val<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">1944. Number of Visible People in a Queue</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有 <code>n</code> 个人排成一个队列，<strong>从左到右</strong> 编号为 <code>0</code> 到 <code>n - 1</code> 。给你以一个整数数组 <code>heights</code> ，每个整数 <strong>互不相同</strong>，<code>heights[i]</code> 表示第 <code>i</code> 个人的高度。</p>
<p>一个人能 <strong>看到</strong> 他右边另一个人的条件是这两人之间的所有人都比他们两人 <strong>矮</strong> 。更正式的，第 <code>i</code> 个人能看到第 <code>j</code> 个人的条件是 <code>i &lt; j</code> 且 <code>min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code> 。</p>
<p>请你返回一个长度为 <code>n</code> 的数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer[i]</code><em> </em>是第 <code>i</code> 个人在他右侧队列中能 <strong>看到</strong> 的 <strong>人数</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/05/29/queue-plane.jpg" style="width: 600px; height: 247px;"/></p>
<pre><b>输入：</b>heights = [10,6,8,5,11,9]
<b>输出：</b>[3,1,2,1,1,0]
<strong>解释：</strong>
第 0 个人能看到编号为 1 ，2 和 4 的人。
第 1 个人能看到编号为 2 的人。
第 2 个人能看到编号为 3 和 4 的人。
第 3 个人能看到编号为 4 的人。
第 4 个人能看到编号为 5 的人。
第 5 个人谁也看不到因为他右边没人。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>heights = [5,1,2,3,10]
<b>输出：</b>[4,1,1,1,0]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == heights.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= heights[i] &lt;= 10<sup>5</sup></code></li>
<li><code>heights</code> 中所有数 <strong>互不相同</strong> 。</li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">1948. Delete Duplicate Folders in System</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组 <code>paths</code>，其中 <code>paths[i]</code> 是一个表示文件系统中第 <code>i</code> 个文件夹的绝对路径的数组。</p>
<ul>
<li>例如，<code>["one", "two", "three"]</code> 表示路径 <code>"/one/two/three"</code> 。</li>
</ul>
<p>如果两个文件夹（不需要在同一层级）包含 <strong>非空且</strong><b>相同的 </b>子文件夹 <strong>集合</strong> 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 <strong>不</strong> 需要相同。如果存在两个（或两个以上）<strong>相同</strong> 文件夹，则需要将这些文件夹和所有它们的子文件夹 <strong>标记</strong> 为待删除。</p>
<ul>
<li>例如，下面文件结构中的文件夹 <code>"/a"</code> 和 <code>"/b"</code> 相同。它们（以及它们的子文件夹）应该被 <strong>全部</strong> 标记为待删除：

	<ul>
<li><code>/a</code></li>
<li><code>/a/x</code></li>
<li><code>/a/x/y</code></li>
<li><code>/a/z</code></li>
<li><code>/b</code></li>
<li><code>/b/x</code></li>
<li><code>/b/x/y</code></li>
<li><code>/b/z</code></li>
</ul>
</li>
<li>然而，如果文件结构中还包含路径 <code>"/b/w"</code> ，那么文件夹 <code>"/a"</code> 和 <code>"/b"</code> 就不相同。注意，即便添加了新的文件夹 <code>"/b/w"</code> ，仍然认为 <code>"/a/x"</code> 和 <code>"/b/x"</code> 相同。</li>
</ul>
<p>一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 <strong>删除</strong> 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。</p>
<p>返回二维数组<em> </em><code>ans</code> ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 <strong>任意顺序</strong> 返回。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder1.jpg" style="width: 200px; height: 218px;"/>
<pre><strong>输入：</strong>paths = [["a"],["c"],["d"],["a","b"],["c","b"],["d","a"]]
<strong>输出：</strong>[["d"],["d","a"]]
<strong>解释：</strong>文件结构如上所示。
文件夹 "/a" 和 "/c"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 "b" 的空文件夹。
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder2.jpg" style="width: 200px; height: 355px;"/>
<pre><strong>输入：</strong>paths = [["a"],["c"],["a","b"],["c","b"],["a","b","x"],["a","b","x","y"],["w"],["w","y"]]
<strong>输出：</strong>[["c"],["c","b"],["a"],["a","b"]]
<strong>解释：</strong>文件结构如上所示。
文件夹 "/a/b/x" 和 "/w"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 "y" 的空文件夹。
注意，文件夹 "/a" 和 "/c" 在删除后变为相同文件夹，但这两个文件夹不会被删除，因为删除只会进行一次，且它们没有在删除前被标记。
</pre>
<p><strong>示例 3：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder3.jpg" style="width: 200px; height: 201px;"/>
<pre><strong>输入：</strong>paths = [["a","b"],["c","d"],["c"],["a"]]
<strong>输出：</strong>[["c"],["c","d"],["a"],["a","b"]]
<strong>解释：</strong>文件系统中所有文件夹互不相同。
注意，返回的数组可以按不同顺序返回文件夹路径，因为题目对顺序没有要求。
</pre>
<p><strong>示例 4：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder4_.jpg" style="width: 300px; height: 290px;"/>
<pre><strong>输入：</strong>paths = [["a"],["a","x"],["a","x","y"],["a","z"],["b"],["b","x"],["b","x","y"],["b","z"]]
<strong>输出：</strong>[]
<strong>解释：</strong>文件结构如上所示。
文件夹 "/a/x" 和 "/b/x"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 "y" 的空文件夹。
文件夹 "/a" 和 "/b"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含一个名为 "z" 的空文件夹以及上面提到的文件夹 "x" 。
</pre>
<p><strong>示例 5：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder5_.jpg" style="width: 300px; height: 282px;"/>
<pre><strong>输入：</strong>paths = [["a"],["a","x"],["a","x","y"],["a","z"],["b"],["b","x"],["b","x","y"],["b","z"],["b","w"]]
<strong>输出：</strong>[["b"],["b","w"],["b","z"],["a"],["a","z"]]
<strong>解释：</strong>本例与上例的结构基本相同，除了新增 "/b/w" 文件夹。
文件夹 "/a/x" 和 "/b/x" 仍然会被标记，但 "/a" 和 "/b" 不再被标记，因为 "/b" 中有名为 "w" 的空文件夹而 "/a" 没有。
注意，"/a/z" 和 "/b/z" 不会被标记，因为相同子文件夹的集合必须是非空集合，但这两个文件夹都是空的。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= paths[i].length &lt;= 500</code></li>
<li><code>1 &lt;= paths[i][j].length &lt;= 10</code></li>
<li><code>1 &lt;= sum(paths[i][j].length) &lt;= 2 * 10<sup>5</sup></code></li>
<li><code>path[i][j]</code> 由小写英文字母组成</li>
<li>不会存在两个路径都指向同一个文件夹的情况</li>
<li>对于不在根层级的任意文件夹，其父文件夹也会包含在输入中</li>
</ul>
</div></div></div><br><br><hr><br>******************************************<div id="title">1955. Count Number of Special Subsequences</div>
******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><strong>特殊序列</strong> 是由 <strong>正整数</strong> 个 <code>0</code> ，紧接着 <strong>正整数</strong> 个 <code>1</code> ，最后 <strong>正整数</strong> 个 <code>2</code> 组成的序列。</p>
<ul>
<li>比方说，<code>[0,1,2]</code> 和 <code>[0,0,1,1,1,2]</code> 是特殊序列。</li>
<li>相反，<code>[2,1,0]</code> ，<code>[1]</code> 和 <code>[0,1,2,0]</code> 就不是特殊序列。</li>
</ul>
<p>给你一个数组 <code>nums</code> （<strong>仅</strong> 包含整数 <code>0</code>，<code>1</code> 和 <code>2</code>），请你返回 <b>不同特殊子序列的数目</b> 。由于答案可能很大，请你将它对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>
<p>一个数组的 <strong>子序列</strong> 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 <strong>下标集合</strong> 不同，那么这两个子序列是 <strong>不同的</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [0,1,2,2]
<b>输出：</b>3
<b>解释：</b>特殊子序列为 [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,2]，[<strong>0</strong>,<strong>1</strong>,2,<strong>2</strong>] 和 [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,<strong>2</strong>] 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [2,2,0,0]
<b>输出：</b>0
<b>解释：</b>数组 [2,2,0,0] 中没有特殊子序列。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>nums = [0,1,2,0,1,2]
<b>输出：</b>7
<b>解释：</b>特殊子序列包括：
- [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,0,1,2]
- [<strong>0</strong>,<strong>1</strong>,2,0,1,<strong>2</strong>]
- [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,0,1,<strong>2</strong>]
- [<strong>0</strong>,<strong>1</strong>,2,0,<strong>1</strong>,<strong>2</strong>]
- [<strong>0</strong>,1,2,<strong>0</strong>,<strong>1</strong>,<strong>2</strong>]
- [<strong>0</strong>,1,2,0,<strong>1</strong>,<strong>2</strong>]
- [0,1,2,<strong>0</strong>,<strong>1</strong>,<strong>2</strong>]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= nums[i] &lt;= 2</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************************************<div id="title">1960. Maximum Product of the Length of Two Palindromic Substrings</div>
*****************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，你需要找到两个 <strong>不重叠</strong><strong>的回文 </strong>子字符串，它们的长度都必须为 <strong>奇数</strong> ，使得它们长度的乘积最大。</p>
<p>更正式地，你想要选择四个整数 <code>i</code> ，<code>j</code> ，<code>k</code> ，<code>l</code> ，使得 <code>0 &lt;= i &lt;= j &lt; k &lt;= l &lt; s.length</code> ，且子字符串 <code>s[i...j]</code> 和 <code>s[k...l]</code> 都是回文串且长度为奇数。<code>s[i...j]</code> 表示下标从 <code>i</code> 到 <code>j</code> 且 <strong>包含</strong> 两端下标的子字符串。</p>
<p>请你返回两个不重叠回文子字符串长度的 <strong>最大</strong> 乘积。</p>
<p><strong>回文字符串</strong> 指的是一个从前往后读和从后往前读一模一样的字符串。<strong>子字符串</strong> 指的是一个字符串中一段连续字符。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>s = "ababbb"
<b>输出：</b>9
<b>解释：</b>子字符串 "aba" 和 "bbb" 为奇数长度的回文串。乘积为 3 * 3 = 9 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>s = "zaaaxbbby"
<b>输出：</b>9
<b>解释：</b>子字符串 "aaa" 和 "bbb" 为奇数长度的回文串。乘积为 3 * 3 = 9 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
<li><code>s</code> 只包含小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*************************************************************<div id="title">1964. Find the Longest Valid Obstacle Course at Each Position</div>
*************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你打算构建一些障碍赛跑路线。给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>obstacles</code> ，数组长度为 <code>n</code> ，其中 <code>obstacles[i]</code> 表示第 <code>i</code> 个障碍的高度。</p>
<p>对于每个介于 <code>0</code> 和 <code>n - 1</code> 之间（包含 <code>0</code> 和 <code>n - 1</code>）的下标  <code>i</code> ，在满足下述条件的前提下，请你找出 <code>obstacles</code> 能构成的最长障碍路线的长度：</p>
<ul>
<li>你可以选择下标介于 <code>0</code> 到 <code>i</code> 之间（包含 <code>0</code> 和 <code>i</code>）的任意个障碍。</li>
<li>在这条路线中，必须包含第 <code>i</code> 个障碍。</li>
<li>你必须按障碍在 <code>obstacles</code> 中的<strong> </strong><strong>出现顺序</strong> 布置这些障碍。</li>
<li>除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 <strong>相同</strong> 或者 <strong>更高</strong> 。</li>
</ul>
<p>返回长度为 <code>n</code> 的答案数组 <code>ans</code> ，其中 <code>ans[i]</code> 是上面所述的下标 <code>i</code> 对应的最长障碍赛跑路线的长度。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>obstacles = [1,2,3,2]
<strong>输出：</strong>[1,2,3,3]
<strong>解释：</strong>每个位置的最长有效障碍路线是：
- i = 0: [<em><strong>1</strong></em>], [1] 长度为 1
- i = 1: [<em><strong>1</strong></em>,<em><strong>2</strong></em>], [1,2] 长度为 2
- i = 2: [<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>], [1,2,3] 长度为 3
- i = 3: [<em><strong>1</strong></em>,<em><strong>2</strong></em>,3,<em><strong>2</strong></em>], [1,2,2] 长度为 3
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>obstacles = [2,2,1]
<strong>输出：</strong>[1,2,1]
<strong>解释：</strong>每个位置的最长有效障碍路线是：
- i = 0: [<em><strong>2</strong></em>], [2] 长度为 1
- i = 1: [<em><strong>2</strong></em>,<em><strong>2</strong></em>], [2,2] 长度为 2
- i = 2: [2,2,<em><strong>1</strong></em>], [1] 长度为 1
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>obstacles = [3,1,5,6,4,2]
<strong>输出：</strong>[1,1,2,3,2,2]
<strong>解释：</strong>每个位置的最长有效障碍路线是：
- i = 0: [<em><strong>3</strong></em>], [3] 长度为 1
- i = 1: [3,<em><strong>1</strong></em>], [1] 长度为 1
- i = 2: [<em><strong>3</strong></em>,1,<em><strong>5</strong></em>], [3,5] 长度为 2, [1,5] 也是有效的障碍赛跑路线
- i = 3: [<em><strong>3</strong></em>,1,<em><strong>5</strong></em>,<em><strong>6</strong></em>], [3,5,6] 长度为 3, [1,5,6] 也是有效的障碍赛跑路线
- i = 4: [<em><strong>3</strong></em>,1,5,6,<em><strong>4</strong></em>], [3,4] 长度为 2, [1,4] 也是有效的障碍赛跑路线
- i = 5: [3,<em><strong>1</strong></em>,5,6,4,<em><strong>2</strong></em>], [1,2] 长度为 2
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == obstacles.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= obstacles[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">1970. Last Day Where You Can Still Cross</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>1</strong> 开始的二进制矩阵，其中 <code>0</code> 表示陆地，<code>1</code> 表示水域。同时给你 <code>row</code> 和 <code>col</code> 分别表示矩阵中行和列的数目。</p>
<p>一开始在第 <code>0</code> 天，<strong>整个</strong> 矩阵都是 <strong>陆地</strong> 。但每一天都会有一块新陆地被 <strong>水</strong> 淹没变成水域。给你一个下标从 <strong>1</strong> 开始的二维数组 <code>cells</code> ，其中 <code>cells[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> 表示在第 <code>i</code> 天，第 <code>r<sub>i</sub></code> 行 <code>c<sub>i</sub></code> 列（下标都是从 <strong>1</strong> 开始）的陆地会变成 <strong>水域</strong> （也就是 <code>0</code> 变成 <code>1</code> ）。</p>
<p>你想知道从矩阵最 <strong>上面</strong> 一行走到最 <strong>下面</strong> 一行，且只经过陆地格子的 <strong>最后一天</strong> 是哪一天。你可以从最上面一行的 <strong>任意</strong> 格子出发，到达最下面一行的 <strong>任意</strong> 格子。你只能沿着 <strong>四个</strong> 基本方向移动（也就是上下左右）。</p>
<p>请返回只经过陆地格子能从最 <strong>上面</strong> 一行走到最 <strong>下面</strong> 一行的 <strong>最后一天</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/1.png" style="width: 624px; height: 162px;"/>
<pre><b>输入：</b>row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
<b>输出：</b>2
<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。
可以从最上面一行到最下面一行的最后一天是第 2 天。
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/2.png" style="width: 504px; height: 178px;"/>
<pre><b>输入：</b>row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
<b>输出：</b>1
<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。
可以从最上面一行到最下面一行的最后一天是第 1 天。
</pre>
<p><strong>示例 3：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/07/27/3.png" style="width: 666px; height: 167px;"/>
<pre><b>输入：</b>row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]
<b>输出：</b>3
<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。
可以从最上面一行到最下面一行的最后一天是第 3 天。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= row, col &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>4 &lt;= row * col &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>cells.length == row * col</code></li>
<li><code>1 &lt;= r<sub>i</sub> &lt;= row</code></li>
<li><code>1 &lt;= c<sub>i</sub> &lt;= col</code></li>
<li><code>cells</code> 中的所有格子坐标都是 <strong>唯一</strong> 的。</li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">1977. Number of Ways to Separate Numbers</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你写下了若干 <strong>正整数</strong> ，并将它们连接成了一个字符串 <code>num</code> 。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 <strong>非递减</strong> 的且 <strong>没有</strong> 任何数字有前导 0 。</p>
<p>请你返回有多少种可能的 <strong>正整数数组</strong> 可以得到字符串 <code>num</code> 。由于答案可能很大，将结果对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 后返回。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>num = "327"
<b>输出：</b>2
<b>解释：</b>以下为可能的方案：
3, 27
327
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>num = "094"
<b>输出：</b>0
<b>解释：</b>不能有数字有前导 0 ，且所有数字均为正数。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>num = "0"
<b>输出：</b>0
<strong>解释：</strong>不能有数字有前导 0 ，且所有数字均为正数。
</pre>
<p><strong>示例 4：</strong></p>
<pre><b>输入：</b>num = "9999999999999"
<b>输出：</b>101
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num.length &lt;= 3500</code></li>
<li><code>num</code> 只含有数字 <code>'0'</code> 到 <code>'9'</code> 。</li>
</ul>
</div></div></div><br><br><hr><br>**********************************<div id="title">1982. Find Array Given Subset Sums</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>存在一个未知数组需要你进行还原，给你一个整数 <code>n</code> 表示该数组的长度。另给你一个数组 <code>sums</code> ，由未知数组中全部 <code>2<sup>n</sup></code> 个 <strong>子集的和</strong> 组成（子集中的元素没有特定的顺序）。</p>
<p>返回一个长度为 <code>n</code> 的数组<em> </em><code>ans</code><em> </em>表示还原得到的未知数组。如果存在 <strong>多种</strong> 答案，只需返回其中 <strong>任意一个</strong> 。</p>
<p>如果可以由数组 <code>arr</code> 删除部分元素（也可能不删除或全删除）得到数组 <code>sub</code> ，那么数组 <code>sub</code> 就是数组 <code>arr</code> 的一个<strong> 子集</strong> 。<code>sub</code> 的元素之和就是 <code>arr</code> 的一个 <strong>子集的和</strong> 。一个空数组的元素之和为 <code>0</code> 。</p>
<p><strong>注意：</strong>生成的测试用例将保证至少存在一个正确答案。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 3, sums = [-3,-2,-1,0,0,1,2,3]
<strong>输出：</strong>[1,2,-3]
<strong>解释：</strong>[1,2,-3] 能够满足给出的子集的和：
- []：和是 0
- [1]：和是 1
- [2]：和是 2
- [1,2]：和是 3
- [-3]：和是 -3
- [1,-3]：和是 -2
- [2,-3]：和是 -1
- [1,2,-3]：和是 0
注意，[1,2,-3] 的任何排列和 [-1,-2,3] 的任何排列都会被视作正确答案。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2, sums = [0,0,0,0]
<strong>输出：</strong>[0,0]
<strong>解释：</strong>唯一的正确答案是 [0,0] 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]
<strong>输出：</strong>[0,-1,4,5]
<strong>解释：</strong>[0,-1,4,5] 能够满足给出的子集的和。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 15</code></li>
<li><code>sums.length == 2<sup>n</sup></code></li>
<li><code>-10<sup>4</sup> &lt;= sums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">1987. Number of Unique Good Subsequences</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个二进制字符串 <code>binary</code> 。 <code>binary</code> 的一个 <strong>子序列</strong> 如果是 <strong>非空</strong> 的且没有 <b>前导</b> <strong>0</strong> （除非数字是 <code>"0"</code> 本身），那么它就是一个 <strong>好</strong> 的子序列。</p>
<p>请你找到 <code>binary</code> <strong>不同好子序列</strong> 的数目。</p>
<ul>
<li>比方说，如果 <code>binary = "001"</code> ，那么所有 <strong>好</strong> 子序列为 <code>["0", "0", "1"]</code> ，所以 <b>不同</b> 的好子序列为 <code>"0"</code> 和 <code>"1"</code> 。 注意，子序列 <code>"00"</code> ，<code>"01"</code> 和 <code>"001"</code> 不是好的，因为它们有前导 0 。</li>
</ul>
<p>请你返回 <code>binary</code> 中 <strong>不同好子序列</strong> 的数目。由于答案可能很大，请将它对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>
<p>一个 <strong>子序列</strong> 指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>binary = "001"
<b>输出：</b>2
<b>解释：</b>好的二进制子序列为 ["0", "0", "1"] 。
不同的好子序列为 "0" 和 "1" 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>binary = "11"
<b>输出：</b>2
<b>解释：</b>好的二进制子序列为 ["1", "1", "11"] 。
不同的好子序列为 "1" 和 "11" 。</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>binary = "101"
<b>输出：</b>5
<b>解释：</b>好的二进制子序列为 ["1", "0", "1", "10", "11", "101"] 。
不同的好子序列为 "0" ，"1" ，"10" ，"11" 和 "101" 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= binary.length &lt;= 10<sup>5</sup></code></li>
<li><code>binary</code> 只含有 <code>'0'</code> 和 <code>'1'</code> 。</li>
</ul>
</div></div></div><br><br><hr><br>********************************<div id="title">1994. The Number of Good Subsets</div>
********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 。如果 <code>nums</code> 的一个子集中，所有元素的乘积可以表示为一个或多个 <strong>互不相同的质数</strong> 的乘积，那么我们称它为 <strong>好子集</strong> 。</p>
<ul>
<li>比方说，如果 <code>nums = [1, 2, 3, 4]</code> ：

	<ul>
<li><code>[2, 3]</code> ，<code>[1, 2, 3]</code> 和 <code>[1, 3]</code> 是 <strong>好</strong> 子集，乘积分别为 <code>6 = 2*3</code> ，<code>6 = 2*3</code> 和 <code>3 = 3</code> 。</li>
<li><code>[1, 4]</code> 和 <code>[4]</code> 不是 <strong>好</strong> 子集，因为乘积分别为 <code>4 = 2*2</code> 和 <code>4 = 2*2</code> 。</li>
</ul>
</li>
</ul>
<p>请你返回 <code>nums</code> 中不同的 <strong>好</strong> 子集的数目对<em> </em><code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>
<p><code>nums</code> 中的 <strong>子集</strong> 是通过删除 <code>nums</code> 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [1,2,3,4]
<b>输出：</b>6
<b>解释：</b>好子集为：
- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [4,2,3,15]
<b>输出：</b>5
<b>解释：</b>好子集为：
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。
- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 30</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">1998. GCD Sort of an Array</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> ，你可以在 <code>nums</code> 上执行下述操作 <strong>任意次</strong> ：</p>
<ul>
<li>如果 <code>gcd(nums[i], nums[j]) &gt; 1</code> ，交换 <code>nums[i]</code> 和 <code>nums[j]</code> 的位置。其中 <code>gcd(nums[i], nums[j])</code> 是 <code>nums[i]</code> 和 <code>nums[j]</code> 的最大公因数。</li>
</ul>
<p>如果能使用上述交换方式将 <code>nums</code> 按 <strong>非递减顺序</strong> 排列，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [7,21,3]
<strong>输出：</strong>true
<strong>解释：</strong>可以执行下述操作完成对 [7,21,3] 的排序：
- 交换 7 和 21 因为 gcd(7,21) = 7 。nums = [<em><strong>21</strong></em>,<em><strong>7</strong></em>,3]
- 交换 21 和 3 因为 gcd(21,3) = 3 。nums = [<em><strong>3</strong></em>,7,<em><strong>21</strong></em>]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [5,2,6,2]
<strong>输出：</strong>false
<strong>解释：</strong>无法完成排序，因为 5 不能与其他元素交换。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [10,5,9,3,15]
<strong>输出：</strong>true
<strong>解释：</strong>
可以执行下述操作完成对 [10,5,9,3,15] 的排序：
- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [<em><strong>15</strong></em>,5,9,3,<em><strong>10</strong></em>]
- 交换 15 和 3 因为 gcd(15,3) = 3 。nums = [<em><strong>3</strong></em>,5,9,<em><strong>15</strong></em>,10]
- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [3,5,9,<em><strong>10</strong></em>,<em><strong>15</strong></em>]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
<li><code>2 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************************<div id="title">2003. Smallest Missing Genetic Value in Each Subtree</div>
****************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一棵根节点为 <code>0</code> 的 <strong>家族树</strong> ，总共包含 <code>n</code> 个节点，节点编号为 <code>0</code> 到 <code>n - 1</code> 。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。由于节点 <code>0</code> 是 <strong>根</strong> ，所以 <code>parents[0] == -1</code> 。</p>
<p>总共有 <code>10<sup>5</sup></code> 个基因值，每个基因值都用 <strong>闭区间</strong> <code>[1, 10<sup>5</sup>]</code> 中的一个整数表示。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是节点 <code>i</code> 的基因值，且基因值 <strong>互不相同</strong> 。</p>
<p>请你返回一个数组<em> </em><code>ans</code> ，长度为 <code>n</code> ，其中 <code>ans[i]</code> 是以节点 <code>i</code> 为根的子树内 <b>缺失</b> 的 <strong>最小</strong> 基因值。</p>
<p>节点 <code>x</code> 为根的 <strong>子树 </strong>包含节点 <code>x</code> 和它所有的 <strong>后代</strong> 节点。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/08/23/case-1.png" style="width: 204px; height: 167px;"/></p>
<pre><b>输入：</b>parents = [-1,0,0,2], nums = [1,2,3,4]
<b>输出：</b>[5,1,1,1]
<b>解释：</b>每个子树答案计算结果如下：
- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。
- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。
- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。
- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/08/23/case-2.png" style="width: 247px; height: 168px;"/></p>
<pre><b>输入：</b>parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]
<b>输出：</b>[7,1,1,4,2,1]
<b>解释：</b>每个子树答案计算结果如下：
- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。
- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。
- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。
- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。
- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。
- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]
<b>输出：</b>[1,1,1,1,1,1,1]
<b>解释：</b>所有子树都缺失基因值 1 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == parents.length == nums.length</code></li>
<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li>对于 <code>i != 0</code> ，满足 <code>0 &lt;= parents[i] &lt;= n - 1</code></li>
<li><code>parents[0] == -1</code></li>
<li><code>parents</code> 表示一棵合法的树。</li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
<li><code>nums[i]</code> 互不相同。</li>
</ul>
</div></div></div><br><br><hr><br>***********************************************************<div id="title">2009. Minimum Number of Operations to Make Array Continuous</div>
***********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 。每一次操作中，你可以将 <code>nums</code> 中 <strong>任意</strong> 一个元素替换成 <strong>任意 </strong>整数。</p>
<p>如果 <code>nums</code> 满足以下条件，那么它是 <strong>连续的</strong> ：</p>
<ul>
<li><code>nums</code> 中所有元素都是 <b>互不相同</b> 的。</li>
<li><code>nums</code> 中 <strong>最大</strong> 元素与 <strong>最小</strong> 元素的差等于 <code>nums.length - 1</code> 。</li>
</ul>
<p>比方说，<code>nums = [4, 2, 5, 3]</code> 是 <strong>连续的</strong> ，但是 <code>nums = [1, 2, 3, 5, 6]</code> <strong>不是连续的</strong> 。</p>
<p>请你返回使 <code>nums</code> <strong>连续</strong> 的 <strong>最少</strong> 操作次数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [4,2,5,3]
<b>输出：</b>0
<b>解释：</b>nums 已经是连续的了。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [1,2,3,5,6]
<b>输出：</b>1
<b>解释：</b>一个可能的解是将最后一个元素变为 4 。
结果数组为 [1,2,3,5,4] ，是连续数组。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>nums = [1,10,100,1000]
<b>输出：</b>3
<b>解释：</b>一个可能的解是：
- 将第二个元素变为 2 。
- 将第三个元素变为 3 。
- 将第四个元素变为 4 。
结果数组为 [1,2,3,4] ，是连续数组。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>******************************************<div id="title">2014. Longest Subsequence Repeated k Times</div>
******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个长度为 <code>n</code> 的字符串 <code>s</code> ，和一个整数 <code>k</code> 。请你找出字符串 <code>s</code> 中 <strong>重复</strong> <code>k</code> 次的 <strong>最长子序列</strong> 。</p>
<p><strong>子序列</strong> 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。</p>
<p>如果 <code>seq * k</code> 是 <code>s</code> 的一个子序列，其中 <code>seq * k</code> 表示一个由 <code>seq</code> 串联 <code>k</code> 次构造的字符串，那么就称 <code>seq</code><strong> </strong>是字符串 <code>s</code> 中一个 <strong>重复 <code>k</code> 次</strong> 的子序列。</p>
<ul>
<li>举个例子，<code>"bba"</code> 是字符串 <code>"bababcba"</code> 中的一个重复 <code>2</code> 次的子序列，因为字符串 <code>"bbabba"</code> 是由 <code>"bba"</code> 串联 <code>2</code> 次构造的，而 <code>"bbabba"</code> 是字符串 <code>"<em><strong>b</strong></em>a<em><strong>bab</strong></em>c<em><strong>ba</strong></em>"</code> 的一个子序列。</li>
</ul>
<p>返回字符串 <code>s</code> 中 <strong>重复 k 次的最长子序列</strong>  。如果存在多个满足的子序列，则返回 <strong>字典序最大</strong> 的那个。如果不存在这样的子序列，返回一个 <strong>空</strong> 字符串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="example 1" src="https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png" style="width: 457px; height: 99px;"/></p>
<pre><strong>输入：</strong>s = "letsleetcode", k = 2
<strong>输出：</strong>"let"
<strong>解释：</strong>存在两个最长子序列重复 2 次：let" 和 "ete" 。
"let" 是其中字典序最大的一个。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "bb", k = 2
<strong>输出：</strong>"b"
<strong>解释：</strong>重复 2 次的最长子序列是 "b" 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "ab", k = 2
<strong>输出：</strong>""
<strong>解释：</strong>不存在重复 2 次的最长子序列。返回空字符串。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == s.length</code></li>
<li><code>2 &lt;= k &lt;= 2000</code></li>
<li><code>2 &lt;= n &lt; k * 8</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>***************************************************<div id="title">2019. The Score of Students Solving Math Expression</div>
***************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> ，它 <strong>只</strong> 包含数字 <code>0-9</code> ，加法运算符 <code>'+'</code> 和乘法运算符 <code>'*'</code> ，这个字符串表示一个 <strong>合法</strong> 的只含有 <strong>个位数</strong><strong>数字</strong> 的数学表达式（比方说 <code>3+5*2</code>）。有 <code>n</code> 位小学生将计算这个数学表达式，并遵循如下 <strong>运算顺序</strong> ：</p>
<ol>
<li>按照 <strong>从左到右</strong> 的顺序计算 <strong>乘法</strong> ，然后</li>
<li>按照 <strong>从左到右</strong> 的顺序计算 <strong>加法</strong> 。</li>
</ol>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>answers</code> ，表示每位学生提交的答案。你的任务是给 <code>answer</code> 数组按照如下 <strong>规则</strong> 打分：</p>
<ul>
<li>如果一位学生的答案 <strong>等于</strong> 表达式的正确结果，这位学生将得到 <code>5</code> 分。</li>
<li>否则，如果答案由 <strong>一处或多处错误的运算顺序</strong> 计算得到，那么这位学生能得到 <code>2</code> 分。</li>
<li>否则，这位学生将得到 <code>0</code> 分。</li>
</ul>
<p>请你返回所有学生的分数和。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/09/17/student_solving_math.png" style="width: 678px; height: 109px;"/></p>
<pre><b>输入：</b>s = "7+3*1*2", answers = [20,13,42]
<b>输出：</b>7
<b>解释：</b>如上图所示，正确答案为 13 ，因此有一位学生得分为 5 分：[20,<em><strong>13</strong></em>,42] 。
一位学生可能通过错误的运算顺序得到结果 20 ：7+3=10，10*1=10，10*2=20 。所以这位学生得分为 2 分：[<em><strong>20</strong></em>,13,42] 。
所有学生得分分别为：[2,5,0] 。所有得分之和为 2+5+0=7 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>s = "3+5*2", answers = [13,0,10,13,13,16,16]
<b>输出：</b>19
<b>解释：</b>表达式的正确结果为 13 ，所以有 3 位学生得到 5 分：[<em><strong>13</strong></em>,0,10,<em><strong>13</strong></em>,<em><strong>13</strong></em>,16,16] 。
学生可能通过错误的运算顺序得到结果 16 ：3+5=8，8*2=16 。所以两位学生得到 2 分：[13,0,10,13,13,<em><strong>16</strong></em>,<em><strong>16</strong></em>] 。
所有学生得分分别为：[5,0,0,5,5,2,2] 。所有得分之和为 5+0+0+5+5+2+2=19 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>s = "6+0*1", answers = [12,9,6,4,8,6]
<b>输出：</b>10
<b>解释：</b>表达式的正确结果为 6 。
如果一位学生通过错误的运算顺序计算该表达式，结果仍为 6 。
根据打分规则，运算顺序错误的学生也将得到 5 分（因为他们仍然得到了正确的结果），而不是 2 分。
所有学生得分分别为：[0,0,5,0,0,5] 。所有得分之和为 10 分。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= s.length &lt;= 31</code></li>
<li><code>s</code> 表示一个只包含 <code>0-9</code> ，<code>'+'</code> 和 <code>'*'</code> 的合法表达式。</li>
<li>表达式中所有整数运算数字都在闭区间 <code>[0, 9]</code> 以内。</li>
<li><code>1 &lt;=</code> 数学表达式中所有运算符数目（<code>'+'</code> 和 <code>'*'</code>） <code>&lt;= 15</code></li>
<li>测试数据保证正确表达式结果在范围 <code>[0, 1000]</code> 以内。</li>
<li><code>n == answers.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
<li><code>0 &lt;= answers[i] &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************************<div id="title">2025. Maximum Number of Ways to Partition an Array</div>
**************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>nums</code> 。<strong>分割</strong> 数组 <code>nums</code> 的方案数定义为符合以下两个条件的 <code>pivot</code> 数目：</p>
<ul>
<li><code>1 &lt;= pivot &lt; n</code></li>
<li><code>nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]</code></li>
</ul>
<p>同时给你一个整数 <code>k</code> 。你可以将 <code>nums</code> 中 <strong>一个</strong> 元素变为 <code>k</code> 或 <strong>不改变</strong> 数组。</p>
<p>请你返回在 <strong>至多</strong> 改变一个元素的前提下，<strong>最多</strong> 有多少种方法 <strong>分割</strong> <code>nums</code> 使得上述两个条件都满足。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [2,-1,2], k = 3
<b>输出：</b>1
<b>解释：</b>一个最优的方案是将 nums[0] 改为 k 。数组变为 [<em><strong>3</strong></em>,-1,2] 。
有一种方法分割数组：
- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [0,0,0], k = 1
<b>输出：</b>2
<b>解释：</b>一个最优的方案是不改动数组。
有两种方法分割数组：
- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。
- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33
<b>输出：</b>4
<b>解释：</b>一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,<em><strong>-33</strong></em>,-20,-15,15,-16,7,19,-10,0,-13,-14] 。
有四种方法分割数组。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>-10<sup>5</sup> &lt;= k, nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************************************<div id="title">2030. Smallest K-Length Subsequence With Occurrences of a Letter</div>
****************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> ，一个整数 <code>k</code> ，一个字母 <code>letter</code> 以及另一个整数 <code>repetition</code> 。</p>
<p>返回 <code>s</code> 中长度为 <code>k</code> 且 <strong>字典序最小</strong> 的子序列，该子序列同时应满足字母 <code>letter</code> 出现<strong> 至少</strong> <code>repetition</code> 次。生成的测试用例满足 <code>letter</code> 在 <code>s</code> 中出现 <strong>至少</strong> <code>repetition</code> 次。</p>
<p><strong>子序列</strong> 是由原字符串删除一些（或不删除）字符且不改变剩余字符顺序得到的剩余字符串。</p>
<p>字符串 <code>a</code> 字典序比字符串 <code>b</code> 小的定义为：在 <code>a</code> 和 <code>b</code> 出现不同字符的第一个位置上，字符串 <code>a</code> 的字符在字母表中的顺序早于字符串 <code>b</code> 的字符。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "leet", k = 3, letter = "e", repetition = 1
<strong>输出：</strong>"eet"
<strong>解释：</strong>存在 4 个长度为 3 ，且满足字母 'e' 出现至少 1 次的子序列：
- "lee"（"<em><strong>lee</strong></em>t"）
- "let"（"<em><strong>le</strong></em>e<em><strong>t</strong></em>"）
- "let"（"<em><strong>l</strong></em>e<em><strong>et</strong></em>"）
- "eet"（"l<em><strong>eet</strong></em>"）
其中字典序最小的子序列是 "eet" 。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="example-2" src="https://assets.leetcode.com/uploads/2021/09/13/smallest-k-length-subsequence.png" style="width: 339px; height: 67px;"/></p>
<pre><strong>输入：</strong>s = "leetcode", k = 4, letter = "e", repetition = 2
<strong>输出：</strong>"ecde"
<strong>解释：</strong>"ecde" 是长度为 4 且满足字母 "e" 出现至少 2 次的字典序最小的子序列。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "bb", k = 2, letter = "b", repetition = 2
<strong>输出：</strong>"bb"
<strong>解释：</strong>"bb" 是唯一一个长度为 2 且满足字母 "b" 出现至少 2 次的子序列。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= repetition &lt;= k &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>s</code> 由小写英文字母组成</li>
<li><code>letter</code> 是一个小写英文字母，在 <code>s</code> 中至少出现 <code>repetition</code> 次</li>
</ul>
</div></div></div><br><br><hr><br>****************************************************************<div id="title">2035. Partition Array Into Two Arrays to Minimize Sum Difference</div>
****************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个长度为 <code>2 * n</code> 的整数数组。你需要将 <code>nums</code> 分成 <strong>两个</strong> 长度为 <code>n</code> 的数组，分别求出两个数组的和，并 <strong>最小化</strong> 两个数组和之 <b>差的绝对值</b> 。<code>nums</code> 中每个元素都需要放入两个数组之一。</p>
<p>请你返回 <strong>最小</strong> 的数组和之差。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="example-1" src="https://assets.leetcode.com/uploads/2021/10/02/ex1.png" style="width: 240px; height: 106px;"/></p>
<pre><b>输入：</b>nums = [3,9,7,3]
<b>输出：</b>2
<strong>解释：</strong>最优分组方案是分成 [3,9] 和 [7,3] 。
数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [-36,36]
<b>输出：</b>72
<strong>解释：</strong>最优分组方案是分成 [-36] 和 [36] 。
数组和之差的绝对值为 abs((-36) - (36)) = 72 。
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="example-3" src="https://assets.leetcode.com/uploads/2021/10/02/ex3.png" style="width: 316px; height: 106px;"/></p>
<pre><b>输入：</b>nums = [2,-1,0,4,-2,-9]
<b>输出：</b>0
<strong>解释：</strong>最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。
数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 15</code></li>
<li><code>nums.length == 2 * n</code></li>
<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***********************************************<div id="title">2040. Kth Smallest Product of Two Sorted Arrays</div>
***********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate">给你两个 <strong>从小到大排好序</strong> 且下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> 以及一个整数 <code>k</code> ，请你返回第<em> </em><code>k</code> （从 <strong>1</strong> 开始编号）小的 <code>nums1[i] * nums2[j]</code><em> </em>的乘积，其中<em> </em><code>0 &lt;= i &lt; nums1.length</code><em> </em>且<em> </em><code>0 &lt;= j &lt; nums2.length</code> 。
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums1 = [2,5], nums2 = [3,4], k = 2
<b>输出：</b>8
<b>解释：</b>第 2 小的乘积计算如下：
- nums1[0] * nums2[0] = 2 * 3 = 6
- nums1[0] * nums2[1] = 2 * 4 = 8
第 2 小的乘积为 8 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6
<b>输出：</b>0
<strong>解释：</strong>第 6 小的乘积计算如下：
- nums1[0] * nums2[1] = (-4) * 4 = -16
- nums1[0] * nums2[0] = (-4) * 2 = -8
- nums1[1] * nums2[1] = (-2) * 4 = -8
- nums1[1] * nums2[0] = (-2) * 2 = -4
- nums1[2] * nums2[0] = 0 * 2 = 0
- nums1[2] * nums2[1] = 0 * 4 = 0
第 6 小的乘积为 0 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3
<b>输出：</b>-6
<b>解释：</b>第 3 小的乘积计算如下：
- nums1[0] * nums2[4] = (-2) * 5 = -10
- nums1[0] * nums2[3] = (-2) * 4 = -8
- nums1[4] * nums2[0] = 2 * (-3) = -6
第 3 小的乘积为 -6 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>-10<sup>5</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= k &lt;= nums1.length * nums2.length</code></li>
<li><code>nums1</code> 和 <code>nums2</code> 都是从小到大排好序的。</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">2045. Second Minimum Time to Reach Destination</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>城市用一个 <strong>双向连通</strong> 图表示，图中有 <code>n</code> 个节点，从 <code>1</code> 到 <code>n</code> 编号（包含 <code>1</code> 和 <code>n</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中每个 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示一条节点 <code>u<sub>i</sub></code> 和节点 <code>v<sub>i</sub></code> 之间的双向连通边。每组节点对由 <strong>最多一条</strong> 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 <code>time</code> 分钟。</p>
<p>每个节点都有一个交通信号灯，每 <code>change</code> 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 <strong>同时</strong> 改变。你可以在 <strong>任何时候</strong> 进入某个节点，但是 <strong>只能</strong> 在节点 <strong>信号灯是绿色时</strong> 才能离开。如果信号灯是  <strong>绿色</strong> ，你 <strong>不能</strong> 在节点等待，必须离开。</p>
<p><strong>第二小的值</strong> 是 <strong>严格大于</strong> 最小值的所有值中最小的值。</p>
<ul>
<li>例如，<code>[2, 3, 4]</code> 中第二小的值是 <code>3</code> ，而 <code>[2, 2, 4]</code> 中第二小的值是 <code>4</code> 。</li>
</ul>
<p>给你 <code>n</code>、<code>edges</code>、<code>time</code> 和 <code>change</code> ，返回从节点 <code>1</code> 到节点 <code>n</code> 需要的 <strong>第二短时间</strong> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>你可以 <strong>任意次</strong> 穿过任意顶点，<strong>包括</strong> <code>1</code> 和 <code>n</code> 。</li>
<li>你可以假设在 <strong>启程时</strong> ，所有信号灯刚刚变成 <strong>绿色</strong> 。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/e1.png" style="width: 200px; height: 250px;"/>        <img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/e2.png" style="width: 200px; height: 250px;"/></p>
<pre><strong>输入：</strong>n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
<strong>输出：</strong>13
<strong>解释：</strong>
上面的左图展现了给出的城市交通图。
右图中的蓝色路径是最短时间路径。
花费的时间是：
- 从节点 1 开始，总花费时间=0
- 1 -&gt; 4：3 分钟，总花费时间=3
- 4 -&gt; 5：3 分钟，总花费时间=6
因此需要的最小时间是 6 分钟。

右图中的红色路径是第二短时间路径。
- 从节点 1 开始，总花费时间=0
- 1 -&gt; 3：3 分钟，总花费时间=3
- 3 -&gt; 4：3 分钟，总花费时间=6
- 在节点 4 等待 4 分钟，总花费时间=10
- 4 -&gt; 5：3 分钟，总花费时间=13
因此第二短时间是 13 分钟。      
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/09/29/eg2.png" style="width: 225px; height: 50px;"/></p>
<pre><strong>输入：</strong>n = 2, edges = [[1,2]], time = 3, change = 2
<strong>输出：</strong>11
<strong>解释：</strong>
最短时间路径是 1 -&gt; 2 ，总花费时间 = 3 分钟
第二短时间路径是 1 -&gt; 2 -&gt; 1 -&gt; 2 ，总花费时间 = 11 分钟</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>
<li><code>n - 1 &lt;= edges.length &lt;= min(2 * 10<sup>4</sup>, n * (n - 1) / 2)</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>
<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
<li>不含重复边</li>
<li>每个节点都可以从其他节点直接或者间接到达</li>
<li><code>1 &lt;= time, change &lt;= 10<sup>3</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">2050. Parallel Courses III</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 节课，课程编号从 <code>1</code> 到 <code>n</code> 。同时给你一个二维整数数组 <code>relations</code> ，其中 <code>relations[j] = [prevCourse<sub>j</sub>, nextCourse<sub>j</sub>]</code> ，表示课程 <code>prevCourse<sub>j</sub></code> 必须在课程 <code>nextCourse<sub>j</sub></code> <strong>之前</strong> 完成（先修课的关系）。同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>time</code> ，其中 <code>time[i]</code> 表示完成第 <code>(i+1)</code> 门课程需要花费的 <strong>月份</strong> 数。</p>
<p>请你根据以下规则算出完成所有课程所需要的 <strong>最少</strong> 月份数：</p>
<ul>
<li>如果一门课的所有先修课都已经完成，你可以在 <strong>任意</strong> 时间开始这门课程。</li>
<li>你可以 <strong>同时</strong> 上 <strong>任意门课程</strong> 。</li>
</ul>
<p>请你返回完成所有课程所需要的 <strong>最少</strong> 月份数。</p>
<p><strong>注意：</strong>测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/10/07/ex1.png" style="width: 392px; height: 232px;"/></strong></p>
<pre><strong>输入：</strong>n = 3, relations = [[1,3],[2,3]], time = [3,2,5]
<b>输出：</b>8
<b>解释：</b>上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。
你可以在月份 0 同时开始课程 1 和 2 。
课程 1 花费 3 个月，课程 2 花费 2 个月。
所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/10/07/ex2.png" style="width: 500px; height: 365px;"/></strong></p>
<pre><b>输入：</b>n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]
<b>输出：</b>12
<b>解释：</b>上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。
你可以在月份 0 同时开始课程 1 ，2 和 3 。
在月份 1，2 和 3 分别完成这三门课程。
课程 4 需在课程 3 之后开始，也就是 3 个月后。课程 4 在 3 + 4 = 7 月完成。
课程 5 需在课程 1，2，3 和 4 之后开始，也就是在 max(1,2,3,7) = 7 月开始。
所以完成所有课程所需的最少时间为 7 + 5 = 12 个月。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>0 &lt;= relations.length &lt;= min(n * (n - 1) / 2, 5 * 10<sup>4</sup>)</code></li>
<li><code>relations[j].length == 2</code></li>
<li><code>1 &lt;= prevCourse<sub>j</sub>, nextCourse<sub>j</sub> &lt;= n</code></li>
<li><code>prevCourse<sub>j</sub> != nextCourse<sub>j</sub></code></li>
<li>所有的先修课程对 <code>[prevCourse<sub>j</sub>, nextCourse<sub>j</sub>]</code> 都是 <strong>互不相同</strong> 的。</li>
<li><code>time.length == n</code></li>
<li><code>1 &lt;= time[i] &lt;= 10<sup>4</sup></code></li>
<li>先修课程图是一个有向无环图。</li>
</ul>
</div></div></div><br><br><hr><br>*****************************************************<div id="title">2056. Number of Valid Move Combinations On Chessboard</div>
*****************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一个 <code>8 x 8</code> 的棋盘，它包含 <code>n</code> 个棋子（棋子包括车，后和象三种）。给你一个长度为 <code>n</code> 的字符串数组 <code>pieces</code> ，其中 <code>pieces[i]</code> 表示第 <code>i</code> 个棋子的类型（车，后或象）。除此以外，还给你一个长度为 <code>n</code> 的二维整数数组 <code>positions</code> ，其中 <code>positions[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> 表示第 <code>i</code> 个棋子现在在棋盘上的位置为 <code>(r<sub>i</sub>, c<sub>i</sub>)</code> ，棋盘下标从 <strong>1</strong> 开始。</p>
<p>棋盘上每个棋子都可以移动 <b>至多一次</b> 。每个棋子的移动中，首先选择移动的 <strong>方向</strong> ，然后选择 <strong>移动的步数</strong> ，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：</p>
<ul>
<li>车可以 <strong>水平或者竖直</strong> 从 <code>(r, c)</code> 沿着方向 <code>(r+1, c)</code>，<code>(r-1, c)</code>，<code>(r, c+1)</code> 或者 <code>(r, c-1)</code> 移动。</li>
<li>后可以 <strong>水平竖直或者斜对角</strong> 从 <code>(r, c)</code> 沿着方向 <code>(r+1, c)</code>，<code>(r-1, c)</code>，<code>(r, c+1)</code>，<code>(r, c-1)</code>，<code>(r+1, c+1)</code>，<code>(r+1, c-1)</code>，<code>(r-1, c+1)</code>，<code>(r-1, c-1)</code> 移动。</li>
<li>象可以 <strong>斜对角</strong> 从 <code>(r, c)</code> 沿着方向 <code>(r+1, c+1)</code>，<code>(r+1, c-1)</code>，<code>(r-1, c+1)</code>，<code>(r-1, c-1)</code> 移动。</li>
</ul>
<p><strong>移动组合</strong> 包含所有棋子的 <strong>移动</strong> 。每一秒，每个棋子都沿着它们选择的方向往前移动 <strong>一步</strong> ，直到它们到达目标位置。所有棋子从时刻 <code>0</code> 开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 <strong>不有效</strong> 。</p>
<p>请你返回 <strong>有效</strong> 移动组合的数目。</p>
<p><strong>注意：</strong></p>
<ul>
<li>初始时，<strong>不会有两个棋子</strong> 在 <strong>同一个位置 。</strong></li>
<li>有可能在一个移动组合中，有棋子不移动。</li>
<li>如果两个棋子 <strong>直接相邻</strong> 且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 <strong>交换位置</strong> 。</li>
</ul>
<p> </p>
<p><strong>示例 1:</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/09/23/a1.png" style="width: 215px; height: 215px;"/></p>
<pre><b>输入：</b>pieces = ["rook"], positions = [[1,1]]
<b>输出：</b>15
<b>解释：</b>上图展示了棋子所有可能的移动。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/09/23/a2.png" style="width: 215px; height: 215px;"/></p>
<pre><b>输入：</b>pieces = ["queen"], positions = [[1,1]]
<b>输出：</b>22
<b>解释：</b>上图展示了棋子所有可能的移动。
</pre>
<p><strong>示例 3:</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/09/23/a3.png" style="width: 214px; height: 215px;"/></p>
<pre><b>输入：</b>pieces = ["bishop"], positions = [[4,3]]
<b>输出：</b>12
<b>解释：</b>上图展示了棋子所有可能的移动。
</pre>
<p><strong>示例 4:</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/09/23/a4.png" style="width: 216px; height: 219px;"/></p>
<pre><b>输入：</b>pieces = ["rook","rook"], positions = [[1,1],[8,8]]
<b>输出：</b>223
<b>解释：</b>每个车有 15 种移动，所以总共有 15 * 15 = 225 种移动组合。
但是，有两个是不有效的移动组合：
- 将两个车都移动到 (8, 1) ，会导致它们在同一个格子相遇。
- 将两个车都移动到 (1, 8) ，会导致它们在同一个格子相遇。
所以，总共有 225 - 2 = 223 种有效移动组合。
注意，有两种有效的移动组合，分别是一个车在 (1, 8) ，另一个车在 (8, 1) 。
即使棋盘状态是相同的，这两个移动组合被视为不同的，因为每个棋子移动操作是不相同的。
</pre>
<p><strong>示例 5：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/09/23/a5.png" style="width: 214px; height: 213px;"/></p>
<pre><b>输入：</b>pieces = ["queen","bishop"], positions = [[5,7],[3,4]]
<b>输出：</b>281
<b>解释：</b>总共有 12 * 24 = 288 种移动组合。
但是，有一些不有效的移动组合：
- 如果后停在 (6, 7) ，它会阻挡象到达 (6, 7) 或者 (7, 8) 。
- 如果后停在 (5, 6) ，它会阻挡象到达 (5, 6) ，(6, 7) 或者 (7, 8) 。
- 如果象停在 (5, 2) ，它会阻挡后到达 (5, 2) 或者 (5, 1) 。
在 288 个移动组合当中，281 个是有效的。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == pieces.length </code></li>
<li><code>n == positions.length</code></li>
<li><code>1 &lt;= n &lt;= 4</code></li>
<li><code>pieces</code> 只包含字符串 <code>"rook"</code> ，<code>"queen"</code> 和 <code>"bishop"</code> 。</li>
<li>棋盘上总共最多只有一个后。</li>
<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 8</code></li>
<li>每一个 <code>positions[i]</code> 互不相同。</li>
</ul>
</div></div></div><br><br><hr><br>******************************************************************<div id="title">2060. Check if an Original String Exists Given Two Encoded Strings</div>
******************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>原字符串由小写字母组成，可以按下述步骤编码：</p>
<ul>
<li>任意将其 <strong>分割</strong> 为由若干 <strong>非空</strong> 子字符串组成的一个 <strong>序列</strong> 。</li>
<li>任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。</li>
<li>重新 <strong>顺次连接</strong> 序列，得到编码后的字符串。</li>
</ul>
<p>例如，编码 <code>"abcdefghijklmnop"</code> 的一种方法可以描述为：</p>
<ul>
<li>将原字符串分割得到一个序列：<code>["ab", "cdefghijklmn", "o", "p"]</code> 。</li>
<li>选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 <code>["ab", "12", "1", "p"]</code> 。</li>
<li>重新顺次连接序列中的元素，得到编码后的字符串：<code>"ab121p"</code> 。</li>
</ul>
<p>给你两个编码后的字符串 <code>s1</code> 和 <code>s2</code> ，由小写英文字母和数字 <code>1-9</code> 组成。如果存在能够同时编码得到 <code>s1</code> 和 <code>s2</code> 原字符串，返回 <code>true</code> ；否则，返回 <code>false</code>。</p>
<p><strong>注意：</strong>生成的测试用例满足 <code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s1 = "internationalization", s2 = "i18n"
<strong>输出：</strong>true
<strong>解释：</strong>"internationalization" 可以作为原字符串
- "internationalization" 
  -&gt; 分割：      ["internationalization"]
  -&gt; 不替换任何元素
  -&gt; 连接：      "internationalization"，得到 s1
- "internationalization"
  -&gt; 分割：      ["i", "nternationalizatio", "n"]
  -&gt; 替换：      ["i", "18",                 "n"]
  -&gt; 连接：      "i18n"，得到 s2
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s1 = "l123e", s2 = "44"
<strong>输出：</strong>true
<strong>解释：</strong>"leetcode" 可以作为原字符串
- "leetcode" 
  -&gt; 分割：       ["l", "e", "et", "cod", "e"]
  -&gt; 替换：       ["l", "1", "2",  "3",   "e"]
  -&gt; 连接：       "l123e"，得到 s1
- "leetcode" 
  -&gt; 分割：       ["leet", "code"]
  -&gt; 替换：       ["4",    "4"]
  -&gt; 连接：       "44"，得到 s2
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s1 = "a5b", s2 = "c5b"
<strong>输出：</strong>false
<strong>解释：</strong>不存在这样的原字符串
- 编码为 s1 的字符串必须以字母 'a' 开头
- 编码为 s2 的字符串必须以字母 'c' 开头
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>s1 = "112s", s2 = "g841"
<strong>输出：</strong>true
<strong>解释：</strong>"gaaaaaaaaaaaas" 可以作为原字符串
- "gaaaaaaaaaaaas"
  -&gt; 分割：       ["g", "aaaaaaaaaaaa", "s"]
  -&gt; 替换：       ["1", "12",           "s"]
  -&gt; 连接：       "112s"，得到 s1
- "gaaaaaaaaaaaas"
  -&gt; 分割：       ["g", "aaaaaaaa", "aaaa", "s"]
  -&gt; 替换：       ["g", "8",        "4",    "1"]
  -&gt; 连接         "g841"，得到 s2
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>s1 = "ab", s2 = "a2"
<strong>输出：</strong>false
<strong>解释：</strong>不存在这样的原字符串
- 编码为 s1 的字符串由两个字母组成
- 编码为 s2 的字符串由三个字母组成
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s1.length, s2.length &lt;= 40</code></li>
<li><code>s1</code> 和 <code>s2</code> 仅由数字 <code>1-9</code> 和小写英文字母组成</li>
<li><code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************<div id="title">2065. Maximum Path Quality of a Graph</div>
*************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一张 <strong>无向</strong> 图，图中有 <code>n</code> 个节点，节点编号从 <code>0</code> 到 <code>n - 1</code> （<strong>都包括</strong>）。同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>values</code> ，其中 <code>values[i]</code> 是第 <code>i</code> 个节点的 <strong>价值</strong> 。同时给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>edges</code> ，其中 <code>edges[j] = [u<sub>j</sub>, v<sub>j</sub>, time<sub>j</sub>]</code> 表示节点 <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 之间有一条需要 <code>time<sub>j</sub></code> 秒才能通过的无向边。最后，给你一个整数 <code>maxTime</code> 。</p>
<p><strong>合法路径</strong> 指的是图中任意一条从节点 <code>0</code> 开始，最终回到节点 <code>0</code> ，且花费的总时间 <strong>不超过</strong> <code>maxTime</code> 秒的一条路径。你可以访问一个节点任意次。一条合法路径的 <b>价值</b> 定义为路径中 <strong>不同节点</strong> 的价值 <strong>之和</strong> （每个节点的价值 <strong>至多</strong> 算入价值总和中一次）。</p>
<p>请你返回一条合法路径的 <strong>最大</strong> 价值。</p>
<p><strong>注意：</strong>每个节点 <strong>至多</strong> 有 <strong>四条</strong> 边与之相连。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/10/19/ex1drawio.png" style="width: 269px; height: 170px;"/></p>
<pre><b>输入：</b>values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49
<b>输出：</b>75
<strong>解释：</strong>
一条可能的路径为：0 -&gt; 1 -&gt; 0 -&gt; 3 -&gt; 0 。总花费时间为 10 + 10 + 10 + 10 = 40 &lt;= 49 。
访问过的节点为 0 ，1 和 3 ，最大路径价值为 0 + 32 + 43 = 75 。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/10/19/ex2drawio.png" style="width: 269px; height: 170px;"/></p>
<pre><b>输入：</b>values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30
<b>输出：</b>25
<strong>解释：</strong>
一条可能的路径为：0 -&gt; 3 -&gt; 0 。总花费时间为 10 + 10 = 20 &lt;= 30 。
访问过的节点为 0 和 3 ，最大路径价值为 5 + 20 = 25 。
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/10/19/ex31drawio.png" style="width: 236px; height: 170px;"/></p>
<pre><b>输入：</b>values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50
<b>输出：</b>7
<strong>解释：</strong>
一条可能的路径为：0 -&gt; 1 -&gt; 3 -&gt; 1 -&gt; 0 。总花费时间为 10 + 13 + 13 + 10 = 46 &lt;= 50 。
访问过的节点为 0 ，1 和 3 ，最大路径价值为 1 + 2 + 4 = 7 。</pre>
<p><strong>示例 4：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/10/21/ex4drawio.png" style="width: 270px; height: 71px;"/></strong></p>
<pre><b>输入：</b>values = [0,1,2], edges = [[1,2,10]], maxTime = 10
<b>输出：</b>0
<b>解释：</b>
唯一一条路径为 0 。总花费时间为 0 。
唯一访问过的节点为 0 ，最大路径价值为 0 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == values.length</code></li>
<li><code>1 &lt;= n &lt;= 1000</code></li>
<li><code>0 &lt;= values[i] &lt;= 10<sup>8</sup></code></li>
<li><code>0 &lt;= edges.length &lt;= 2000</code></li>
<li><code>edges[j].length == 3 </code></li>
<li><code>0 &lt;= u<sub>j </sub>&lt; v<sub>j</sub> &lt;= n - 1</code></li>
<li><code>10 &lt;= time<sub>j</sub>, maxTime &lt;= 100</code></li>
<li><code>[u<sub>j</sub>, v<sub>j</sub>]</code> 所有节点对 <strong>互不相同</strong> 。</li>
<li>每个节点 <strong>至多有四条 </strong>边。</li>
<li>图可能不连通。</li>
</ul>
</div></div></div><br><br><hr><br>********************************************<div id="title">2071. Maximum Number of Tasks You Can Assign</div>
********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你 <code>n</code> 个任务和 <code>m</code> 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> 中，第 <code>i</code> 个任务需要 <code>tasks[i]</code> 的力量才能完成。每个工人的力量值保存在下标从 <strong>0</strong> 开始的整数数组 <code>workers</code> 中，第 <code>j</code> 个工人的力量值为 <code>workers[j]</code> 。每个工人只能完成 <strong>一个</strong> 任务，且力量值需要 <strong>大于等于</strong> 该任务的力量要求值（即 <code>workers[j] &gt;= tasks[i]</code> ）。</p>
<p>除此以外，你还有 <code>pills</code> 个神奇药丸，可以给 <strong>一个工人的力量值</strong> 增加 <code>strength</code> 。你可以决定给哪些工人使用药丸，但每个工人 <strong>最多</strong> 只能使用 <strong>一片</strong> 药丸。</p>
<p>给你下标从 <strong>0</strong> 开始的整数数组<code>tasks</code> 和 <code>workers</code> 以及两个整数 <code>pills</code> 和 <code>strength</code> ，请你返回 <strong>最多</strong> 有多少个任务可以被完成。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>tasks = [<em><strong>3</strong></em>,<em><strong>2</strong></em>,<em><strong>1</strong></em>], workers = [<em><strong>0</strong></em>,<em><strong>3</strong></em>,<em><strong>3</strong></em>], pills = 1, strength = 1
<b>输出：</b>3
<strong>解释：</strong>
我们可以按照如下方案安排药丸：
- 给 0 号工人药丸。
- 0 号工人完成任务 2（0 + 1 &gt;= 1）
- 1 号工人完成任务 1（3 &gt;= 2）
- 2 号工人完成任务 0（3 &gt;= 3）
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>tasks = [<em><strong>5</strong></em>,4], workers = [<em><strong>0</strong></em>,0,0], pills = 1, strength = 5
<b>输出：</b>1
<strong>解释：</strong>
我们可以按照如下方案安排药丸：
- 给 0 号工人药丸。
- 0 号工人完成任务 0（0 + 5 &gt;= 5）
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>tasks = [<em><strong>10</strong></em>,<em><strong>15</strong></em>,30], workers = [<em><strong>0</strong></em>,<em><strong>10</strong></em>,10,10,10], pills = 3, strength = 10
<b>输出：</b>2
<strong>解释：</strong>
我们可以按照如下方案安排药丸：
- 给 0 号和 1 号工人药丸。
- 0 号工人完成任务 0（0 + 10 &gt;= 10）
- 1 号工人完成任务 1（10 + 10 &gt;= 15）
</pre>
<p><strong>示例 4：</strong></p>
<pre><b>输入：</b>tasks = [<em><strong>5</strong></em>,9,<em><strong>8</strong></em>,<em><strong>5</strong></em>,9], workers = [1,<em><strong>6</strong></em>,<em><strong>4</strong></em>,2,<em><strong>6</strong></em>], pills = 1, strength = 5
<b>输出：</b>3
<strong>解释：</strong>
我们可以按照如下方案安排药丸：
- 给 2 号工人药丸。
- 1 号工人完成任务 0（6 &gt;= 5）
- 2 号工人完成任务 2（4 + 5 &gt;= 8）
- 4 号工人完成任务 3（6 &gt;= 5）
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == tasks.length</code></li>
<li><code>m == workers.length</code></li>
<li><code>1 &lt;= n, m &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>0 &lt;= pills &lt;= m</code></li>
<li><code>0 &lt;= tasks[i], workers[j], strength &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">2076. Process Restricted Friend Requests</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数 <code>n</code> ，表示网络上的用户数目。每个用户按从 <code>0</code> 到 <code>n - 1</code> 进行编号。</p>
<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>restrictions</code> ，其中 <code>restrictions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 意味着用户 <code>x<sub>i</sub></code> 和用户 <code>y<sub>i</sub></code> <strong>不能</strong> 成为 <strong>朋友</strong> ，不管是 <strong>直接</strong> 还是通过其他用户 <strong>间接</strong> 。</p>
<p>最初，用户里没有人是其他用户的朋友。给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>requests</code> 表示好友请求的列表，其中 <code>requests[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> 是用户 <code>u<sub>j</sub></code> 和用户 <code>v<sub>j</sub></code> 之间的一条好友请求。</p>
<p>如果 <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 可以成为 <strong>朋友</strong> ，那么好友请求将会 <strong>成功</strong> 。每个好友请求都会按列表中给出的顺序进行处理（即，<code>requests[j]</code> 会在 <code>requests[j + 1]</code> 前）。一旦请求成功，那么对所有未来的好友请求而言， <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 将会 <strong>成为直接朋友 。</strong></p>
<p>返回一个 <strong>布尔数组</strong> <code>result</code> ，其中元素遵循此规则：如果第 <code>j</code> 个好友请求 <strong>成功</strong><em> </em>，那么 <code>result[j]</code><em> </em>就是<em> </em><code>true</code><em> </em>；否则，为<em> </em><code>false</code> 。</p>
<p><strong>注意：</strong>如果 <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 已经是直接朋友，那么他们之间的请求将仍然 <strong>成功</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]
<strong>输出：</strong>[true,false]
<strong>解释：
</strong>请求 0 ：用户 0 和 用户 2 可以成为朋友，所以他们成为直接朋友。 
请求 1 ：用户 2 和 用户 1 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (1--2--0) 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]
<strong>输出：</strong>[true,false]
<strong>解释：</strong>
请求 0 ：用户 1 和 用户 2 可以成为朋友，所以他们成为直接朋友。 
请求 1 ：用户 0 和 用户 2 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--2--1) 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]
<strong>输出：</strong>[true,false,true,false]
<strong>解释：
</strong>请求 0 ：用户 0 和 用户 4 可以成为朋友，所以他们成为直接朋友。 
请求 1 ：用户 1 和 用户 2 不能成为朋友，因为他们之间存在限制。
请求 2 ：用户 3 和 用户 1 可以成为朋友，所以他们成为直接朋友。 
请求 3 ：用户 3 和 用户 4 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--4--3--1) 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 1000</code></li>
<li><code>0 &lt;= restrictions.length &lt;= 1000</code></li>
<li><code>restrictions[i].length == 2</code></li>
<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>
<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
<li><code>1 &lt;= requests.length &lt;= 1000</code></li>
<li><code>requests[j].length == 2</code></li>
<li><code>0 &lt;= u<sub>j</sub>, v<sub>j</sub> &lt;= n - 1</code></li>
<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">2081. Sum of k-Mirror Numbers</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个 <strong>k 镜像数字</strong> 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 <strong>没有前导 0</strong> 的 <strong>正</strong> 整数。</p>
<ul>
<li>比方说，<code>9</code> 是一个 2 镜像数字。<code>9</code> 在十进制下为 <code>9</code> ，二进制下为 <code>1001</code> ，两者从前往后读和从后往前读都一样。</li>
<li>相反地，<code>4</code> 不是一个 2 镜像数字。<code>4</code> 在二进制下为 <code>100</code> ，从前往后和从后往前读不相同。</li>
</ul>
<p>给你进制 <code>k</code> 和一个数字 <code>n</code> ，请你返回 k 镜像数字中 <strong>最小</strong> 的 <code>n</code> 个数 <strong>之和</strong> 。</p>
<p> </p>
<p><b>示例 1：</b></p>
<pre><b>输入：</b>k = 2, n = 5
<b>输出：</b>25
<strong>解释：
</strong>最小的 5 个 2 镜像数字和它们的二进制表示如下：
  十进制       二进制
    1          1
    3          11
    5          101
    7          111
    9          1001
它们的和为 1 + 3 + 5 + 7 + 9 = 25 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>k = 3, n = 7
<b>输出：</b>499
<strong>解释：
</strong>7 个最小的 3 镜像数字和它们的三进制表示如下：
  十进制       三进制
    1          1
    2          2
    4          11
    8          22
    121        11111
    151        12121
    212        21212
它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>k = 7, n = 17
<b>输出：</b>20379000
<b>解释：</b>17 个最小的 7 镜像数字分别为：
1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= k &lt;= 9</code></li>
<li><code>1 &lt;= n &lt;= 30</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">2088. Count Fertile Pyramids in a Land</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一个 <strong>矩形网格</strong> 状的农场，划分为 <code>m</code> 行 <code>n</code> 列的单元格。每个格子要么是 <strong>肥沃的</strong> （用 <code>1</code> 表示），要么是 <strong>贫瘠</strong> 的（用 <code>0</code> 表示）。网格图以外的所有与格子都视为贫瘠的。</p>
<p>农场中的 <strong>金字塔</strong> 区域定义如下：</p>
<ol>
<li>区域内格子数目 <strong>大于 </strong><code>1</code> 且所有格子都是 <strong>肥沃的</strong> 。</li>
<li>金字塔 <strong>顶端</strong> 是这个金字塔 <strong>最上方</strong> 的格子。金字塔的高度是它所覆盖的行数。令 <code>(r, c)</code> 为金字塔的顶端且高度为 <code>h</code> ，那么金字塔区域内包含的任一格子 <code>(i, j)</code> 需满足 <code>r &lt;= i &lt;= r + h - 1</code> <strong>且</strong> <code>c - (i - r) &lt;= j &lt;= c + (i - r)</code> 。</li>
</ol>
<p>一个 <strong>倒金字塔</strong> 类似定义如下：</p>
<ol>
<li>区域内格子数目 <strong>大于</strong> <code>1</code> 且所有格子都是 <b>肥沃的</b> 。</li>
<li>倒金字塔的 <strong>顶端</strong> 是这个倒金字塔 <strong>最下方</strong> 的格子。倒金字塔的高度是它所覆盖的行数。令 <code>(r, c)</code> 为金字塔的顶端且高度为 <code>h</code> ，那么金字塔区域内包含的任一格子 <code>(i, j)</code> 需满足 <code>r - h + 1 &lt;= i &lt;= r</code> <strong>且</strong> <code>c - (r - i) &lt;= j &lt;= c + (r - i)</code> 。</li>
</ol>
<p>下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/11/08/image.png" style="width: 700px; height: 156px;"/></p>
<p>给你一个下标从 <strong>0</strong> 开始且大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，它表示农场，请你返回 <code>grid</code> 中金字塔和倒金字塔的 <strong>总数目</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/10/23/eg11.png" style="width: 200px; height: 102px;"/> <img alt="" src="https://assets.leetcode.com/uploads/2021/10/23/exa12.png" style="width: 200px; height: 102px;"/> <img alt="" src="https://assets.leetcode.com/uploads/2021/10/23/exa13.png" style="width: 200px; height: 102px;"/></p>
<pre><b>输入：</b>grid = [[0,1,1,0],[1,1,1,1]]
<b>输出：</b>2
<strong>解释：</strong>
2 个可能的金字塔区域分别如上图蓝色和红色区域所示。
这个网格图中没有倒金字塔区域。
所以金字塔区域总数为 2 + 0 = 2 。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/10/23/eg21.png" style="width: 180px; height: 122px;"/> <img alt="" src="https://assets.leetcode.com/uploads/2021/10/23/exa22.png" style="width: 180px; height: 122px;"/> <img alt="" src="https://assets.leetcode.com/uploads/2021/10/23/exa23.png" style="width: 180px; height: 122px;"/></p>
<pre><b>输入：</b>grid = [[1,1,1],[1,1,1]]
<b>输出：</b>2
<strong>解释：</strong>
金字塔区域如上图蓝色区域所示，倒金字塔如上图红色区域所示。
所以金字塔区域总数目为 1 + 1 = 2 。
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/10/23/eg3.png" style="width: 149px; height: 150px;"/></p>
<pre><b>输入：</b>grid = [[1,0,1],[0,0,0],[1,0,1]]
<b>输出：</b>0
<strong>解释：</strong>
网格图中没有任何金字塔或倒金字塔区域。
</pre>
<p><strong>示例 4：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/10/23/eg41.png" style="width: 180px; height: 144px;"/> <img alt="" src="https://assets.leetcode.com/uploads/2021/10/23/eg42.png" style="width: 180px; height: 144px;"/> <img alt="" src="https://assets.leetcode.com/uploads/2021/10/23/eg43.png" style="width: 180px; height: 144px;"/> <img alt="" src="https://assets.leetcode.com/uploads/2021/10/23/eg44.png" style="width: 180px; height: 144px;"/></p>
<pre><strong>输入：</strong>grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]
<b>输出：</b>13
<strong>解释：</strong>
有 7 个金字塔区域。上图第二和第三张图中展示了它们中的 3 个。
有 6 个倒金字塔区域。上图中最后一张图展示了它们中的 2 个。
所以金字塔区域总数目为 7 + 6 = 13.
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 1000</code></li>
<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
<li><code>grid[i][j]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">2092. Find All People With Secret</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 个专家从 <code>0</code> 到 <code>n - 1</code> 编号。另外给你一个下标从 0 开始的二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> 表示专家 <code>x<sub>i</sub></code> 和专家 <code>y<sub>i</sub></code> 在时间 <code>time<sub>i</sub></code> 要开一场会。一个专家可以同时参加 <strong>多场会议</strong> 。最后，给你一个整数 <code>firstPerson</code> 。</p>
<p>专家 <code>0</code> 有一个 <strong>秘密</strong> ，最初，他在时间 <code>0</code> 将这个秘密分享给了专家 <code>firstPerson</code> 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 <code>x<sub>i</sub></code> 在时间 <code>time<sub>i</sub></code> 时知晓这个秘密，那么他将会与专家 <code>y<sub>i</sub></code> 分享这个秘密，反之亦然。</p>
<p>秘密共享是 <strong>瞬时发生</strong> 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。</p>
<p>在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 <strong>任何顺序</strong> 返回答案。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1
<strong>输出：</strong>[0,1,2,3,5]
<strong>解释：
</strong>时间 0 ，专家 0 将秘密与专家 1 共享。
时间 5 ，专家 1 将秘密与专家 2 共享。
时间 8 ，专家 2 将秘密与专家 3 共享。
时间 10 ，专家 1 将秘密与专家 5 共享。
因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3
<strong>输出：</strong>[0,1,3]
<strong>解释：</strong>
时间 0 ，专家 0 将秘密与专家 3 共享。
时间 2 ，专家 1 与专家 2 都不知晓这个秘密。
时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。
因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1
<strong>输出：</strong>[0,1,2,3,4]
<strong>解释：</strong>
时间 0 ，专家 0 将秘密与专家 1 共享。
时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。
注意，专家 2 可以在收到秘密的同一时间分享此秘密。
时间 2 ，专家 3 将秘密与专家 4 共享。
因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>
<li><code>meetings[i].length == 3</code></li>
<li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>
<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>
</ul>
</div></div></div><br><br><hr><br>********************************<div id="title">2097. Valid Arrangement of Pairs</div>
********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>pairs</code> ，其中 <code>pairs[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 。如果 <code>pairs</code> 的一个重新排列，满足对每一个下标 <code>i</code> （ <code>1 &lt;= i &lt; pairs.length</code> ）都有 <code>end<sub>i-1</sub> == start<sub>i</sub></code><sub> </sub>，那么我们就认为这个重新排列是 <code>pairs</code> 的一个 <strong>合法重新排列</strong> 。</p>
<p>请你返回 <strong>任意一个</strong> <code>pairs</code> 的合法重新排列。</p>
<p><b>注意：</b>数据保证至少存在一个 <code>pairs</code> 的合法重新排列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>pairs = [[5,1],[4,5],[11,9],[9,4]]
<b>输出：</b>[[11,9],[9,4],[4,5],[5,1]]
<strong>解释：
</strong>输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub> 。
end<sub>0</sub> = 9 == 9 = start<sub>1</sub> 
end<sub>1</sub> = 4 == 4 = start<sub>2</sub>
end<sub>2</sub> = 5 == 5 = start<sub>3</sub>
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>pairs = [[1,3],[3,2],[2,1]]
<b>输出：</b>[[1,3],[3,2],[2,1]]
<strong>解释：</strong>
输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub> 。
end<sub>0</sub> = 3 == 3 = start<sub>1</sub>
end<sub>1</sub> = 2 == 2 = start<sub>2</sub>
重新排列后的数组 [[2,1],[1,3],[3,2]] 和 [[3,2],[2,1],[1,3]] 都是合法的。
</pre>
<p><strong>示例 3：</strong></p>
<pre><b>输入：</b>pairs = [[1,2],[1,3],[2,1]]
<b>输出：</b>[[1,2],[2,1],[1,3]]
<strong>解释：</strong>
输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub> 。
end<sub>0</sub> = 2 == 2 = start<sub>1</sub>
end<sub>1</sub> = 1 == 1 = start<sub>2</sub>
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= pairs.length &lt;= 10<sup>5</sup></code></li>
<li><code>pairs[i].length == 2</code></li>
<li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
<li><code>start<sub>i</sub> != end<sub>i</sub></code></li>
<li><code>pairs</code> 中不存在一模一样的数对。</li>
<li>至少 <strong>存在</strong> 一个合法的 <code>pairs</code> 重新排列。</li>
</ul>
</div></div></div><br><br><hr><br>***************************************<div id="title">2102. Sequentially Ordinal Rank Tracker</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个观光景点由它的名字 <code>name</code> 和景点评分 <code>score</code> 组成，其中 <code>name</code> 是所有观光景点中 <strong>唯一</strong> 的字符串，<code>score</code> 是一个整数。景点按照最好到最坏排序。景点评分 <strong>越高</strong> ，这个景点越好。如果有两个景点的评分一样，那么 <strong>字典序较小</strong> 的景点更好。</p>
<p>你需要搭建一个系统，查询景点的排名。初始时系统里没有任何景点。这个系统支持：</p>
<ul>
<li><strong>添加</strong> 景点，每次添加 <strong>一个</strong> 景点。</li>
<li><strong>查询 </strong>已经添加景点中第 <code>i</code> <strong>好</strong> 的景点，其中 <code>i</code> 是系统目前位置查询的次数（包括当前这一次）。
	<ul>
<li>比方说，如果系统正在进行第 <code>4</code> 次查询，那么需要返回所有已经添加景点中第 <code>4</code> 好的。</li>
</ul>
</li>
</ul>
<p>注意，测试数据保证 <strong>任意查询时刻</strong> ，查询次数都 <strong>不超过</strong> 系统中景点的数目。</p>
<p>请你实现 <code>SORTracker</code> 类：</p>
<ul>
<li><code>SORTracker()</code> 初始化系统。</li>
<li><code>void add(string name, int score)</code> 向系统中添加一个名为 <code>name</code> 评分为 <code>score</code> 的景点。</li>
<li><code>string get()</code> 查询第 <code>i</code> 好的景点，其中 <code>i</code> 是目前系统查询的次数（包括当前这次查询）。</li>
</ul>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>
["SORTracker", "add", "add", "get", "add", "get", "add", "get", "add", "get", "add", "get", "get"]
[[], ["bradford", 2], ["branford", 3], [], ["alps", 2], [], ["orland", 2], [], ["orlando", 3], [], ["alpine", 2], [], []]
<strong>输出：</strong>
[null, null, null, "branford", null, "alps", null, "bradford", null, "bradford", null, "bradford", "orland"]

<strong>解释：</strong>
SORTracker tracker = new SORTracker(); // 初始化系统
tracker.add("bradford", 2); // 添加 name="bradford" 且 score=2 的景点。
tracker.add("branford", 3); // 添加 name="branford" 且 score=3 的景点。
tracker.get();              // 从好带坏的景点为：branford ，bradford 。
                            // 注意到 branford 比 bradford 好，因为它的 <strong>评分更高</strong> (3 &gt; 2) 。
                            // 这是第 1 次调用 get() ，所以返回最好的景点："branford" 。
tracker.add("alps", 2);     // 添加 name="alps" 且 score=2 的景点。
tracker.get();              // 从好到坏的景点为：branford, alps, bradford 。
                            // 注意 alps 比 bradford 好，虽然它们评分相同，都为 2 。
                            // 这是因为 "alps" <strong>字典序</strong> 比 "bradford" 小。
                            // 返回第 2 好的地点 "alps" ，因为当前为第 2 次调用 get() 。
tracker.add("orland", 2);   // 添加 name="orland" 且 score=2 的景点。
tracker.get();              // 从好到坏的景点为：branford, alps, bradford, orland 。
                            // 返回 "bradford" ，因为当前为第 3 次调用 get() 。
tracker.add("orlando", 3);  // 添加 name="orlando" 且 score=3 的景点。
tracker.get();              // 从好到坏的景点为：branford, orlando, alps, bradford, orland 。
                            // 返回 "bradford".
tracker.add("alpine", 2);   // 添加 name="alpine" 且 score=2 的景点。
tracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。
                            // 返回 "bradford" 。
tracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。
                            // 返回 "orland" 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>name</code> 只包含小写英文字母，且每个景点名字互不相同。</li>
<li><code>1 &lt;= name.length &lt;= 10</code></li>
<li><code>1 &lt;= score &lt;= 10<sup>5</sup></code></li>
<li>任意时刻，调用 <code>get</code> 的次数都不超过调用 <code>add</code> 的次数。</li>
<li><strong>总共</strong> 调用 <code>add</code> 和 <code>get</code> 不超过 <code>4 * 10<sup>4</sup></code> </li>
</ul>
</div></div></div><br><br><hr><br>****************************************************<div id="title">2106. Maximum Fruits Harvested After at Most K Steps</div>
****************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 <code>fruits</code> ，其中 <code>fruits[i] = [position<sub>i</sub>, amount<sub>i</sub>]</code> 表示共有 <code>amount<sub>i</sub></code> 个水果放置在 <code>position<sub>i</sub></code> 上。<code>fruits</code> 已经按 <code>position<sub>i</sub></code> <strong>升序排列</strong> ，每个 <code>position<sub>i</sub></code> <strong>互不相同</strong> 。</p>
<p>另给你两个整数 <code>startPos</code> 和 <code>k</code> 。最初，你位于 <code>startPos</code> 。从任何位置，你可以选择 <strong>向左或者向右</strong> 走。在 x 轴上每移动 <strong>一个单位</strong> ，就记作 <strong>一步</strong> 。你总共可以走 <strong>最多</strong> <code>k</code> 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。</p>
<p>返回你可以摘到水果的 <strong>最大总数</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/21/1.png" style="width: 472px; height: 115px;"/>
<pre><strong>输入：</strong>fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4
<strong>输出：</strong>9
<strong>解释：</strong>
最佳路线为：
- 向右移动到位置 6 ，摘到 3 个水果
- 向右移动到位置 8 ，摘到 6 个水果
移动 3 步，共摘到 3 + 6 = 9 个水果
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/21/2.png" style="width: 512px; height: 129px;"/>
<pre><strong>输入：</strong>fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4
<strong>输出：</strong>14
<strong>解释：</strong>
可以移动最多 k = 4 步，所以无法到达位置 0 和位置 10 。
最佳路线为：
- 在初始位置 5 ，摘到 7 个水果
- 向左移动到位置 4 ，摘到 1 个水果
- 向右移动到位置 6 ，摘到 2 个水果
- 向右移动到位置 7 ，摘到 4 个水果
移动 1 + 3 = 4 步，共摘到 7 + 1 + 2 + 4 = 14 个水果
</pre>
<p><strong>示例 3：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/11/21/3.png" style="width: 476px; height: 100px;"/>
<pre><strong>输入：</strong>fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2
<strong>输出：</strong>0
<strong>解释：</strong>
最多可以移动 k = 2 步，无法到达任一有水果的地方
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>
<li><code>fruits[i].length == 2</code></li>
<li><code>0 &lt;= startPos, position<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>
<li>对于任意 <code>i &gt; 0</code> ，<code>position<sub>i-1</sub> &lt; position<sub>i</sub></code> 均成立（下标从 <strong>0</strong> 开始计数）</li>
<li><code>1 &lt;= amount<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
<li><code>0 &lt;= k &lt;= 2 * 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************************************<div id="title">2111. Minimum Operations to Make the Array K-Increasing</div>
*******************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始包含 <code>n</code> 个正整数的数组 <code>arr</code> ，和一个正整数 <code>k</code> 。</p>
<p>如果对于每个满足 <code>k &lt;= i &lt;= n-1</code> 的下标 <code>i</code> ，都有 <code>arr[i-k] &lt;= arr[i]</code> ，那么我们称 <code>arr</code> 是 <strong>K</strong> <strong>递增</strong> 的。</p>
<ul>
<li>比方说，<code>arr = [4, 1, 5, 2, 6, 2]</code> 对于 <code>k = 2</code> 是 K 递增的，因为：

	<ul>
<li><code>arr[0] &lt;= arr[2] (4 &lt;= 5)</code></li>
<li><code>arr[1] &lt;= arr[3] (1 &lt;= 2)</code></li>
<li><code>arr[2] &lt;= arr[4] (5 &lt;= 6)</code></li>
<li><code>arr[3] &lt;= arr[5] (2 &lt;= 2)</code></li>
</ul>
</li>
<li>但是，相同的数组 <code>arr</code> 对于 <code>k = 1</code> 不是 K 递增的（因为 <code>arr[0] &gt; arr[1]</code>），对于 <code>k = 3</code> 也不是 K 递增的（因为 <code>arr[0] &gt; arr[3]</code> ）。</li>
</ul>
<p>每一次 <strong>操作</strong> 中，你可以选择一个下标 <code>i</code> 并将 <code>arr[i]</code> <strong>改成任意 </strong>正整数。</p>
<p>请你返回对于给定的 <code>k</code> ，使数组变成 K 递增的 <strong>最少操作次数</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>arr = [5,4,3,2,1], k = 1
<b>输出：</b>4
<strong>解释：
</strong>对于 k = 1 ，数组最终必须变成非递减的。
可行的 K 递增结果数组为 [5,<em><strong>6</strong></em>,<em><strong>7</strong></em>,<em><strong>8</strong></em>,<em><strong>9</strong></em>]，[<em><strong>1</strong></em>,<em><strong>1</strong></em>,<em><strong>1</strong></em>,<em><strong>1</strong></em>,1]，[<em><strong>2</strong></em>,<em><strong>2</strong></em>,3,<em><strong>4</strong></em>,<em><strong>4</strong></em>] 。它们都需要 4 次操作。
次优解是将数组变成比方说 [<em><strong>6</strong></em>,<em><strong>7</strong></em>,<em><strong>8</strong></em>,<em><strong>9</strong></em>,<em><strong>10</strong></em>] ，因为需要 5 次操作。
显然我们无法使用少于 4 次操作将数组变成 K 递增的。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>arr = [4,1,5,2,6,2], k = 2
<b>输出：</b>0
<strong>解释：</strong>
这是题目描述中的例子。
对于每个满足 2 &lt;= i &lt;= 5 的下标 i ，有 arr[i-2] &lt;=<b> </b>arr[i] 。
由于给定数组已经是 K 递增的，我们不需要进行任何操作。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>arr = [4,1,5,2,6,2], k = 3
<b>输出：</b>2
<strong>解释：</strong>
下标 3 和 5 是仅有的 3 &lt;= i &lt;= 5 且不满足 arr[i-3] &lt;= arr[i] 的下标。
将数组变成 K 递增的方法之一是将 arr[3] 变为 4 ，且将 arr[5] 变成 5 。
数组变为 [4,1,5,<em><strong>4</strong></em>,6,<em><strong>5</strong></em>] 。
可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 2 次。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= arr[i], k &lt;= arr.length</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">2117. Abbreviating the Product of a Range</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个正整数 <code>left</code> 和 <code>right</code> ，满足 <code>left &lt;= right</code> 。请你计算 <strong>闭区间</strong> <code>[left, right]</code> 中所有整数的 <strong>乘积</strong> 。</p>
<p>由于乘积可能非常大，你需要将它按照以下步骤 <strong>缩写</strong> ：</p>
<ol>
<li>统计乘积中 <strong>后缀</strong> 0 的数目，并 <strong>移除</strong> 这些 0 ，将这个数目记为 <code>C</code> 。

	<ul>
<li>比方说，<code>1000</code> 中有 <code>3</code> 个后缀 0 ，<code>546</code> 中没有后缀 0 。</li>
</ul>
</li>
<li>将乘积中剩余数字的位数记为 <code>d</code> 。如果 <code>d &gt; 10</code> ，那么将乘积表示为 <code>&lt;pre&gt;...&lt;suf&gt;</code> 的形式，其中 <code>&lt;pre&gt;</code> 表示乘积最 <strong>开始</strong> 的 <code>5</code> 个数位，<code>&lt;suf&gt;</code> 表示删除后缀 0 <strong>之后</strong> 结尾的 <code>5</code> 个数位。如果 <code>d &lt;= 10</code> ，我们不对它做修改。
	<ul>
<li>比方说，我们将 <code>1234567654321</code> 表示为 <code>12345...54321</code> ，但是 <code>1234567</code> 仍然表示为 <code>1234567</code> 。</li>
</ul>
</li>
<li>最后，将乘积表示为 <strong>字符串</strong> <code>"&lt;pre&gt;...&lt;suf&gt;eC"</code> 。
	<ul>
<li>比方说，<code>12345678987600000</code> 被表示为 <code>"12345...89876e5"</code> 。</li>
</ul>
</li>
</ol>
<p>请你返回一个字符串，表示 <strong>闭区间</strong> <code>[left, right]</code> 中所有整数 <strong>乘积</strong> 的 <strong>缩写</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>left = 1, right = 4
<b>输出：</b>"24e0"
<strong>解释：</strong>
乘积为 1 × 2 × 3 × 4 = 24 。
由于没有后缀 0 ，所以 24 保持不变，缩写的结尾为 "e0" 。
因为乘积的结果是 2 位数，小于 10 ，所欲我们不进一步将它缩写。
所以，最终将乘积表示为 "24e0" 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>left = 2, right = 11
<strong>输出：</strong>"399168e2"
<strong>解释：</strong>乘积为 39916800 。
有 2 个后缀 0 ，删除后得到 399168 。缩写的结尾为 "e2" 。 
删除后缀 0 后是 6 位数，不需要进一步缩写。 
所以，最终将乘积表示为 "399168e2" 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>left = 371, right = 375
<strong>输出：</strong>"7219856259e3"
<strong>解释：</strong>乘积为 7219856259000 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>********************************<div id="title">2122. Recover the Original Array</div>
********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>Alice 有一个下标从 <strong>0</strong> 开始的数组 <code>arr</code> ，由 <code>n</code> 个正整数组成。她会选择一个任意的 <strong>正整数 </strong><code>k</code> 并按下述方式创建两个下标从 <strong>0</strong> 开始的新整数数组 <code>lower</code> 和 <code>higher</code> ：</p>
<ol>
<li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>lower[i] = arr[i] - k</code></li>
<li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>higher[i] = arr[i] + k</code></li>
</ol>
<p>不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 <code>lower</code> 和 <code>higher</code> 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。</p>
<p>给你一个由 2n 个整数组成的整数数组 <code>nums</code> ，其中 <strong>恰好</strong> <code>n</code> 个整数出现在 <code>lower</code> ，剩下的出现在 <code>higher</code> ，还原并返回 <strong>原数组</strong> <code>arr</code> 。如果出现答案不唯一的情况，返回 <strong>任一</strong> 有效数组。</p>
<p><strong>注意：</strong>生成的测试用例保证存在 <strong>至少一个</strong> 有效数组 <code>arr</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [2,10,6,4,8,12]
<strong>输出：</strong>[3,7,11]
<strong>解释：</strong>
如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。
组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。
另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,1,3,3]
<strong>输出：</strong>[2,2]
<strong>解释：</strong>
如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。
组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。
注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。
这种方案是无效的，k 必须是一个正整数。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [5,435]
<strong>输出：</strong>[220]
<strong>解释：</strong>
唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 * n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
<li>生成的测试用例保证存在 <strong>至少一个</strong> 有效数组 <code>arr</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************************<div id="title">2127. Maximum Employees to Be Invited to a Meeting</div>
**************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个公司准备组织一场会议，邀请名单上有 <code>n</code> 位员工。公司准备了一张 <strong>圆形</strong> 的桌子，可以坐下 <strong>任意数目</strong> 的员工。</p>
<p>员工编号为 <code>0</code> 到 <code>n - 1</code> 。每位员工都有一位 <strong>喜欢</strong> 的员工，每位员工 <strong>当且仅当</strong> 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 <strong>不会</strong> 是他自己。</p>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>favorite</code> ，其中 <code>favorite[i]</code> 表示第 <code>i</code> 位员工喜欢的员工。请你返回参加会议的 <strong>最多员工数目</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/12/14/ex1.png" style="width: 236px; height: 195px;"/></p>
<pre><b>输入：</b>favorite = [2,2,1,2]
<b>输出：</b>3
<strong>解释：</strong>
上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。
没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。
注意，公司也可以邀请员工 1，2 和 3 参加会议。
所以最多参加会议的员工数目为 3 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>favorite = [1,2,0]
<b>输出：</b>3
<b>解释：</b>
每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。
座位安排同图 1 所示：
- 员工 0 坐在员工 2 和 1 之间。
- 员工 1 坐在员工 0 和 2 之间。
- 员工 2 坐在员工 1 和 0 之间。
参与会议的最多员工数目为 3 。
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/12/14/ex2.png" style="width: 219px; height: 220px;"/></p>
<pre><b>输入：</b>favorite = [3,0,1,4,1]
<b>输出：</b>4
<b>解释：</b>
上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。
员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。
所以公司只能不邀请员工 2 。
参加会议的最多员工数目为 4 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == favorite.length</code></li>
<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= favorite[i] &lt;= n - 1</code></li>
<li><code>favorite[i] != i</code></li>
</ul>
</div></div></div><br><br><hr><br>***********************<div id="title">2132. Stamping the Grid</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，每个格子要么为 <code>0</code> （空）要么为 <code>1</code> （被占据）。</p>
<p>给你邮票的尺寸为 <code>stampHeight x stampWidth</code> 。我们想将邮票贴进二进制矩阵中，且满足以下 <strong>限制</strong> 和 <strong>要求</strong> ：</p>
<ol>
<li>覆盖所有 <strong>空</strong> 格子。</li>
<li>不覆盖任何 <strong>被占据 </strong>的格子。</li>
<li>我们可以放入任意数目的邮票。</li>
<li>邮票可以相互有 <strong>重叠</strong> 部分。</li>
<li>邮票不允许 <strong>旋转</strong> 。</li>
<li>邮票必须完全在矩阵 <strong>内</strong> 。</li>
</ol>
<p>如果在满足上述要求的前提下，可以放入邮票，请返回 <code>true</code> ，否则返回<i> </i><code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/11/03/ex1.png" style="width: 180px; height: 237px;"/></p>
<pre><b>输入：</b>grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3
<b>输出：</b>true
<b>解释：</b>我们放入两个有重叠部分的邮票（图中标号为 1 和 2），它们能覆盖所有与空格子。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/11/03/ex2.png" style="width: 170px; height: 179px;"/></p>
<pre><b>输入：</b>grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 
<b>输出：</b>false 
<b>解释：</b>没办法放入邮票覆盖所有的空格子，且邮票不超出网格图以外。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[r].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>
<li><code>grid[r][c]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>
<li><code>1 &lt;= stampHeight, stampWidth &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">2136. Earliest Possible Day of Full Bloom</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你有 <code>n</code> 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>plantTime</code> 和 <code>growTime</code> ，每个数组的长度都是 <code>n</code> ：</p>
<ul>
<li><code>plantTime[i]</code> 是 <strong>播种</strong> 第 <code>i</code> 枚种子所需的 <strong>完整天数</strong> 。每天，你只能为播种某一枚种子而劳作。<strong>无须</strong> 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 <code>plantTime[i]</code> 之后才算完成。</li>
<li><code>growTime[i]</code> 是第 <code>i</code> 枚种子完全种下后生长所需的 <strong>完整天数 </strong>。在它生长的最后一天 <strong>之后</strong> ，将会开花并且永远 <strong>绽放</strong> 。</li>
</ul>
<p>从第 <code>0</code> 开始，你可以按 <strong>任意</strong> 顺序播种种子。</p>
<p>返回所有种子都开花的 <strong>最早</strong> 一天是第几天。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/21/1.png" style="width: 453px; height: 149px;"/>
<pre><strong>输入：</strong>plantTime = [1,4,3], growTime = [2,3,1]
<strong>输出：</strong>9
<strong>解释：</strong>灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。
一种最优方案是：
第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。
第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。
第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。
因此，在第 9 天，所有种子都开花。 
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/12/21/2.png" style="width: 454px; height: 184px;"/>
<pre><strong>输入：</strong>plantTime = [1,2,3,2], growTime = [2,1,2,1]
<strong>输出：</strong>9
<strong>解释：</strong>灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 
一种最优方案是：
第 1 天，播种第 0 枚种子，种子生长 2 整天。并在第 4 天开花。
第 0、3 天，播种第 1 枚种子。种子生长 1 整天，并在第 5 天开花。
第 2、4、5 天，播种第 2 枚种子。种子生长 2 整天，并在第 8 天开花。
第 6、7 天，播种第 3 枚种子。种子生长 1 整天，并在第 9 天开花。
因此，在第 9 天，所有种子都开花。 
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>plantTime = [1], growTime = [1]
<strong>输出：</strong>2
<strong>解释：</strong>第 0 天，播种第 0 枚种子。种子需要生长 1 整天，然后在第 2 天开花。
因此，在第 2 天，所有种子都开花。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == plantTime.length == growTime.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= plantTime[i], growTime[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">2141. Maximum Running Time of N Computers</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你有 <code>n</code> 台电脑。给你整数 <code>n</code> 和一个下标从 <strong>0</strong> 开始的整数数组 <code>batteries</code> ，其中第 <code>i</code> 个电池可以让一台电脑 <strong>运行 </strong><code>batteries[i]</code> 分钟。你想使用这些电池让 <strong>全部</strong> <code>n</code> 台电脑 <b>同时</b> 运行。</p>
<p>一开始，你可以给每台电脑连接 <strong>至多一个电池</strong> 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 <strong>任意次</strong> 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p>
<p>注意，你不能给电池充电。</p>
<p>请你返回你可以让 <code>n</code> 台电脑同时运行的 <strong>最长</strong> 分钟数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png" style="width: 762px; height: 150px;"/></p>
<pre><b>输入：</b>n = 2, batteries = [3,3,3]
<b>输出：</b>4
<b>解释：</b>
一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 1 连接。
2 分钟后，将第二台电脑与电池 1 断开连接，并连接电池 2 。注意，电池 0 还可以供电 1 分钟。
在第 3 分钟结尾，你需要将第一台电脑与电池 0 断开连接，然后连接电池 1 。
在第 4 分钟结尾，电池 1 也被耗尽，第一台电脑无法继续运行。
我们最多能同时让两台电脑同时运行 4 分钟，所以我们返回 4 。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/01/06/example2.png" style="width: 629px; height: 150px;"/></p>
<pre><b>输入：</b>n = 2, batteries = [1,1,1,1]
<b>输出：</b>2
<b>解释：</b>
一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 2 连接。
一分钟后，电池 0 和电池 2 同时耗尽，所以你需要将它们断开连接，并将电池 1 和第一台电脑连接，电池 3 和第二台电脑连接。
1 分钟后，电池 1 和电池 3 也耗尽了，所以两台电脑都无法继续运行。
我们最多能让两台电脑同时运行 2 分钟，所以我们返回 2 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= batteries.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= batteries[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">2147. Number of Ways to Divide a Long Corridor</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在一个图书馆的长廊里，有一些座位和装饰植物排成一列。给你一个下标从 <strong>0</strong> 开始，长度为 <code>n</code> 的字符串 <code>corridor</code> ，它包含字母 <code>'S'</code> 和 <code>'P'</code> ，其中每个 <code>'S'</code> 表示一个座位，每个 <code>'P'</code> 表示一株植物。</p>
<p>在下标 <code>0</code> 的左边和下标 <code>n - 1</code> 的右边 <strong>已经</strong> 分别各放了一个屏风。你还需要额外放置一些屏风。每一个位置 <code>i - 1</code> 和 <code>i</code> 之间（<code>1 &lt;= i &lt;= n - 1</code>），至多能放一个屏风。</p>
<p>请你将走廊用屏风划分为若干段，且每一段内都 <strong>恰好有两个座位</strong> ，而每一段内植物的数目没有要求。可能有多种划分方案，如果两个方案中有任何一个屏风的位置不同，那么它们被视为 <strong>不同</strong> 方案。</p>
<p>请你返回划分走廊的方案数。由于答案可能很大，请你返回它对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。如果没有任何方案，请返回 <code>0</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/12/04/1.png" style="width: 410px; height: 199px;"/></p>
<pre><b>输入：</b>corridor = "SSPPSPS"
<b>输出：</b>3
<b>解释：</b>总共有 3 种不同分隔走廊的方案。
上图中黑色的竖线表示已经放置好的屏风。
上图每种方案中，每一段都恰好有 <strong>两个</strong> 座位。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/12/04/2.png" style="width: 357px; height: 68px;"/></p>
<pre><b>输入：</b>corridor = "PPSPSP"
<b>输出：</b>1
<b>解释：</b>只有 1 种分隔走廊的方案，就是不放置任何屏风。
放置任何的屏风都会导致有一段无法恰好有 2 个座位。
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/12/12/3.png" style="width: 115px; height: 68px;"/></p>
<pre><b>输入：</b>corridor = "S"
<b>输出：</b>0
<b>解释：</b>没有任何方案，因为总是有一段无法恰好有 2 个座位。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == corridor.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>corridor[i]</code> 要么是 <code>'S'</code> ，要么是 <code>'P'</code> 。</li>
</ul>
</div></div></div><br><br><hr><br>*********************************************<div id="title">2151. Maximum Good People Based on Statements</div>
*********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>游戏中存在两种角色：</p>
<ul>
<li><strong>好人</strong>：该角色只说真话。</li>
<li><strong>坏人</strong>：该角色可能说真话，也可能说假话。</li>
</ul>
<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>statements</code> ，大小为 <code>n x n</code> ，表示 <code>n</code> 个玩家对彼此角色的陈述。具体来说，<code>statements[i][j]</code> 可以是下述值之一：</p>
<ul>
<li><code>0</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>坏人</strong> 。</li>
<li><code>1</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>好人</strong> 。</li>
<li><code>2</code> 表示 <code>i</code> 没有对 <code>j</code> 作出陈述。</li>
</ul>
<p>另外，玩家不会对自己进行陈述。形式上，对所有 <code>0 &lt;= i &lt; n</code> ，都有 <code>statements[i][i] = 2</code> 。</p>
<p>根据这 <code>n</code> 个玩家的陈述，返回可以认为是 <strong>好人</strong> 的 <strong>最大</strong> 数目。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/01/15/logic1.jpg" style="width: 600px; height: 262px;"/>
<pre><strong>输入：</strong>statements = [[2,1,2],[1,2,2],[2,0,2]]
<strong>输出：</strong>2
<strong>解释：</strong>每个人都做一条陈述。
- 0 认为 1 是好人。
- 1 认为 0 是好人。
- 2 认为 1 是坏人。
以 2 为突破点。
- 假设 2 是一个好人：
    - 基于 2 的陈述，1 是坏人。
    - 那么可以确认 1 是坏人，2 是好人。
    - 基于 1 的陈述，由于 1 是坏人，那么他在陈述时可能：
        - 说真话。在这种情况下会出现矛盾，所以假设无效。
        - 说假话。在这种情况下，0 也是坏人并且在陈述时说假话。
    - <strong>在认为 2 是好人的情况下，这组玩家中只有一个好人。</strong>
- 假设 2 是一个坏人：
    - 基于 2 的陈述，由于 2 是坏人，那么他在陈述时可能：
        - 说真话。在这种情况下，0 和 1 都是坏人。
            - <strong>在认为 2 是坏人但说真话的情况下，这组玩家中没有一个好人。</strong>
        - 说假话。在这种情况下，1 是好人。
            - 由于 1 是好人，0 也是好人。
            - <strong>在认为 2 是坏人且说假话的情况下，这组玩家中有两个好人。</strong>
在最佳情况下，至多有两个好人，所以返回 2 。
注意，能得到此结论的方法不止一种。
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2022/01/15/logic2.jpg" style="width: 600px; height: 262px;"/>
<pre><strong>输入：</strong>statements = [[2,0],[0,2]]
<strong>输出：</strong>1
<strong>解释：</strong>每个人都做一条陈述。
- 0 认为 1 是坏人。
- 1 认为 0 是坏人。
以 0 为突破点。
- 假设 0 是一个好人：
    - 基于与 0 的陈述，1 是坏人并说假话。
    - <strong>在认为 0 是好人的情况下，这组玩家中只有一个好人。</strong>
- 假设 0 是一个坏人：
    - 基于 0 的陈述，由于 0 是坏人，那么他在陈述时可能：
        - 说真话。在这种情况下，0 和 1 都是坏人。
            - <strong>在认为 0 是坏人但说真话的情况下，这组玩家中没有一个好人。</strong>
        - 说假话。在这种情况下，1 是好人。
            - <strong>在认为 0 是坏人且说假话的情况下，这组玩家中只有一个好人。</strong>
在最佳情况下，至多有一个好人，所以返回 1 。 
注意，能得到此结论的方法不止一种。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == statements.length == statements[i].length</code></li>
<li><code>2 &lt;= n &lt;= 15</code></li>
<li><code>statements[i][j]</code> 的值为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
<li><code>statements[i][i] == 2</code></li>
</ul>
</div></div></div><br><br><hr><br>******************************************<div id="title">2156. Find Substring With Given Hash Value</div>
******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定整数 <code>p</code> 和 <code>m</code> ，一个长度为 <code>k</code> 且下标从 <strong>0</strong> 开始的字符串 <code>s</code> 的哈希值按照如下函数计算：</p>
<ul>
<li><code>hash(s, p, m) = (val(s[0]) * p<sup>0</sup> + val(s[1]) * p<sup>1</sup> + ... + val(s[k-1]) * p<sup>k-1</sup>) mod m</code>.</li>
</ul>
<p>其中 <code>val(s[i])</code> 表示 <code>s[i]</code> 在字母表中的下标，从 <code>val('a') = 1</code> 到 <code>val('z') = 26</code> 。</p>
<p>给你一个字符串 <code>s</code> 和整数 <code>power</code>，<code>modulo</code>，<code>k</code> 和 <code>hashValue</code> 。请你返回 <code>s</code> 中 <strong>第一个</strong> 长度为 <code>k</code> 的 <strong>子串</strong> <code>sub</code> ，满足<em> </em><code>hash(sub, power, modulo) == hashValue</code> 。</p>
<p>测试数据保证一定 <strong>存在</strong> 至少一个这样的子串。</p>
<p><strong>子串</strong> 定义为一个字符串中连续非空字符组成的序列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>s = "leetcode", power = 7, modulo = 20, k = 2, hashValue = 0
<strong>输出：</strong>"ee"
<strong>解释：</strong>"ee" 的哈希值为 hash("ee", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。
"ee" 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 "ee" 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>s = "fbxzaad", power = 31, modulo = 100, k = 3, hashValue = 32
<b>输出：</b>"fbx"
<b>解释：</b>"fbx" 的哈希值为 hash("fbx", 31, 100) = (6 * 1 + 2 * 31 + 24 * 31<sup>2</sup>) mod 100 = 23132 mod 100 = 32 。
"bxz" 的哈希值为 hash("bxz", 31, 100) = (2 * 1 + 24 * 31 + 26 * 31<sup>2</sup>) mod 100 = 25732 mod 100 = 32 。
"fbx" 是长度为 3 的第一个哈希值为 32 的子串，所以我们返回 "fbx" 。
注意，"bxz" 的哈希值也为 32 ，但是它在字符串中比 "fbx" 更晚出现。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= s.length &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= power, modulo &lt;= 10<sup>9</sup></code></li>
<li><code>0 &lt;= hashValue &lt; modulo</code></li>
<li><code>s</code> 只包含小写英文字母。</li>
<li>测试数据保证一定 <strong>存在</strong> 满足条件的子串。</li>
</ul>
</div></div></div><br><br><hr><br>***********************<div id="title">2157. Groups of Strings</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0 </strong>开始的字符串数组 <code>words</code> 。每个字符串都只包含 <strong>小写英文字母</strong> 。<code>words</code> 中任意一个子串中，每个字母都至多只出现一次。</p>
<p>如果通过以下操作之一，我们可以从 <code>s1</code> 的字母集合得到 <code>s2</code> 的字母集合，那么我们称这两个字符串为 <strong>关联的</strong> ：</p>
<ul>
<li>往 <code>s1</code> 的字母集合中添加一个字母。</li>
<li>从 <code>s1</code> 的字母集合中删去一个字母。</li>
<li>将 <code>s1</code> 中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。</li>
</ul>
<p>数组 <code>words</code> 可以分为一个或者多个无交集的 <strong>组</strong> 。如果一个字符串与另一个字符串关联，那么它们应当属于同一个组。</p>
<p>注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。</p>
<p>请你返回一个长度为 <code>2</code> 的数组 <code>ans</code> ：</p>
<ul>
<li><code>ans[0]</code> 是 <code>words</code> 分组后的 <strong>总组数</strong> 。</li>
<li><code>ans[1]</code> 是字符串数目最多的组所包含的字符串数目。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>words = ["a","b","ab","cde"]
<b>输出：</b>[2,3]
<b>解释：</b>
- words[0] 可以得到 words[1] （将 'a' 替换为 'b'）和 words[2] （添加 'b'）。所以 words[0] 与 words[1] 和 words[2] 关联。
- words[1] 可以得到 words[0] （将 'b' 替换为 'a'）和 words[2] （添加 'a'）。所以 words[1] 与 words[0] 和 words[2] 关联。
- words[2] 可以得到 words[0] （删去 'b'）和 words[1] （删去 'a'）。所以 words[2] 与 words[0] 和 words[1] 关联。
- words[3] 与 words 中其他字符串都不关联。
所以，words 可以分成 2 个组 ["a","b","ab"] 和 ["cde"] 。最大的组大小为 3 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>words = ["a","ab","abc"]
<b>输出：</b>[1,3]
<strong>解释：</strong>
- words[0] 与 words[1] 关联。
- words[1] 与 words[0] 和 words[2] 关联。
- words[2] 与 words[1] 关联。
由于所有字符串与其他字符串都关联，所以它们全部在同一个组内。
所以最大的组大小为 3 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= words[i].length &lt;= 26</code></li>
<li><code>words[i]</code> 只包含小写英文字母。</li>
<li><code>words[i]</code> 中每个字母最多只出现一次。</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************************<div id="title">2163. Minimum Difference in Sums After Removal of Elements</div>
**********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，它包含 <code>3 * n</code> 个元素。</p>
<p>你可以从 <code>nums</code> 中删除 <strong>恰好</strong> <code>n</code> 个元素，剩下的 <code>2 * n</code> 个元素将会被分成两个 <strong>相同大小</strong> 的部分。</p>
<ul>
<li>前面 <code>n</code> 个元素属于第一部分，它们的和记为 <code>sum<sub>first</sub></code> 。</li>
<li>后面 <code>n</code> 个元素属于第二部分，它们的和记为 <code>sum<sub>second</sub></code> 。</li>
</ul>
<p>两部分和的 <strong>差值</strong> 记为 <code>sum<sub>first</sub> - sum<sub>second</sub></code> 。</p>
<ul>
<li>比方说，<code>sum<sub>first</sub> = 3</code> 且 <code>sum<sub>second</sub> = 2</code> ，它们的差值为 <code>1</code> 。</li>
<li>再比方，<code>sum<sub>first</sub> = 2</code> 且 <code>sum<sub>second</sub> = 3</code> ，它们的差值为 <code>-1</code> 。</li>
</ul>
<p>请你返回删除 <code>n</code> 个元素之后，剩下两部分和的 <strong>差值的最小值</strong> 是多少。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [3,1,2]
<b>输出：</b>-1
<b>解释：</b>nums 有 3 个元素，所以 n = 1 。
所以我们需要从 nums 中删除 1 个元素，并将剩下的元素分成两部分。
- 如果我们删除 nums[0] = 3 ，数组变为 [1,2] 。两部分和的差值为 1 - 2 = -1 。
- 如果我们删除 nums[1] = 1 ，数组变为 [3,2] 。两部分和的差值为 3 - 2 = 1 。
- 如果我们删除 nums[2] = 2 ，数组变为 [3,1] 。两部分和的差值为 3 - 1 = 2 。
两部分和的最小差值为 min(-1,1,2) = -1 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [7,9,5,8,1,3]
<b>输出：</b>1
<b>解释：</b>n = 2 。所以我们需要删除 2 个元素，并将剩下元素分为 2 部分。
如果我们删除元素 nums[2] = 5 和 nums[3] = 8 ，剩下元素为 [7,9,1,3] 。和的差值为 (7+9) - (1+3) = 12 。
为了得到最小差值，我们应该删除 nums[1] = 9 和 nums[4] = 1 ，剩下的元素为 [7,5,8,3] 。和的差值为 (7+5) - (8+3) = 1 。
观察可知，最优答案为 1 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>nums.length == 3 * n</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************************************<div id="title">2167. Minimum Time to Remove All Cars Containing Illegal Goods</div>
**************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始的二进制字符串 <code>s</code> ，表示一个列车车厢序列。<code>s[i] = '0'</code> 表示第 <code>i</code> 节车厢 <strong>不</strong> 含违禁货物，而 <code>s[i] = '1'</code> 表示第 <code>i</code> 节车厢含违禁货物。</p>
<p>作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：</p>
<ol>
<li>从列车 <strong>左</strong> 端移除一节车厢（即移除 <code>s[0]</code>），用去 1 单位时间。</li>
<li>从列车 <strong>右</strong> 端移除一节车厢（即移除 <code>s[s.length - 1]</code>），用去 1 单位时间。</li>
<li>从列车车厢序列的 <strong>任意位置</strong> 移除一节车厢，用去 2 单位时间。</li>
</ol>
<p>返回移除所有载有违禁货物车厢所需要的 <strong>最少</strong> 单位时间数。</p>
<p>注意，空的列车车厢序列视为没有车厢含违禁货物。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "<em><strong>11</strong></em>00<em><strong>1</strong></em>0<em><strong>1</strong></em>"
<strong>输出：</strong>5
<strong>解释：</strong>
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 1 次。所用时间是 1 。
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2 + 1 + 2 = 5 。

一种替代方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间也是 2 + 3 = 5 。

5 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "00<em><strong>1</strong></em>0"
<strong>输出：</strong>2
<strong>解释：</strong>
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间是 3.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从右端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
总时间是 2.

2 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>
<li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">2172. Maximum AND Sum of Array</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>numSlots</code> ，满足<code>2 * numSlots &gt;= n</code> 。总共有 <code>numSlots</code> 个篮子，编号为 <code>1</code> 到 <code>numSlots</code> 。</p>
<p>你需要把所有 <code>n</code> 个整数分到这些篮子中，且每个篮子 <strong>至多</strong> 有 2 个整数。一种分配方案的 <strong>与和</strong> 定义为每个数与它所在篮子编号的 <strong>按位与运算</strong> 结果之和。</p>
<ul>
<li>比方说，将数字 <code>[1, 3]</code> 放入篮子 <strong><em><code>1</code></em></strong> 中，<code>[4, 6]</code> 放入篮子 <strong><em><code>2</code></em></strong> 中，这个方案的与和为 <code>(1 AND <strong><em>1</em></strong>) + (3 AND <strong><em>1</em></strong>) + (4 AND <em><strong>2</strong></em>) + (6 AND <em><strong>2</strong></em>) = 1 + 1 + 0 + 2 = 4</code> 。</li>
</ul>
<p>请你返回将 <code>nums</code> 中所有数放入<em> </em><code>numSlots</code> 个篮子中的最大与和。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums = [1,2,3,4,5,6], numSlots = 3
<b>输出：</b>9
<b>解释：</b>一个可行的方案是 [1, 4] 放入篮子 <em><strong>1</strong></em> 中，[2, 6] 放入篮子 <strong><em>2</em></strong> 中，[3, 5] 放入篮子 <strong><em>3</em></strong> 中。
最大与和为 (1 AND <strong><em>1</em></strong>) + (4 AND <strong><em>1</em></strong>) + (2 AND <strong><em>2</em></strong>) + (6 AND <strong><em>2</em></strong>) + (3 AND <strong><em>3</em></strong>) + (5 AND <em><strong>3</strong></em>) = 1 + 0 + 2 + 2 + 3 + 1 = 9 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums = [1,3,10,4,7,1], numSlots = 9
<b>输出：</b>24
<b>解释：</b>一个可行的方案是 [1, 1] 放入篮子 <em><strong>1</strong></em> 中，[3] 放入篮子 <em><strong>3</strong></em> 中，[4] 放入篮子 <strong><em>4</em></strong> 中，[7] 放入篮子 <strong><em>7</em></strong> 中，[10] 放入篮子 <strong><em>9</em></strong> 中。
最大与和为 (1 AND <strong><em>1</em></strong>) + (1 AND <strong><em>1</em></strong>) + (3 AND <strong><em>3</em></strong>) + (4 AND <strong><em>4</em></strong>) + (7 AND <strong><em>7</em></strong>) + (10 AND <strong><em>9</em></strong>) = 1 + 1 + 3 + 4 + 7 + 8 = 24 。
注意，篮子 2 ，5 ，6 和 8 是空的，这是允许的。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= numSlots &lt;= 9</code></li>
<li><code>1 &lt;= n &lt;= 2 * numSlots</code></li>
<li><code>1 &lt;= nums[i] &lt;= 15</code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************<div id="title">2179. Count Good Triplets in an Array</div>
*************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>nums1</code> 和 <code>nums2</code> ，两者都是 <code>[0, 1, ..., n - 1]</code> 的 <strong>排列</strong> 。</p>
<p><strong>好三元组 </strong>指的是 <code>3</code> 个 <strong>互不相同</strong> 的值，且它们在数组 <code>nums1</code> 和 <code>nums2</code> 中出现顺序保持一致。换句话说，如果我们将 <code>pos1<sub>v</sub></code> 记为值 <code>v</code> 在 <code>nums1</code> 中出现的位置，<code>pos2<sub>v</sub></code> 为值 <code>v</code> 在 <code>nums2</code> 中的位置，那么一个好三元组定义为 <code>0 &lt;= x, y, z &lt;= n - 1</code> ，且 <code>pos1<sub>x</sub> &lt; pos1<sub>y</sub> &lt; pos1<sub>z</sub></code> 和 <code>pos2<sub>x</sub> &lt; pos2<sub>y</sub> &lt; pos2<sub>z</sub></code> 都成立的 <code>(x, y, z)</code> 。</p>
<p>请你返回好三元组的 <strong>总数目</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>nums1 = [2,0,1,3], nums2 = [0,1,2,3]
<b>输出：</b>1
<b>解释：</b>
总共有 4 个三元组 (x,y,z) 满足 pos1<sub>x</sub> &lt; pos1<sub>y</sub> &lt; pos1<sub>z </sub>，分别是 (2,0,1) ，(2,0,3) ，(2,1,3) 和 (0,1,3) 。
这些三元组中，只有 (0,1,3) 满足 pos2<sub>x</sub> &lt; pos2<sub>y</sub> &lt; pos2<sub>z</sub> 。所以只有 1 个好三元组。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]
<b>输出：</b>4
<b>解释：</b>总共有 4 个好三元组 (4,0,3) ，(4,0,2) ，(4,1,3) 和 (4,1,2) 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length == nums2.length</code></li>
<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= n - 1</code></li>
<li><code>nums1</code> 和 <code>nums2</code> 是 <code>[0, 1, ..., n - 1]</code> 的排列。</li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">2183. Count Array Pairs Divisible by K</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回满足下述条件的下标对 <code>(i, j)</code> 的数目：</p>
<ul>
<li><code>0 &lt;= i &lt; j &lt;= n - 1</code> 且</li>
<li><code>nums[i] * nums[j]</code> 能被 <code>k</code> 整除。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,3,4,5], k = 2
<strong>输出：</strong>7
<strong>解释：</strong>
共有 7 对下标的对应积可以被 2 整除：
(0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4)
它们的积分别是 2、4、6、8、10、12 和 20 。
其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15 ，都无法被 2 整除。    
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,2,3,4], k = 5
<strong>输出：</strong>0
<strong>解释：</strong>不存在对应积可以被 5 整除的下标对。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i], k &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************<div id="title">2188. Minimum Time to Finish the Race</div>
*************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>tires</code> ，其中 <code>tires[i] = [f<sub>i</sub>, r<sub>i</sub>]</code> 表示第 <code>i</code> 种轮胎如果连续使用，第 <code>x</code> 圈需要耗时 <code>f<sub>i</sub> * r<sub>i</sub><sup>(x-1)</sup></code> 秒。</p>
<ul>
<li>比方说，如果 <code>f<sub>i</sub> = 3</code> 且 <code>r<sub>i</sub> = 2</code> ，且一直使用这种类型的同一条轮胎，那么该轮胎完成第 <code>1</code> 圈赛道耗时 <code>3</code> 秒，完成第 <code>2</code> 圈耗时 <code>3 * 2 = 6</code> 秒，完成第 <code>3</code> 圈耗时 <code>3 * 2<sup>2</sup> = 12</code> 秒，依次类推。</li>
</ul>
<p>同时给你一个整数 <code>changeTime</code> 和一个整数 <code>numLaps</code> 。</p>
<p>比赛总共包含 <code>numLaps</code> 圈，你可以选择 <strong>任意</strong> 一种轮胎开始比赛。每一种轮胎都有 <strong>无数条</strong> 。每一圈后，你可以选择耗费 <code>changeTime</code> 秒 <strong>换成</strong> 任意一种轮胎（也可以换成当前种类的新轮胎）。</p>
<p>请你返回完成比赛需要耗费的 <strong>最少</strong> 时间。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4
<b>输出：</b>21
<b>解释：</b>
第 1 圈：使用轮胎 0 ，耗时 2 秒。
第 2 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。
第 3 圈：耗费 5 秒换一条新的轮胎 0 ，然后耗时 2 秒完成这一圈。
第 4 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。
总耗时 = 2 + 6 + 5 + 2 + 6 = 21 秒。
完成比赛的最少时间为 21 秒。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5
<b>输出：</b>25
<b>解释：</b>
第 1 圈：使用轮胎 1 ，耗时 2 秒。
第 2 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。
第 3 圈：耗时 6 秒换一条新的轮胎 1 ，然后耗时 2 秒完成这一圈。
第 4 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。
第 5 圈：耗时 6 秒换成轮胎 0 ，然后耗时 1 秒完成这一圈。
总耗时 = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 秒。
完成比赛的最少时间为 25 秒。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tires.length &lt;= 10<sup>5</sup></code></li>
<li><code>tires[i].length == 2</code></li>
<li><code>1 &lt;= f<sub>i</sub>, changeTime &lt;= 10<sup>5</sup></code></li>
<li><code>2 &lt;= r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= numLaps &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************************<div id="title">2193. Minimum Number of Moves to Make Palindrome</div>
************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个只包含小写英文字母的字符串 <code>s</code> 。</p>
<p>每一次 <strong>操作</strong> ，你可以选择 <code>s</code> 中两个 <strong>相邻</strong> 的字符，并将它们交换。</p>
<p>请你返回将 <code>s</code> 变成回文串的 <strong>最少操作次数</strong> 。</p>
<p><strong>注意</strong> ，输入数据会确保 <code>s</code> 一定能变成一个回文串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>s = "aabb"
<b>输出：</b>2
<strong>解释：</strong>
我们可以将 s 变成 2 个回文串，"abba" 和 "baab" 。
- 我们可以通过 2 次操作得到 "abba" ："a<em><strong>ab</strong></em>b" -&gt; "ab<em><strong>ab</strong></em>" -&gt; "abba" 。
- 我们可以通过 2 次操作得到 "baab" ："a<em><strong>ab</strong></em>b" -&gt; "<em><strong>ab</strong></em>ab" -&gt; "baab" 。
因此，得到回文串的最少总操作次数为 2 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>s = "letelt"
<b>输出：</b>2
<strong>解释：</strong>
通过 2 次操作从 s 能得到回文串 "lettel" 。
其中一种方法是："lete<em><strong>lt</strong></em>" -&gt; "let<em><strong>et</strong></em>l" -&gt; "lettel" 。
其他回文串比方说 "tleelt" 也可以通过 2 次操作得到。
可以证明少于 2 次操作，无法得到回文串。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 只包含小写英文字母。</li>
<li><code>s</code> 可以通过有限次操作得到一个回文串。</li>
</ul>
</div></div></div><br><br><hr><br>******************************************<div id="title">2197. Replace Non-Coprime Numbers in Array</div>
******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 。请你对数组执行下述操作：</p>
<ol>
<li>从 <code>nums</code> 中找出 <strong>任意</strong> 两个 <strong>相邻</strong> 的 <strong>非互质</strong> 数。</li>
<li>如果不存在这样的数，<strong>终止</strong> 这一过程。</li>
<li>否则，删除这两个数，并 <strong>替换</strong> 为它们的 <strong>最小公倍数</strong>（Least Common Multiple，LCM）。</li>
<li>只要还能找出两个相邻的非互质数就继续 <strong>重复</strong> 这一过程。</li>
</ol>
<p>返回修改后得到的 <strong>最终</strong> 数组。可以证明的是，以 <strong>任意</strong> 顺序替换相邻的非互质数都可以得到相同的结果。</p>
<p>生成的测试用例可以保证最终数组中的值 <strong>小于或者等于</strong> <code>10<sup>8</sup></code> 。</p>
<p>两个数字 <code>x</code> 和 <code>y</code> 满足 <strong>非互质数</strong> 的条件是：<code>GCD(x, y) &gt; 1</code> ，其中 <code>GCD(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的 <strong>最大公约数</strong> 。</p>
<p> </p>
<p><strong>示例 1 ：</strong></p>
<pre><strong>输入：</strong>nums = [6,4,3,2,7,6,2]
<strong>输出：</strong>[12,7,6]
<strong>解释：</strong>
- (6, 4) 是一组非互质数，且 LCM(6, 4) = 12 。得到 nums = [<em><strong>12</strong></em>,3,2,7,6,2] 。
- (12, 3) 是一组非互质数，且 LCM(12, 3) = 12 。得到 nums = [<em><strong>12</strong></em>,2,7,6,2] 。
- (12, 2) 是一组非互质数，且 LCM(12, 2) = 12 。得到 nums = [<em><strong>12</strong></em>,7,6,2] 。
- (6, 2) 是一组非互质数，且 LCM(6, 2) = 6 。得到 nums = [12,7,<em><strong>6</strong></em>] 。
现在，nums 中不存在相邻的非互质数。
因此，修改后得到的最终数组是 [12,7,6] 。
注意，存在其他方法可以获得相同的最终数组。
</pre>
<p><strong>示例 2 ：</strong></p>
<pre><strong>输入：</strong>nums = [2,2,1,1,3,3,3]
<strong>输出：</strong>[2,1,1,3]
<strong>解释：</strong>
- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,<em><strong>3</strong></em>,3] 。
- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,<em><strong>3</strong></em>] 。
- (2, 2) 是一组非互质数，且 LCM(2, 2) = 2 。得到 nums = [<em><strong>2</strong></em>,1,1,3] 。
现在，nums 中不存在相邻的非互质数。 
因此，修改后得到的最终数组是 [2,1,1,3] 。 
注意，存在其他方法可以获得相同的最终数组。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
<li>生成的测试用例可以保证最终数组中的值 <strong>小于或者等于</strong> <code>10<sup>8</sup></code> 。</li>
</ul>
</div></div></div><br><br><hr><br>*******************************************************<div id="title">2203. Minimum Weighted Subgraph With the Required Paths</div>
*******************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数 <code>n</code> ，它表示一个 <strong>带权有向</strong> 图的节点数，节点编号为 <code>0</code> 到 <code>n - 1</code> 。</p>
<p>同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> ，表示从 <code>from<sub>i</sub></code> 到 <code>to<sub>i</sub></code> 有一条边权为 <code>weight<sub>i</sub></code> 的 <strong>有向</strong> 边。</p>
<p>最后，给你三个 <strong>互不相同</strong> 的整数 <code>src1</code> ，<code>src2</code> 和 <code>dest</code> ，表示图中三个不同的点。</p>
<p>请你从图中选出一个 <b>边权和最小</b> 的子图，使得从 <code>src1</code> 和 <code>src2</code> 出发，在这个子图中，都 <strong>可以</strong> 到达 <code>dest</code> 。如果这样的子图不存在，请返回 <code>-1</code> 。</p>
<p><strong>子图</strong> 中的点和边都应该属于原图的一部分。子图的边权和定义为它所包含的所有边的权值之和。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png" style="width: 263px; height: 250px;"/></p>
<pre><b>输入：</b>n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5
<b>输出：</b>9
<strong>解释：</strong>
上图为输入的图。
蓝色边为最优子图之一。
注意，子图 [[1,0,3],[0,5,6]] 也能得到最优解，但无法在满足所有限制的前提下，得到更优解。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png" style="width: 350px; height: 51px;"/></p>
<pre><b>输入：</b>n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2
<b>输出：</b>-1
<strong>解释：</strong>
上图为输入的图。
可以看到，不存在从节点 1 到节点 2 的路径，所以不存在任何子图满足所有限制。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
<li><code>edges[i].length == 3</code></li>
<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, src1, src2, dest &lt;= n - 1</code></li>
<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
<li><code>src1</code> ，<code>src2</code> 和 <code>dest</code> 两两不同。</li>
<li><code>1 &lt;= weight[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************************<div id="title">2209. Minimum White Tiles After Covering With Carpets</div>
*****************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从<strong> 0</strong> 开始的 <strong>二进制</strong> 字符串 <code>floor</code> ，它表示地板上砖块的颜色。</p>
<ul>
<li><code>floor[i] = '0'</code> 表示地板上第 <code>i</code> 块砖块的颜色是 <strong>黑色</strong> 。</li>
<li><code>floor[i] = '1'</code> 表示地板上第 <code>i</code> 块砖块的颜色是 <strong>白色</strong> 。</li>
</ul>
<p>同时给你 <code>numCarpets</code> 和 <code>carpetLen</code> 。你有 <code>numCarpets</code> 条 <strong>黑色</strong> 的地毯，每一条 <strong>黑色</strong> 的地毯长度都为 <code>carpetLen</code> 块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余 <strong>白色</strong> 砖块的数目 <strong>最小</strong> 。地毯相互之间可以覆盖。</p>
<p>请你返回没被覆盖的白色砖块的 <strong>最少</strong> 数目。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png" style="width: 400px; height: 73px;"/></p>
<pre><b>输入：</b>floor = "10110101", numCarpets = 2, carpetLen = 2
<b>输出：</b>2
<b>解释：</b>
上图展示了剩余 2 块白色砖块的方案。
没有其他方案可以使未被覆盖的白色砖块少于 2 块。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/02/10/ex2.png" style="width: 353px; height: 123px;"/></p>
<pre><b>输入：</b>floor = "11111", numCarpets = 2, carpetLen = 3
<b>输出：</b>0
<b>解释：</b>
上图展示了所有白色砖块都被覆盖的一种方案。
注意，地毯相互之间可以覆盖。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= carpetLen &lt;= floor.length &lt;= 1000</code></li>
<li><code>floor[i]</code> 要么是 <code>'0'</code> ，要么是 <code>'1'</code> 。</li>
<li><code>1 &lt;= numCarpets &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************************<div id="title">2213. Longest Substring of One Repeating Character</div>
**************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>k</code> 的字符串 <code>queryCharacters</code> ，一个下标从 <code>0</code> 开始、长度也是 <code>k</code> 的整数 <strong>下标</strong> 数组 <code>queryIndices</code> ，这两个都用来描述 <code>k</code> 个查询。</p>
<p>第 <code>i</code> 个查询会将 <code>s</code> 中位于下标 <code>queryIndices[i]</code> 的字符更新为 <code>queryCharacters[i]</code> 。</p>
<p>返回一个长度为 <code>k</code> 的数组 <code>lengths</code> ，其中 <code>lengths[i]</code> 是在执行第 <code>i</code> 个查询 <strong>之后</strong> <code>s</code> 中仅由 <strong>单个字符重复</strong> 组成的 <strong>最长子字符串</strong> 的 <strong>长度</strong> <em>。</em></p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "babacc", queryCharacters = "bcb", queryIndices = [1,3,3]
<strong>输出：</strong>[3,3,4]
<strong>解释：</strong>
- 第 1 次查询更新后 s = "<em>b<strong>b</strong>b</em>acc" 。由单个字符重复组成的最长子字符串是 "bbb" ，长度为 3 。
- 第 2 次查询更新后 s = "bbb<em><strong>c</strong>cc</em>" 。由单个字符重复组成的最长子字符串是 "bbb" 或 "ccc"，长度为 3 。
- 第 3 次查询更新后 s = "<em>bbb<strong>b</strong></em>cc" 。由单个字符重复组成的最长子字符串是 "bbbb" ，长度为 4 。
因此，返回 [3,3,4] 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "abyzz", queryCharacters = "aa", queryIndices = [2,1]
<strong>输出：</strong>[2,3]
<strong>解释：</strong>
- 第 1 次查询更新后 s = "ab<strong>a</strong><em>zz</em>" 。由单个字符重复组成的最长子字符串是 "zz" ，长度为 2 。
- 第 2 次查询更新后 s = "<em>a<strong>a</strong>a</em>zz" 。由单个字符重复组成的最长子字符串是 "aaa" ，长度为 3 。
因此，返回 [2,3] 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
<li><code>s</code> 由小写英文字母组成</li>
<li><code>k == queryCharacters.length == queryIndices.length</code></li>
<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>
<li><code>queryCharacters</code> 由小写英文字母组成</li>
<li><code>0 &lt;= queryIndices[i] &lt; s.length</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">2218. Maximum Value of K Coins From Piles</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一张桌子上总共有 <code>n</code> 个硬币 <b>栈</b> 。每个栈有 <strong>正整数</strong> 个带面值的硬币。</p>
<p>每一次操作中，你可以从任意一个栈的 <strong>顶部</strong> 取出 1 个硬币，从栈中移除它，并放入你的钱包里。</p>
<p>给你一个列表 <code>piles</code> ，其中 <code>piles[i]</code> 是一个整数数组，分别表示第 <code>i</code> 个栈里 <strong>从顶到底</strong> 的硬币面值。同时给你一个正整数 <code>k</code> ，请你返回在 <strong>恰好</strong> 进行 <code>k</code> 次操作的前提下，你钱包里硬币面值之和 <strong>最大为多少</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2019/11/09/e1.png" style="width: 600px; height: 243px;"/></p>
<pre><b>输入：</b>piles = [[1,100,3],[7,8,9]], k = 2
<b>输出：</b>101
<strong>解释：</strong>
上图展示了几种选择 k 个硬币的不同方法。
我们可以得到的最大面值为 101 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7
<b>输出：</b>706
<strong>解释：
</strong>如果我们所有硬币都从最后一个栈中取，可以得到最大面值和。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == piles.length</code></li>
<li><code>1 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= piles[i][j] &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= k &lt;= sum(piles[i].length) &lt;= 2000</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************<div id="title">2223. Sum of Scores of Built Strings</div>
************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你需要从空字符串开始 <strong>构造</strong> 一个长度为 <code>n</code> 的字符串 <code>s</code> ，构造的过程为每次给当前字符串 <strong>前面</strong> 添加 <strong>一个</strong> 字符。构造过程中得到的所有字符串编号为 <code>1</code> 到 <code>n</code> ，其中长度为 <code>i</code> 的字符串编号为 <code>s<sub>i</sub></code> 。</p>
<ul>
<li>比方说，<code>s = "abaca"</code> ，<code>s<sub>1</sub> == "a"</code> ，<code>s<sub>2</sub> == "ca"</code> ，<code>s<sub>3</sub> == "aca"</code> 依次类推。</li>
</ul>
<p><code>s<sub>i</sub></code> 的 <strong>得分</strong> 为 <code>s<sub>i</sub></code> 和 <code>s<sub>n</sub></code> 的 <strong>最长公共前缀</strong> 的长度（注意 <code>s == s<sub>n</sub></code> ）。</p>
<p>给你最终的字符串 <code>s</code> ，请你返回每一个<em> </em><code>s<sub>i</sub></code> 的 <strong>得分之和</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>s = "babab"
<b>输出：</b>9
<b>解释：</b>
s<sub>1</sub> == "b" ，最长公共前缀是 "b" ，得分为 1 。
s<sub>2</sub> == "ab" ，没有公共前缀，得分为 0 。
s<sub>3</sub> == "bab" ，最长公共前缀为 "bab" ，得分为 3 。
s<sub>4</sub> == "abab" ，没有公共前缀，得分为 0 。
s<sub>5</sub> == "babab" ，最长公共前缀为 "babab" ，得分为 5 。
得分和为 1 + 0 + 3 + 0 + 5 = 9 ，所以我们返回 9 。</pre>
<p><strong>示例 2 ：</strong></p>
<pre><b>输入：</b>s = "azbazbzaz"
<b>输出：</b>14
<b>解释：</b>
s<sub>2</sub> == "az" ，最长公共前缀为 "az" ，得分为 2 。
s<sub>6</sub> == "azbzaz" ，最长公共前缀为 "azb" ，得分为 3 。
s<sub>9</sub> == "azbazbzaz" ，最长公共前缀为 "azbazbzaz" ，得分为 9 。
其他 s<sub>i</sub> 得分均为 0 。
得分和为 2 + 3 + 9 = 14 ，所以我们返回 14 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
<li><code>s</code> 只包含小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">2227. Encrypt and Decrypt Strings</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符数组 <code>keys</code> ，由若干 <strong>互不相同</strong> 的字符组成。还有一个字符串数组 <code>values</code> ，内含若干长度为 2 的字符串。另给你一个字符串数组 <code>dictionary</code> ，包含解密后所有允许的原字符串。请你设计并实现一个支持加密及解密下标从 <strong>0</strong> 开始字符串的数据结构。</p>
<p>字符串 <strong>加密</strong> 按下述步骤进行：</p>
<ol>
<li>对字符串中的每个字符 <code>c</code> ，先从 <code>keys</code> 中找出满足 <code>keys[i] == c</code> 的下标 <code>i</code> 。</li>
<li>在字符串中，用 <code>values[i]</code> 替换字符 <code>c</code> 。</li>
</ol>
<p>字符串 <strong>解密</strong> 按下述步骤进行：</p>
<ol>
<li>将字符串每相邻 2 个字符划分为一个子字符串，对于每个子字符串 <code>s</code> ，找出满足 <code>values[i] == s</code> 的一个下标 <code>i</code> 。如果存在多个有效的 <code>i</code> ，从中选择 <strong>任意</strong> 一个。这意味着一个字符串解密可能得到多个解密字符串。</li>
<li>在字符串中，用 <code>keys[i]</code> 替换 <code>s</code> 。</li>
</ol>
<p>实现 <code>Encrypter</code> 类：</p>
<ul>
<li><code>Encrypter(char[] keys, String[] values, String[] dictionary)</code> 用 <code>keys</code>、<code>values</code> 和 <code>dictionary</code> 初始化 <code>Encrypter</code> 类。</li>
<li><code>String encrypt(String word1)</code> 按上述加密过程完成对 <code>word1</code> 的加密，并返回加密后的字符串。</li>
<li><code>int decrypt(String word2)</code> 统计并返回可以由 <code>word2</code> 解密得到且出现在 <code>dictionary</code> 中的字符串数目。</li>
</ul>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>
["Encrypter", "encrypt", "decrypt"]
[[['a', 'b', 'c', 'd'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]], ["abcd"], ["eizfeiam"]]
<strong>输出：</strong>
[null, "eizfeiam", 2]

<strong>解释：</strong>
Encrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]);
encrypter.encrypt("abcd"); // 返回 "eizfeiam"。 
                           // 'a' 映射为 "ei"，'b' 映射为 "zf"，'c' 映射为 "ei"，'d' 映射为 "am"。
encrypter.decrypt("eizfeiam"); // return 2. 
                              // "ei" 可以映射为 'a' 或 'c'，"zf" 映射为 'b'，"am" 映射为 'd'。 
                              // 因此，解密后可以得到的字符串是 "abad"，"cbad"，"abcd" 和 "cbcd"。 
                              // 其中 2 个字符串，"abad" 和 "abcd"，在 dictionary 中出现，所以答案是 2 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= keys.length == values.length &lt;= 26</code></li>
<li><code>values[i].length == 2</code></li>
<li><code>1 &lt;= dictionary.length &lt;= 100</code></li>
<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>
<li>所有 <code>keys[i]</code> 和 <code>dictionary[i]</code> <strong>互不相同</strong></li>
<li><code>1 &lt;= word1.length &lt;= 2000</code></li>
<li><code>1 &lt;= word2.length &lt;= 200</code></li>
<li>所有 <code>word1[i]</code> 都出现在 <code>keys</code> 中</li>
<li><code>word2.length</code> 是偶数</li>
<li><code>keys</code>、<code>values[i]</code>、<code>dictionary[i]</code>、<code>word1</code> 和 <code>word2</code> 只含小写英文字母</li>
<li>至多调用 <code>encrypt</code> 和 <code>decrypt</code> <strong>总计</strong> <code>200</code> 次</li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">2234. Maximum Total Beauty of the Gardens</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>Alice 是 <code>n</code> 个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。</p>
<p>给你一个下标从 <strong>0</strong> 开始大小为 <code>n</code> 的整数数组 <code>flowers</code> ，其中 <code>flowers[i]</code> 是第 <code>i</code> 个花园里已经种的花的数目。已经种了的花 <strong>不能</strong> 移走。同时给你 <code>newFlowers</code> ，表示 Alice 额外可以种花的 <strong>最大数目</strong> 。同时给你的还有整数 <code>target</code> ，<code>full</code> 和 <code>partial</code> 。</p>
<p>如果一个花园有 <strong>至少</strong> <code>target</code> 朵花，那么这个花园称为 <strong>完善的</strong> ，花园的 <strong>总美丽值</strong> 为以下分数之 <strong>和</strong> ：</p>
<ul>
<li><b>完善</b> 花园数目乘以 <code>full</code>.</li>
<li>剩余 <strong>不完善</strong> 花园里，花的 <strong>最少数目</strong> 乘以 <code>partial</code> 。如果没有不完善花园，那么这一部分的值为 <code>0</code> 。</li>
</ul>
<p>请你返回 Alice 种最多 <code>newFlowers</code> 朵花以后，能得到的<strong> 最大</strong> 总美丽值。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1
<b>输出：</b>14
<b>解释：</b>Alice 可以按以下方案种花
- 在第 0 个花园种 2 朵花
- 在第 1 个花园种 3 朵花
- 在第 2 个花园种 1 朵花
- 在第 3 个花园种 1 朵花
花园里花的数目为 [3,6,2,2] 。总共种了 2 + 3 + 1 + 1 = 7 朵花。
只有 1 个花园是完善的。
不完善花园里花的最少数目是 2 。
所以总美丽值为 1 * 12 + 2 * 1 = 12 + 2 = 14 。
没有其他方案可以让花园总美丽值超过 14 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6
<b>输出：</b>30
<b>解释：</b>Alice 可以按以下方案种花
- 在第 0 个花园种 3 朵花
- 在第 1 个花园种 0 朵花
- 在第 2 个花园种 0 朵花
- 在第 3 个花园种 2 朵花
花园里花的数目为 [5,4,5,5] 。总共种了 3 + 0 + 0 + 2 = 5 朵花。
有 3 个花园是完善的。
不完善花园里花的最少数目为 4 。
所以总美丽值为 3 * 2 + 4 * 6 = 6 + 24 = 30 。
没有其他方案可以让花园总美丽值超过 30 。
注意，Alice可以让所有花园都变成完善的，但这样她的总美丽值反而更小。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= flowers.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= flowers[i], target &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= newFlowers &lt;= 10<sup>10</sup></code></li>
<li><code>1 &lt;= full, partial &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">2242. Maximum Score of a Node Sequence</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>n</code> 个节点的 <strong>无向图</strong> ，节点编号为 <code>0</code> 到 <code>n - 1</code> 。</p>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>scores</code> ，其中 <code>scores[i]</code> 是第 <code>i</code> 个节点的分数。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> ，表示节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间有一条 <strong>无向</strong> 边。</p>
<p>一个合法的节点序列如果满足以下条件，我们称它是 <strong>合法的</strong> ：</p>
<ul>
<li>序列中每 <b>相邻</b> 节点之间有边相连。</li>
<li>序列中没有节点出现超过一次。</li>
</ul>
<p>节点序列的分数定义为序列中节点分数之 <strong>和</strong> 。</p>
<p>请你返回一个长度为 <code>4</code> 的合法节点序列的最大分数。如果不存在这样的序列，请你返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/04/15/ex1new3.png" style="width: 290px; height: 215px;"/></p>
<pre><b>输入：</b>scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
<b>输出：</b>24
<b>解释：</b>上图为输入的图，节点序列为 [0,1,2,3] 。
节点序列的分数为 5 + 2 + 9 + 8 = 24 。
观察可知，没有其他节点序列得分和超过 24 。
注意节点序列 [3,1,2,0] 和 [1,0,2,3] 也是合法的，且分数为 24 。
序列 [0,3,2,4] 不是合法的，因为没有边连接节点 0 和 3 。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/17/ex2.png" style="width: 333px; height: 151px;"/></p>
<pre><b>输入：</b>scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]
<b>输出：</b>-1
<b>解释：</b>上图为输入的图。
没有长度为 4 的合法序列，所以我们返回 -1 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == scores.length</code></li>
<li><code>4 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= scores[i] &lt;= 10<sup>8</sup></code></li>
<li><code>0 &lt;= edges.length &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
<li>不会有重边。</li>
</ul>
</div></div></div><br><br><hr><br>*****************************************************<div id="title">2246. Longest Path With Different Adjacent Characters</div>
*****************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一棵 <strong>树</strong>（即一个连通、无向、无环图），根节点是节点 <code>0</code> ，这棵树由编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点组成。用下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>parent</code> 来表示这棵树，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点，由于节点 <code>0</code> 是根节点，所以 <code>parent[0] == -1</code> 。</p>
<p>另给你一个字符串 <code>s</code> ，长度也是 <code>n</code> ，其中 <code>s[i]</code> 表示分配给节点 <code>i</code> 的字符。</p>
<p>请你找出路径上任意一对相邻节点都没有分配到相同字符的 <strong>最长路径</strong> ，并返回该路径的长度。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png" style="width: 201px; height: 241px;"/></p>
<pre><strong>输入：</strong>parent = [-1,0,0,1,1,2], s = "abacbe"
<strong>输出：</strong>3
<strong>解释：</strong>任意一对相邻节点字符都不同的最长路径是：0 -&gt; 1 -&gt; 3 。该路径的长度是 3 ，所以返回 3 。
可以证明不存在满足上述条件且比 3 更长的路径。 
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png" style="width: 201px; height: 221px;"/></p>
<pre><strong>输入：</strong>parent = [-1,0,0,0], s = "aabc"
<strong>输出：</strong>3
<strong>解释：</strong>任意一对相邻节点字符都不同的最长路径是：2 -&gt; 0 -&gt; 3 。该路径的长度为 3 ，所以返回 3 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == parent.length == s.length</code></li>
<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li>对所有 <code>i &gt;= 1</code> ，<code>0 &lt;= parent[i] &lt;= n - 1</code> 均成立</li>
<li><code>parent[0] == -1</code></li>
<li><code>parent</code> 表示一棵有效的树</li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>*************************************<div id="title">2251. Number of Flowers in Full Bloom</div>
*************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>flowers</code> ，其中 <code>flowers[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示第 <code>i</code> 朵花的 <strong>花期</strong> 从 <code>start<sub>i</sub></code> 到 <code>end<sub>i</sub></code> （都 <strong>包含</strong>）。同时给你一个下标从 <strong>0</strong> 开始大小为 <code>n</code> 的整数数组 <code>persons</code> ，<code>persons[i]</code> 是第 <code>i</code> 个人来看花的时间。</p>
<p>请你返回一个大小为 <code>n</code> 的整数数组<em> </em><code>answer</code> ，其中 <code>answer[i]</code>是第 <code>i</code> 个人到达时在花期内花的 <strong>数目</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/02/ex1new.jpg" style="width: 550px; height: 216px;"/></p>
<pre><b>输入：</b>flowers = [[1,6],[3,7],[9,12],[4,13]], persons = [2,3,7,11]
<b>输出：</b>[1,2,2,2]
<strong>解释：</strong>上图展示了每朵花的花期时间，和每个人的到达时间。
对每个人，我们返回他们到达时在花期内花的数目。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/02/ex2new.jpg" style="width: 450px; height: 195px;"/></p>
<pre><b>输入：</b>flowers = [[1,10],[3,3]], persons = [3,3,2]
<b>输出：</b>[2,2,1]
<b>解释：</b>上图展示了每朵花的花期时间，和每个人的到达时间。
对每个人，我们返回他们到达时在花期内花的数目。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= flowers.length &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>flowers[i].length == 2</code></li>
<li><code>1 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>
<li><code>1 &lt;= persons.length &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= persons[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">2258. Escape the Spreading Fire</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始大小为 <code>m x n</code> 的二维整数数组 <code>grid</code> ，它表示一个网格图。每个格子为下面 3 个值之一：</p>
<ul>
<li><code>0</code> 表示草地。</li>
<li><code>1</code> 表示着火的格子。</li>
<li><code>2</code> 表示一座墙，你跟火都不能通过这个格子。</li>
</ul>
<p>一开始你在最左上角的格子 <code>(0, 0)</code> ，你想要到达最右下角的安全屋格子 <code>(m - 1, n - 1)</code> 。每一分钟，你可以移动到 <strong>相邻</strong> 的草地格子。每次你移动 <strong>之后</strong> ，着火的格子会扩散到所有不是墙的 <strong>相邻</strong> 格子。</p>
<p>请你返回你在初始位置可以停留的 <strong>最多 </strong>分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 <code>-1</code> 。如果不管你在初始位置停留多久，你 <strong>总是</strong> 能到达安全屋，请你返回 <code>10<sup>9</sup></code> 。</p>
<p>注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。</p>
<p>如果两个格子有共同边，那么它们为 <strong>相邻</strong> 格子。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg" style="width: 650px; height: 404px;"/></p>
<pre><b>输入：</b>grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]
<b>输出：</b>3
<b>解释：</b>上图展示了你在初始位置停留 3 分钟后的情形。
你仍然可以安全到达安全屋。
停留超过 3 分钟会让你无法安全到达安全屋。</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg" style="width: 515px; height: 150px;"/></p>
<pre><b>输入：</b>grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]
<b>输出：</b>-1
<b>解释：</b>上图展示了你马上开始朝安全屋移动的情形。
火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。
所以返回 -1 。
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg" style="width: 174px; height: 150px;"/></p>
<pre><b>输入：</b>grid = [[0,0,0],[2,2,0],[1,2,0]]
<b>输出：</b>1000000000
<b>解释：</b>上图展示了初始网格图。
注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。
所以返回 10<sup>9</sup> 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>2 &lt;= m, n &lt;= 300</code></li>
<li><code>4 &lt;= m * n &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>grid[i][j]</code> 是 <code>0</code> ，<code>1</code> 或者 <code>2</code> 。</li>
<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">2262. Total Appeal of A String</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>字符串的 <strong>引力</strong> 定义为：字符串中 <strong>不同</strong> 字符的数量。</p>
<ul>
<li>例如，<code>"abbca"</code> 的引力为 <code>3</code> ，因为其中有 <code>3</code> 个不同字符 <code>'a'</code>、<code>'b'</code> 和 <code>'c'</code> 。</li>
</ul>
<p>给你一个字符串 <code>s</code> ，返回 <strong>其所有子字符串的总引力</strong> <strong>。</strong></p>
<p><strong>子字符串</strong> 定义为：字符串中的一个连续字符序列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "abbca"
<strong>输出：</strong>28
<strong>解释：</strong>"abbca" 的子字符串有：
- 长度为 1 的子字符串："a"、"b"、"b"、"c"、"a" 的引力分别为 1、1、1、1、1，总和为 5 。
- 长度为 2 的子字符串："ab"、"bb"、"bc"、"ca" 的引力分别为 2、1、2、2 ，总和为 7 。
- 长度为 3 的子字符串："abb"、"bbc"、"bca" 的引力分别为 2、2、3 ，总和为 7 。
- 长度为 4 的子字符串："abbc"、"bbca" 的引力分别为 3、3 ，总和为 6 。
- 长度为 5 的子字符串："abbca" 的引力为 3 ，总和为 3 。
引力总和为 5 + 7 + 7 + 6 + 3 = 28 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "code"
<strong>输出：</strong>20
<strong>解释：</strong>"code" 的子字符串有：
- 长度为 1 的子字符串："c"、"o"、"d"、"e" 的引力分别为 1、1、1、1 ，总和为 4 。
- 长度为 2 的子字符串："co"、"od"、"de" 的引力分别为 2、2、2 ，总和为 6 。
- 长度为 3 的子字符串："cod"、"ode" 的引力分别为 3、3 ，总和为 6 。
- 长度为 4 的子字符串："code" 的引力为 4 ，总和为 4 。
引力总和为 4 + 6 + 6 + 4 = 20 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>********************************************************<div id="title">2267.  Check if There Is a Valid Parentheses String Path</div>
********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个括号字符串是一个 <strong>非空</strong> 且只包含 <code>'('</code> 和 <code>')'</code> 的字符串。如果下面 <strong>任意</strong> 条件为 <strong>真</strong> ，那么这个括号字符串就是 <strong>合法的</strong> 。</p>
<ul>
<li>字符串是 <code>()</code> 。</li>
<li>字符串可以表示为 <code>AB</code>（<code>A</code> 连接 <code>B</code>），<code>A</code> 和 <code>B</code> 都是合法括号序列。</li>
<li>字符串可以表示为 <code>(A)</code> ，其中 <code>A</code> 是合法括号序列。</li>
</ul>
<p>给你一个 <code>m x n</code> 的括号网格图矩阵 <code>grid</code> 。网格图中一个 <strong>合法括号路径</strong> 是满足以下所有条件的一条路径：</p>
<ul>
<li>路径开始于左上角格子 <code>(0, 0)</code> 。</li>
<li>路径结束于右下角格子 <code>(m - 1, n - 1)</code> 。</li>
<li>路径每次只会向 <strong>下</strong> 或者向 <strong>右</strong> 移动。</li>
<li>路径经过的格子组成的括号字符串是<strong> 合法</strong> 的。</li>
</ul>
<p>如果网格图中存在一条 <strong>合法括号路径</strong> ，请返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png" style="width: 521px; height: 300px;"/></p>
<pre><b>输入：</b>grid = [["(","(","("],[")","(",")"],["(","(",")"],["(","(",")"]]
<b>输出：</b>true
<b>解释：</b>上图展示了两条路径，它们都是合法括号字符串路径。
第一条路径得到的合法字符串是 "()(())" 。
第二条路径得到的合法字符串是 "((()))" 。
注意可能有其他的合法括号字符串路径。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png" style="width: 165px; height: 165px;"/></p>
<pre><b>输入：</b>grid = [[")",")"],["(","("]]
<b>输出：</b>false
<b>解释：</b>两条可行路径分别得到 "))(" 和 ")((" 。由于它们都不是合法括号字符串，我们返回 false 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>grid[i][j]</code> 要么是 <code>'('</code> ，要么是 <code>')'</code> 。</li>
</ul>
</div></div></div><br><br><hr><br>*************************************<div id="title">2272. Substring With Largest Variance</div>
*************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>字符串的 <strong>波动</strong> 定义为子字符串中出现次数 <strong>最多</strong> 的字符次数与出现次数 <strong>最少</strong> 的字符次数之差。</p>
<p>给你一个字符串 <code>s</code> ，它只包含小写英文字母。请你返回 <code>s</code> 里所有 <strong>子字符串的</strong> <strong>最大波动</strong> 值。</p>
<p><strong>子字符串</strong> 是一个字符串的一段连续字符序列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>s = "aababbb"
<b>输出：</b>3
<strong>解释：</strong>
所有可能的波动值和它们对应的子字符串如以下所示：
- 波动值为 0 的子字符串："a" ，"aa" ，"ab" ，"abab" ，"aababb" ，"ba" ，"b" ，"bb" 和 "bbb" 。
- 波动值为 1 的子字符串："aab" ，"aba" ，"abb" ，"aabab" ，"ababb" ，"aababbb" 和 "bab" 。
- 波动值为 2 的子字符串："aaba" ，"ababbb" ，"abbb" 和 "babb" 。
- 波动值为 3 的子字符串 "babbb" 。
所以，最大可能波动值为 3 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>s = "abcde"
<b>输出：</b>0
<strong>解释：</strong>
s 中没有字母出现超过 1 次，所以 s 中每个子字符串的波动值都是 0 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
<li><code>s</code>  只包含小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">2276. Count Integers in Intervals</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你区间的 <strong>空</strong> 集，请你设计并实现满足要求的数据结构：</p>
<ul>
<li><strong>新增：</strong>添加一个区间到这个区间集合中。</li>
<li><strong>统计：</strong>计算出现在 <strong>至少一个</strong> 区间中的整数个数。</li>
</ul>
<p>实现 <code>CountIntervals</code> 类：</p>
<ul>
<li><code>CountIntervals()</code> 使用区间的空集初始化对象</li>
<li><code>void add(int left, int right)</code> 添加区间 <code>[left, right]</code> 到区间集合之中。</li>
<li><code>int count()</code> 返回出现在 <strong>至少一个</strong> 区间中的整数个数。</li>
</ul>
<p><strong>注意：</strong>区间 <code>[left, right]</code> 表示满足 <code>left &lt;= x &lt;= right</code> 的所有整数 <code>x</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入</strong>
["CountIntervals", "add", "add", "count", "add", "count"]
[[], [2, 3], [7, 10], [], [5, 8], []]
<strong>输出</strong>
[null, null, null, 6, null, 8]

<strong>解释</strong>
CountIntervals countIntervals = new CountIntervals(); // 用一个区间空集初始化对象
countIntervals.add(2, 3);  // 将 [2, 3] 添加到区间集合中
countIntervals.add(7, 10); // 将 [7, 10] 添加到区间集合中
countIntervals.count();    // 返回 6
                           // 整数 2 和 3 出现在区间 [2, 3] 中
                           // 整数 7、8、9、10 出现在区间 [7, 10] 中
countIntervals.add(5, 8);  // 将 [5, 8] 添加到区间集合中
countIntervals.count();    // 返回 8
                           // 整数 2 和 3 出现在区间 [2, 3] 中
                           // 整数 5 和 6 出现在区间 [5, 8] 中
                           // 整数 7 和 8 出现在区间 [5, 8] 和区间 [7, 10] 中
                           // 整数 9 和 10 出现在区间 [7, 10] 中</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>9</sup></code></li>
<li>最多调用  <code>add</code> 和 <code>count</code> 方法 <strong>总计</strong> <code>10<sup>5</sup></code> 次</li>
<li>调用 <code>count</code> 方法至少一次</li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">2281. Sum of Total Strength of Wizards</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>作为国王的统治者，你有一支巫师军队听你指挥。</p>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>strength</code> ，其中 <code>strength[i]</code> 表示第 <code>i</code> 位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 <code>strength</code> 的 <strong>子数组</strong>），<strong>总力量</strong> 定义为以下两个值的 <strong>乘积</strong> ：</p>
<ul>
<li>巫师中 <strong>最弱</strong> 的能力值。</li>
<li>组中所有巫师的个人力量值 <strong>之和</strong> 。</li>
</ul>
<p>请你返回 <strong>所有</strong> 巫师组的 <strong>总</strong> 力量之和。由于答案可能很大，请将答案对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>
<p><strong>子数组</strong> 是一个数组里 <strong>非空</strong> 连续子序列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>strength = [1,3,1,2]
<b>输出：</b>44
<b>解释：</b>以下是所有连续巫师组：
- [<em><strong>1</strong></em>,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1
- [1,<em><strong>3</strong></em>,1,2] 中 [3] ，总力量值为 min([3]) * sum([3]) = 3 * 3 = 9
- [1,3,<em><strong>1</strong></em>,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1
- [1,3,1,<em><strong>2</strong></em>] 中 [2] ，总力量值为 min([2]) * sum([2]) = 2 * 2 = 4
- [<em><strong>1,3</strong></em>,1,2] 中 [1,3] ，总力量值为 min([1,3]) * sum([1,3]) = 1 * 4 = 4
- [1,<em><strong>3,1</strong></em>,2] 中 [3,1] ，总力量值为 min([3,1]) * sum([3,1]) = 1 * 4 = 4
- [1,3,<em><strong>1,2</strong></em>] 中 [1,2] ，总力量值为 min([1,2]) * sum([1,2]) = 1 * 3 = 3
- [<em><strong>1,3,1</strong></em>,2] 中 [1,3,1] ，总力量值为 min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5
- [1,<em><strong>3,1,2</strong></em>] 中 [3,1,2] ，总力量值为 min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6
- [<em><strong>1,3,1,2</strong></em>] 中 [1,3,1,2] ，总力量值为 min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7
所有力量值之和为 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><b>输入：</b>strength = [5,4,6]
<b>输出：</b>213
<b>解释：</b>以下是所有连续巫师组：
- [<em><strong>5</strong></em>,4,6] 中 [5] ，总力量值为 min([5]) * sum([5]) = 5 * 5 = 25
- [5,<em><strong>4</strong></em>,6] 中 [4] ，总力量值为 min([4]) * sum([4]) = 4 * 4 = 16
- [5,4,<em><strong>6</strong></em>] 中 [6] ，总力量值为 min([6]) * sum([6]) = 6 * 6 = 36
- [<em><strong>5,4</strong></em>,6] 中 [5,4] ，总力量值为 min([5,4]) * sum([5,4]) = 4 * 9 = 36
- [5,<em><strong>4,6</strong></em>] 中 [4,6] ，总力量值为 min([4,6]) * sum([4,6]) = 4 * 10 = 40
- [<em><strong>5,4,6</strong></em>] 中 [5,4,6] ，总力量值为 min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60
所有力量值之和为 25 + 16 + 36 + 36 + 40 + 60 = 213 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strength.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= strength[i] &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***************************************<div id="title">2286. Booking Concert Tickets in Groups</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个音乐会总共有 <code>n</code> 排座位，编号从 <code>0</code> 到 <code>n - 1</code> ，每一排有 <code>m</code> 个座椅，编号为 <code>0</code> 到 <code>m - 1</code> 。你需要设计一个买票系统，针对以下情况进行座位安排：</p>
<ul>
<li>同一组的 <code>k</code> 位观众坐在<strong> 同一排座位，且座位连续 </strong>。</li>
<li><code>k</code> 位观众中 <strong>每一位</strong> 都有座位坐，但他们 <strong>不一定</strong> 坐在一起。</li>
</ul>
<p>由于观众非常挑剔，所以：</p>
<ul>
<li>只有当一个组里所有成员座位的排数都 <strong>小于等于</strong> <code>maxRow</code> ，这个组才能订座位。每一组的 <code>maxRow</code> 可能 <strong>不同</strong> 。</li>
<li>如果有多排座位可以选择，优先选择 <strong>最小</strong> 的排数。如果同一排中有多个座位可以坐，优先选择号码 <strong>最小</strong> 的。</li>
</ul>
<p>请你实现 <code>BookMyShow</code> 类：</p>
<ul>
<li><code>BookMyShow(int n, int m)</code> ，初始化对象，<code>n</code> 是排数，<code>m</code> 是每一排的座位数。</li>
<li><code>int[] gather(int k, int maxRow)</code> 返回长度为 <code>2</code> 的数组，表示 <code>k</code> 个成员中 <strong>第一个座位</strong> 的排数和座位编号，这 <code>k</code> 位成员必须坐在 <strong>同一排座位，且座位连续 </strong>。换言之，返回最小可能的 <code>r</code> 和 <code>c</code> 满足第 <code>r</code> 排中 <code>[c, c + k - 1]</code> 的座位都是空的，且 <code>r &lt;= maxRow</code> 。如果 <strong>无法</strong> 安排座位，返回 <code>[]</code> 。</li>
<li><code>boolean scatter(int k, int maxRow)</code> 如果组里所有 <code>k</code> 个成员 <strong>不一定</strong> 要坐在一起的前提下，都能在第 <code>0</code> 排到第 <code>maxRow</code> 排之间找到座位，那么请返回 <code>true</code> 。这种情况下，每个成员都优先找排数 <strong>最小</strong> ，然后是座位编号最小的座位。如果不能安排所有 <code>k</code> 个成员的座位，请返回 <code>false</code> 。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>
["BookMyShow", "gather", "gather", "scatter", "scatter"]
[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]
<strong>输出：</strong>
[null, [0, 0], [], true, false]

<strong>解释：</strong>
BookMyShow bms = new BookMyShow(2, 5); // 总共有 2 排，每排 5 个座位。
bms.gather(4, 0); // 返回 [0, 0]
                  // 这一组安排第 0 排 [0, 3] 的座位。
bms.gather(2, 0); // 返回 []
                  // 第 0 排只剩下 1 个座位。
                  // 所以无法安排 2 个连续座位。
bms.scatter(5, 1); // 返回 True
                   // 这一组安排第 0 排第 4 个座位和第 1 排 [0, 3] 的座位。
bms.scatter(5, 1); // 返回 False
                   // 总共只剩下 2 个座位。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= m, k &lt;= 10<sup>9</sup></code></li>
<li><code>0 &lt;= maxRow &lt;= n - 1</code></li>
<li><code>gather</code> 和 <code>scatter</code> <strong>总</strong> 调用次数不超过 <code>5 * 10<sup>4</sup></code> 次。</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">2290. Minimum Obstacle Removal to Reach Corner</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>grid</code> ，数组大小为 <code>m x n</code> 。每个单元格都是两个值之一：</p>
<ul>
<li><code>0</code> 表示一个 <strong>空</strong> 单元格，</li>
<li><code>1</code> 表示一个可以移除的 <strong>障碍物</strong> 。</li>
</ul>
<p>你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。</p>
<p>现在你需要从左上角 <code>(0, 0)</code> 移动到右下角 <code>(m - 1, n - 1)</code> ，返回需要移除的障碍物的 <strong>最小</strong> 数目。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png" style="width: 605px; height: 246px;"/></p>
<pre><strong>输入：</strong>grid = [[0,1,1],[1,1,0],[1,1,0]]
<strong>输出：</strong>2
<strong>解释：</strong>可以移除位于 (0, 1) 和 (0, 2) 的障碍物来创建从 (0, 0) 到 (2, 2) 的路径。
可以证明我们至少需要移除两个障碍物，所以返回 2 。
注意，可能存在其他方式来移除 2 个障碍物，创建出可行的路径。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png" style="width: 405px; height: 246px;"/></p>
<pre><strong>输入：</strong>grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
<strong>输出：</strong>0
<strong>解释：</strong>不移除任何障碍物就能从 (0, 0) 到 (2, 4) ，所以返回 0 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>
<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> <strong>或</strong> <code>1</code></li>
<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
</div></div></div><br><br><hr><br>