 <style>pre{white-space:pre-wrap;background:#f7f9fa;padding:10px 15px;color:#263238;line-height:1.6;font-size:13px;border-radius:3px margin-top: 0;margin-bottom:1em;overflow:auto}b,strong{font-weight:bolder}#title{font-size:16px;color:#212121;font-weight:600;margin-bottom:10px}hr{height:10px;border:0;box-shadow:0 10px 10px -10px #8c8b8b inset}</style>***********************<div id="title">1001. Grid Illumination</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在大小为 <code>n x n</code> 的网格 <code>grid</code> 上，每个单元格都有一盏灯，最初灯都处于 <strong>关闭</strong> 状态。</p>
<p>给你一个由灯的位置组成的二维数组 <code>lamps</code> ，其中 <code>lamps[i] = [row<sub>i</sub>, col<sub>i</sub>]</code> 表示 <strong>打开</strong> 位于 <code>grid[row<sub>i</sub>][col<sub>i</sub>]</code> 的灯。即便同一盏灯可能在 <code>lamps</code> 中多次列出，不会影响这盏灯处于 <strong>打开</strong> 状态。</p>
<p>当一盏灯处于打开状态，它将会照亮 <strong>自身所在单元格</strong> 以及同一 <strong>行</strong> 、同一 <strong>列</strong> 和两条 <strong>对角线</strong> 上的 <strong>所有其他单元格</strong> 。</p>
<p>另给你一个二维数组 <code>queries</code> ，其中 <code>queries[j] = [row<sub>j</sub>, col<sub>j</sub>]</code> 。对于第 <code>j</code> 个查询，如果单元格 <code>[row<sub>j</sub>, col<sub>j</sub>]</code> 是被照亮的，则查询结果为 <code>1</code> ，否则为 <code>0</code> 。在第 <code>j</code> 次查询之后 [按照查询的顺序] ，<strong>关闭</strong> 位于单元格 <code>grid[row<sub>j</sub>][col<sub>j</sub>]</code> 上及相邻 8 个方向上（与单元格 <code>grid[row<sub>i</sub>][col<sub>i</sub>]</code> 共享角或边）的任何灯。</p>
<p>返回一个整数数组 <code>ans</code> 作为答案， <code>ans[j]</code> 应等于第 <code>j</code> 次查询 <code>queries[j]</code> 的结果，<code>1</code> 表示照亮，<code>0</code> 表示未照亮。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/illu_1.jpg" style="height: 209px; width: 750px;"/>
<pre><strong>输入：</strong>n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
<strong>输出：</strong>[1,0]
<strong>解释：</strong>最初所有灯都是关闭的。在执行查询之前，打开位于 [0, 0] 和 [4, 4] 的灯。第 0 次查询检查 grid[1][1] 是否被照亮（蓝色方框）。该单元格被照亮，所以 ans[0] = 1 。然后，关闭红色方框中的所有灯。
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/illu_step1.jpg" style="height: 218px; width: 500px;"/>
第 1 次查询检查 grid[1][0] 是否被照亮（蓝色方框）。该单元格没有被照亮，所以 ans[1] = 0 。然后，关闭红色矩形中的所有灯。
<img alt="" src="https://assets.leetcode.com/uploads/2020/08/19/illu_step2.jpg" style="height: 219px; width: 500px;"/>
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]
<strong>输出：</strong>[1,1]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]
<strong>输出：</strong>[1,1,0]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
<li><code>0 &lt;= lamps.length &lt;= 20000</code></li>
<li><code>0 &lt;= queries.length &lt;= 20000</code></li>
<li><code>lamps[i].length == 2</code></li>
<li><code>0 &lt;= row<sub>i</sub>, col<sub>i</sub> &lt; n</code></li>
<li><code>queries[j].length == 2</code></li>
<li><code>0 &lt;= row<sub>j</sub>, col<sub>j</sub> &lt; n</code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************<div id="title">1012. Numbers With Repeated Digits</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定正整数 <code>n</code>，返回在<em> </em><code>[1, n]</code><em> </em>范围内具有 <strong>至少 1 位</strong> 重复数字的正整数的个数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 20
<strong>输出：</strong>1
<strong>解释：</strong>具有至少 1 位重复数字的正数（&lt;= 20）只有 11 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 100
<strong>输出：</strong>10
<strong>解释：</strong>具有至少 1 位重复数字的正数（&lt;= 100）有 11，22，33，44，55，66，77，88，99 和 100 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 1000
<strong>输出：</strong>262
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>********************************************<div id="title">1028. Recover a Tree From Preorder Traversal</div>
********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>我们从二叉树的根节点 <code>root</code> 开始进行深度优先搜索。</p>
<p>在遍历中的每个节点处，我们输出 <code>D</code> 条短划线（其中 <code>D</code> 是该节点的深度），然后输出该节点的值。（<em>如果节点的深度为 <code>D</code>，则其直接子节点的深度为 <code>D + 1</code>。根节点的深度为 <code>0</code>）。</em></p>
<p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p>
<p>给出遍历输出 <code>S</code>，还原树并返回其根节点 <code>root</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/recover-a-tree-from-preorder-traversal.png" style="height: 200px; width: 320px;"/></strong></p>
<pre><strong>输入：</strong>"1-2--3--4-5--6--7"
<strong>输出：</strong>[1,2,5,3,4,6,7]
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/screen-shot-2019-04-10-at-114101-pm.png" style="height: 250px; width: 256px;"/></strong></p>
<pre><strong>输入：</strong>"1-2--3---4-5--6---7"
<strong>输出：</strong>[1,2,5,3,null,6,null,4,null,7]
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/screen-shot-2019-04-10-at-114955-pm.png" style="height: 250px; width: 276px;"/></p>
<pre><strong>输入：</strong>"1-401--349---90--88"
<strong>输出：</strong>[1,401,null,349,88,90]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li>原始树中的节点数介于 <code>1</code> 和 <code>1000</code> 之间。</li>
<li>每个节点的值介于 <code>1</code> 和 <code>10 ^ 9</code> 之间。</li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">1032. Stream of Characters</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>设计一个算法：接收一个字符流，并检查这些字符的后缀是否是字符串数组 <code>words</code> 中的一个字符串。</p>
<p>例如，<code>words = ["abc", "xyz"]</code> 且字符流中逐个依次加入 4 个字符 <code>'a'</code>、<code>'x'</code>、<code>'y'</code> 和 <code>'z'</code> ，你所设计的算法应当可以检测到 <code>"axyz"</code> 的后缀 <code>"xyz"</code> 与 <code>words</code> 中的字符串 <code>"xyz"</code> 匹配。</p>
<p>按下述要求实现 <code>StreamChecker</code> 类：</p>
<ul>
<li><code>StreamChecker(String[] words)</code> ：构造函数，用字符串数组 <code>words</code> 初始化数据结构。</li>
<li><code>boolean query(char letter)</code>：从字符流中接收一个新字符，如果字符流中的任一非空后缀能匹配 <code>words</code> 中的某一字符串，返回 <code>true</code> ；否则，返回 <code>false</code>。</li>
</ul>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>
["StreamChecker", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query"]
[[["cd", "f", "kl"]], ["a"], ["b"], ["c"], ["d"], ["e"], ["f"], ["g"], ["h"], ["i"], ["j"], ["k"], ["l"]]
<strong>输出：</strong>
[null, false, false, false, true, false, true, false, false, false, false, false, true]

<strong>解释：</strong>
StreamChecker streamChecker = new StreamChecker(["cd", "f", "kl"]);
streamChecker.query("a"); // 返回 False
streamChecker.query("b"); // 返回 False
streamChecker.query("c"); // 返回n False
streamChecker.query("d"); // 返回 True ，因为 'cd' 在 words 中
streamChecker.query("e"); // 返回 False
streamChecker.query("f"); // 返回 True ，因为 'f' 在 words 中
streamChecker.query("g"); // 返回 False
streamChecker.query("h"); // 返回 False
streamChecker.query("i"); // 返回 False
streamChecker.query("j"); // 返回 False
streamChecker.query("k"); // 返回 False
streamChecker.query("l"); // 返回 True ，因为 'kl' 在 words 中
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 2000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 200</code></li>
<li><code>words[i]</code> 由小写英文字母组成</li>
<li><code>letter</code> 是一个小写英文字母</li>
<li>最多调用查询 <code>4 * 10<sup>4</sup></code> 次</li>
</ul>
</div></div></div><br><br><hr><br>*************************<div id="title">1036. Escape a Large Maze</div>
*************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在一个 10<sup>6</sup> x 10<sup>6</sup> 的网格中，每个网格上方格的坐标为 <code>(x, y)</code> 。</p>
<p>现在从源方格 <code>source = [s<sub>x</sub>, s<sub>y</sub>]</code> 开始出发，意图赶往目标方格 <code>target = [t<sub>x</sub>, t<sub>y</sub>]</code> 。数组 <code>blocked</code> 是封锁的方格列表，其中每个 <code>blocked[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示坐标为 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 的方格是禁止通行的。</p>
<p>每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 <strong>不</strong> 在给出的封锁列表 <code>blocked</code> 上。同时，不允许走出网格。</p>
<p>只有在可以通过一系列的移动从源方格 <code>source</code> 到达目标方格 <code>target</code> 时才返回 <code>true</code>。否则，返回 <code>false</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
<strong>输出：</strong>false
<strong>解释：</strong>
从源方格无法到达目标方格，因为我们无法在网格中移动。
无法向北或者向东移动是因为方格禁止通行。
无法向南或者向西移动是因为不能走出网格。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>blocked = [], source = [0,0], target = [999999,999999]
<strong>输出：</strong>true
<strong>解释：</strong>
因为没有方格被封锁，所以一定可以到达目标方格。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= blocked.length &lt;= 200</code></li>
<li><code>blocked[i].length == 2</code></li>
<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt; 10<sup>6</sup></code></li>
<li><code>source.length == target.length == 2</code></li>
<li><code>0 &lt;= s<sub>x</sub>, s<sub>y</sub>, t<sub>x</sub>, t<sub>y</sub> &lt; 10<sup>6</sup></code></li>
<li><code>source != target</code></li>
<li>题目数据保证 <code>source</code> 和 <code>target</code> 不在封锁列表内</li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1044. Longest Duplicate Substring</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> ，考虑其所有 <em>重复子串</em> ：即 <code>s</code> 的（连续）子串，在 <code>s</code> 中出现 2 次或更多次。这些出现之间可能存在重叠。</p>
<p>返回 <strong>任意一个</strong> 可能具有最长长度的重复子串。如果 <code>s</code> 不含重复子串，那么答案为 <code>""</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "banana"
<strong>输出：</strong>"ana"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "abcd"
<strong>输出：</strong>""
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">1074. Number of Submatrices That Sum to Target</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>子矩阵 <code>x1, y1, x2, y2</code> 是满足 <code>x1 &lt;= x &lt;= x2</code> 且 <code>y1 &lt;= y &lt;= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>
<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1', y1', x2', y2')</code> 两个子矩阵中部分坐标不同（如：<code>x1 != x1'</code>），那么这两个子矩阵也不同。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg" style="width: 242px; height: 242px;"/></p>
<pre><strong>输入：</strong>matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
<strong>输出：</strong>4
<strong>解释：</strong>四个只含 0 的 1x1 子矩阵。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>matrix = [[1,-1],[-1,1]], target = 0
<strong>输出：</strong>5
<strong>解释：</strong>两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>matrix = [[904]], target = 0
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong><strong>提示：</strong></strong></p>
<ul>
<li><code>1 &lt;= matrix.length &lt;= 100</code></li>
<li><code>1 &lt;= matrix[0].length &lt;= 100</code></li>
<li><code>-1000 &lt;= matrix[i] &lt;= 1000</code></li>
<li><code>-10^8 &lt;= target &lt;= 10^8</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************<div id="title">1092. Shortest Common Supersequence </div>
************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给出两个字符串 <code>str1</code> 和 <code>str2</code>，返回同时以 <code>str1</code> 和 <code>str2</code> 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。</p>
<p>（如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 <strong>任意位置</strong>），可以得到字符串 S，那么 S 就是 T 的子序列）</p>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>str1 = "abac", str2 = "cab"
<strong>输出：</strong>"cabac"
<strong>解释：</strong>
str1 = "abac" 是 "cabac" 的一个子串，因为我们可以删去 "cabac" 的第一个 "c"得到 "abac"。 
str2 = "cab" 是 "cabac" 的一个子串，因为我们可以删去 "cabac" 末尾的 "ac" 得到 "cab"。
最终我们给出的答案是满足上述属性的最短字符串。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li>
<li><code>str1</code> 和 <code>str2</code> 都由小写英文字母组成。</li>
</ol>
</div></div></div><br><br><hr><br>****************************<div id="title">1095. Find in Mountain Array</div>
****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>（这是一个 <strong>交互式问题 </strong>）</p>
<p>给你一个 <strong>山脉数组</strong> <code>mountainArr</code>，请你返回能够使得 <code>mountainArr.get(index)</code> <strong>等于</strong> <code>target</code> <strong>最小</strong> 的下标 <code>index</code> 值。</p>
<p>如果不存在这样的下标 <code>index</code>，就请返回 <code>-1</code>。</p>
<p> </p>
<p>何为山脉数组？如果数组 <code>A</code> 是一个山脉数组的话，那它满足如下条件：</p>
<p><strong>首先</strong>，<code>A.length &gt;= 3</code></p>
<p><strong>其次</strong>，在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 <code>i</code> 使得：</p>
<ul>
<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>
<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
<p> </p>
<p>你将 <strong>不能直接访问该山脉数组</strong>，必须通过 <code>MountainArray</code> 接口来获取数据：</p>
<ul>
<li><code>MountainArray.get(k)</code> - 会返回数组中索引为<code>k</code> 的元素（下标从 0 开始）</li>
<li><code>MountainArray.length()</code> - 会返回该数组的长度</li>
</ul>
<p> </p>
<p><strong>注意：</strong></p>
<p>对 <code>MountainArray.get</code> 发起超过 <code>100</code> 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p>
<p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “<strong>答案</strong>”：<a href="https://leetcode-cn.com/playground/RKhe3ave">https://leetcode-cn.com/playground/RKhe3ave</a>，请注意这 <strong>不是一个正确答案</strong>。</p>
<ol>
</ol>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>array = [1,2,3,4,5,3,1], target = 3
<strong>输出：</strong>2
<strong>解释：</strong>3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>array = [0,1,2,4,2,1], target = 3
<strong>输出：</strong>-1
<strong>解释：</strong>3 在数组中没有出现，返回 -1。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li>
<li><code>0 &lt;= target &lt;= 10^9</code></li>
<li><code>0 &lt;= mountain_arr.get(index) &lt;= 10^9</code></li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">1096. Brace Expansion II</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。</p>
<p>花括号展开的表达式可以看作一个由 <strong>花括号</strong>、<strong>逗号</strong> 和 <strong>小写英文字母</strong> 组成的字符串，定义下面几条语法规则：</p>
<ul>
<li>如果只给出单一的元素 <code>x</code>，那么表达式表示的字符串就只有 <code>"x"</code>。<code>R(x) = {x}</code>
<ul>
<li>例如，表达式 <code>"a"</code> 表示字符串 <code>"a"</code>。</li>
<li>而表达式 <code>"w"</code> 就表示字符串 <code>"w"</code>。</li>
</ul>
</li>
<li>当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。<code>R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ...</code>
<ul>
<li>例如，表达式 <code>"{a,b,c}"</code> 表示字符串 <code>"a","b","c"</code>。</li>
<li>而表达式 <code>"{{a,b},{b,c}}"</code> 也可以表示字符串 <code>"a","b","c"</code>。</li>
</ul>
</li>
<li>要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。<code>R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)}</code>
<ul>
<li>例如，表达式 <code>"{a,b}{c,d}"</code> 表示字符串 <code>"ac","ad","bc","bd"</code>。</li>
</ul>
</li>
<li>表达式之间允许嵌套，单一元素与表达式的连接也是允许的。
	<ul>
<li>例如，表达式 <code>"a{b,c,d}"</code> 表示字符串 <code>"ab","ac","ad"​​​​​​</code>。</li>
<li>例如，表达式 <code>"a{b,c}{d,e}f{g,h}"</code> 可以表示字符串 <code>"abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"</code>。</li>
</ul>
</li>
</ul>
<p>给出表示基于给定语法规则的表达式 <code>expression</code>，返回它所表示的所有字符串组成的有序列表。</p>
<p>假如你希望以「集合」的概念了解此题，也可以通过点击 “<strong>显示英文描述</strong>” 获取详情。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>expression = "{a,b}{c,{d,e}}"
<strong>输出：</strong>["ac","ad","ae","bc","bd","be"]</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>expression = "{{a,z},a{b,c},{ab,z}}"
<strong>输出：</strong>["a","ab","ac","z"]
<strong>解释：</strong>输出中 <strong>不应 </strong>出现重复的组合结果。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= expression.length &lt;= 60</code></li>
<li><code>expression[i]</code> 由 <code>'{'</code>，<code>'}'</code>，<code>','</code> 或小写英文字母组成</li>
<li>给出的表达式 <code>expression</code> 用以表示一组基于题目描述中语法构造的字符串</li>
</ul>
</div></div></div><br><br><hr><br>**********************************<div id="title">1106. Parsing A Boolean Expression</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个以字符串形式表述的 <a href="https://baike.baidu.com/item/%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/1574380?fr=aladdin">布尔表达式</a>（boolean） <code>expression</code>，返回该式的运算结果。</p>
<p>有效的表达式需遵循以下约定：</p>
<ul>
<li><code>"t"</code>，运算结果为 <code>True</code></li>
<li><code>"f"</code>，运算结果为 <code>False</code></li>
<li><code>"!(expr)"</code>，运算过程为对内部表达式 <code>expr</code> 进行逻辑 <strong>非的运算</strong>（NOT）</li>
<li><code>"&amp;(expr1,expr2,...)"</code>，运算过程为对 2 个或以上内部表达式 <code>expr1, expr2, ...</code> 进行逻辑 <strong>与的运算</strong>（AND）</li>
<li><code>"|(expr1,expr2,...)"</code>，运算过程为对 2 个或以上内部表达式 <code>expr1, expr2, ...</code> 进行逻辑 <strong>或的运算</strong>（OR）</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>expression = "!(f)"
<strong>输出：</strong>true
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>expression = "|(f,t)"
<strong>输出：</strong>true
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>expression = "&amp;(t,f)"
<strong>输出：</strong>false
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>expression = "|(&amp;(t,f,t),!(t))"
<strong>输出：</strong>false
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= expression.length &lt;= 20000</code></li>
<li><code>expression[i]</code> 由 <code>{'(', ')', '&amp;', '|', '!', 't', 'f', ','}</code> 中的字符组成。</li>
<li><code>expression</code> 是以上述形式给出的有效表达式，表示一个布尔值。</li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">1125. Smallest Sufficient Team</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>作为项目经理，你规划了一份需求的技能清单 <code>req_skills</code>，并打算从备选人员名单 <code>people</code> 中选出些人组成一个「必要团队」（ 编号为 <code>i</code> 的备选人员 <code>people[i]</code> 含有一份该备选人员掌握的技能列表）。</p>
<p>所谓「必要团队」，就是在这个团队中，对于所需求的技能列表 <code>req_skills</code> 中列出的每项技能，团队中至少有一名成员已经掌握。可以用每个人的编号来表示团队中的成员：</p>
<ul>
<li>例如，团队 <code>team = [0, 1, 3]</code> 表示掌握技能分别为 <code>people[0]</code>，<code>people[1]</code>，和 <code>people[3]</code> 的备选人员。</li>
</ul>
<p>请你返回 <strong>任一</strong> 规模最小的必要团队，团队成员用人员编号表示。你可以按 <strong>任意顺序</strong> 返回答案，题目数据保证答案存在。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]
<strong>输出：</strong>[0,2]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]
<strong>输出：</strong>[1,2]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= req_skills.length &lt;= 16</code></li>
<li><code>1 &lt;= req_skills[i].length &lt;= 16</code></li>
<li><code>req_skills[i]</code> 由小写英文字母组成</li>
<li><code>req_skills</code> 中的所有字符串 <strong>互不相同</strong></li>
<li><code>1 &lt;= people.length &lt;= 60</code></li>
<li><code>0 &lt;= people[i].length &lt;= 16</code></li>
<li><code>1 &lt;= people[i][j].length &lt;= 16</code></li>
<li><code>people[i][j]</code> 由小写英文字母组成</li>
<li><code>people[i]</code> 中的所有字符串 <strong>互不相同</strong></li>
<li><code>people[i]</code> 中的每个技能是 <code>req_skills</code> 中的技能</li>
<li>题目数据保证「必要团队」一定存在</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">1147. Longest Chunked Palindrome Decomposition</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你会得到一个字符串 <code>text</code> 。你应该把它分成 <code>k</code> 个子字符串 <code>(subtext1, subtext2，…， subtextk)</code> ，要求满足:</p>
<ul>
<li><code>subtext<sub>i</sub></code><sub> </sub>是 <strong>非空 </strong>字符串</li>
<li>所有子字符串的连接等于 <code>text</code> ( 即<code>subtext<sub>1</sub> + subtext<sub>2</sub> + ... + subtext<sub>k</sub> == text</code> )</li>
<li><code>subtext<sub>i</sub> == subtext<sub>k - i + 1</sub></code><sub> </sub>表示所有 <font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">i</span></span></font></font> 的有效值( 即 <code>1 &lt;= i &lt;= k</code> )</li>
</ul>
<p>返回<code>k</code>可能最大值。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>text = "ghiabcdefhelloadamhelloabcdefghi"
<strong>输出：</strong>7
<strong>解释：</strong>我们可以把字符串拆分成 "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>text = "merchant"
<strong>输出：</strong>1
<strong>解释：</strong>我们可以把字符串拆分成 "(merchant)"。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>text = "antaprezatepzapreanta"
<strong>输出：</strong>11
<strong>解释：</strong>我们可以把字符串拆分成 "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)"。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text.length &lt;= 1000</code></li>
<li><code>text</code> 仅由小写英文字符组成</li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">115. Distinct Subsequences</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串 <code>s</code><strong> </strong>和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p>
<p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>"ACE"</code> 是 <code>"ABCDE"</code> 的一个子序列，而 <code>"AEC"</code> 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "rabbbit", t = "rabbit"<code>
<strong>输出</strong></code><strong>：</strong><code>3
</code><strong>解释：</strong>
如下图所示, 有 3 种可以从 s 中得到 <code>"rabbit" 的方案</code>。
<code><strong><u>rabb</u></strong>b<strong><u>it</u></strong></code>
<code><strong><u>ra</u></strong>b<strong><u>bbit</u></strong></code>
<code><strong><u>rab</u></strong>b<strong><u>bit</u></strong></code></pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "babgbag", t = "bag"
<code><strong>输出</strong></code><strong>：</strong><code>5
</code><strong>解释：</strong>
如下图所示, 有 5 种可以从 s 中得到 <code>"bag" 的方案</code>。 
<code><strong><u>ba</u></strong>b<u><strong>g</strong></u>bag</code>
<code><strong><u>ba</u></strong>bgba<strong><u>g</u></strong></code>
<code><u><strong>b</strong></u>abgb<strong><u>ag</u></strong></code>
<code>ba<u><strong>b</strong></u>gb<u><strong>ag</strong></u></code>
<code>babg<strong><u>bag</u></strong></code>
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">1157. Online Majority Element In Subarray</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>设计一个数据结构，有效地找到给定子数组的 <strong>多数元素</strong> 。</p>
<p>子数组的 <strong>多数元素</strong> 是在子数组中出现 <code>threshold</code> 次数或次数以上的元素。</p>
<p>实现 <code>MajorityChecker</code> 类:</p>
<ul>
<li><code>MajorityChecker(int[] arr)</code> 会用给定的数组 <code>arr</code> 对 <code>MajorityChecker</code> 初始化。</li>
<li><code>int query(int left, int right, int threshold)</code> 返回子数组中的元素  <code>arr[left...right]</code> 至少出现 <code>threshold</code> 次数，如果不存在这样的元素则返回 <code>-1</code>。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入:</strong>
["MajorityChecker", "query", "query", "query"]
[[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]
<strong>输出：</strong>
[null, 1, -1, 2]

<b>解释：</b>
MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);
majorityChecker.query(0,5,4); // 返回 1
majorityChecker.query(0,3,3); // 返回 -1
majorityChecker.query(2,3,2); // 返回 2
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>1 &lt;= arr[i] &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>
<li><code>threshold &lt;= right - left + 1</code></li>
<li><code>2 * threshold &gt; right - left + 1</code></li>
<li>调用 <code>query</code> 的次数最多为 <code>10<sup>4</sup></code> </li>
</ul>
</div></div></div><br><br><hr><br>*********************************************<div id="title">1163. Last Substring in Lexicographical Order</div>
*********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> ，找出它的所有子串并按字典序排列，返回排在最后的那个子串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "abab"
<strong>输出：</strong>"bab"
<strong>解释：</strong>我们可以找出 7 个子串 ["a", "ab", "aba", "abab", "b", "ba", "bab"]。按字典序排在最后的子串是 "bab"。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "leetcode"
<strong>输出：</strong>"tcode"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 4 * 10<sup>5</sup></code></li>
<li><code>s</code> 仅含有小写英文字符。</li>
</ul>
</div></div></div><br><br><hr><br>*************************<div id="title">1172. Dinner Plate Stacks</div>
*************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>我们把无限数量 ∞ 的栈排成一行，按从左到右的次序从 0 开始编号。每个栈的的最大容量 <code>capacity</code> 都相同。</p>
<p>实现一个叫「餐盘」的类 <code>DinnerPlates</code>：</p>
<ul>
<li><code>DinnerPlates(int capacity)</code> - 给出栈的最大容量 <code>capacity</code>。</li>
<li><code>void push(int val)</code> - 将给出的正整数 <code>val</code> 推入 <strong>从左往右第一个 </strong>没有满的栈。</li>
<li><code>int pop()</code> - 返回 <strong>从右往左第一个 </strong>非空栈顶部的值，并将其从栈中删除；如果所有的栈都是空的，请返回 <code>-1</code>。</li>
<li><code>int popAtStack(int index)</code> - 返回编号 <code>index</code> 的栈顶部的值，并将其从栈中删除；如果编号 <code>index</code> 的栈是空的，请返回 <code>-1</code>。</li>
</ul>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入： </strong>
["DinnerPlates","push","push","push","push","push","popAtStack","push","push","popAtStack","popAtStack","pop","pop","pop","pop","pop"]
[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]
<strong>输出：</strong>
[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]

<strong>解释：</strong>
DinnerPlates D = DinnerPlates(2);  // 初始化，栈最大容量 capacity = 2
D.push(1);
D.push(2);
D.push(3);
D.push(4);
D.push(5);         // 栈的现状为：    2  4
                                    1  3  5
                                    ﹈ ﹈ ﹈
D.popAtStack(0);   // 返回 2。栈的现状为：      4
                                          1  3  5
                                          ﹈ ﹈ ﹈
D.push(20);        // 栈的现状为：  20  4
                                   1  3  5
                                   ﹈ ﹈ ﹈
D.push(21);        // 栈的现状为：  20  4 21
                                   1  3  5
                                   ﹈ ﹈ ﹈
D.popAtStack(0);   // 返回 20。栈的现状为：       4 21
                                            1  3  5
                                            ﹈ ﹈ ﹈
D.popAtStack(2);   // 返回 21。栈的现状为：       4
                                            1  3  5
                                            ﹈ ﹈ ﹈ 
D.pop()            // 返回 5。栈的现状为：        4
                                            1  3 
                                            ﹈ ﹈  
D.pop()            // 返回 4。栈的现状为：    1  3 
                                           ﹈ ﹈   
D.pop()            // 返回 3。栈的现状为：    1 
                                           ﹈   
D.pop()            // 返回 1。现在没有栈。
D.pop()            // 返回 -1。仍然没有栈。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 20000</code></li>
<li><code>1 &lt;= val &lt;= 20000</code></li>
<li><code>0 &lt;= index &lt;= 100000</code></li>
<li>最多会对 <code>push</code>，<code>pop</code>，和 <code>popAtStack</code> 进行 <code>200000</code> 次调用。</li>
</ul>
</div></div></div><br><br><hr><br>*******************************************<div id="title">1178. Number of Valid Words for Each Puzzle</div>
*******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p>
<p>字谜的迷面 <code>puzzle</code> 按字符串形式给出，如果一个单词 <code>word</code> 符合下面两个条件，那么它就可以算作谜底：</p>
<ul>
<li>单词 <code>word</code> 中包含谜面 <code>puzzle</code> 的第一个字母。</li>
<li>单词 <code>word</code> 中的每一个字母都可以在谜面 <code>puzzle</code> 中找到。<br/>
	例如，如果字谜的谜面是 "abcdefg"，那么可以作为谜底的单词有 "faced", "cabbage", 和 "baggage"；而 "beefed"（不含字母 "a"）以及 "based"（其中的 "s" 没有出现在谜面中）都不能作为谜底。</li>
</ul>
<p>返回一个答案数组 <code>answer</code>，数组中的每个元素 <code>answer[i]</code> 是在给出的单词列表 <code>words</code> 中可以作为字谜迷面 <code>puzzles[i]</code> 所对应的谜底的单词数目。</p>
<p> </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>
words = ["aaaa","asas","able","ability","actt","actor","access"], 
puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]
<strong>输出：</strong>[1,1,3,2,4,0]
<strong>解释：</strong>
1 个单词可以作为 "aboveyz" 的谜底 : "aaaa" 
1 个单词可以作为 "abrodyz" 的谜底 : "aaaa"
3 个单词可以作为 "abslute" 的谜底 : "aaaa", "asas", "able"
2 个单词可以作为 "absoryz" 的谜底 : "aaaa", "asas"
4 个单词可以作为 "actresz" 的谜底 : "aaaa", "asas", "actt", "access"
没有单词可以作为 "gaswxyz" 的谜底，因为列表中的单词都不含字母 'g'。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 10^5</code></li>
<li><code>4 &lt;= words[i].length &lt;= 50</code></li>
<li><code>1 &lt;= puzzles.length &lt;= 10^4</code></li>
<li><code>puzzles[i].length == 7</code></li>
<li><code>words[i][j]</code>, <code>puzzles[i][j]</code> 都是小写英文字母。</li>
<li>每个 <code>puzzles[i]</code> 所包含的字符都不重复。</li>
</ul>
</div></div></div><br><br><hr><br>************************************<div id="title">1187. Make Array Strictly Increasing</div>
************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个整数数组 <code>arr1</code> 和 <code>arr2</code>，返回使 <code>arr1</code> 严格递增所需要的最小「操作」数（可能为 0）。</p>
<p>每一步「操作」中，你可以分别从 <code>arr1</code> 和 <code>arr2</code> 中各选出一个索引，分别为 <code>i</code> 和 <code>j</code>，<code>0 &lt;= i &lt; arr1.length</code> 和 <code>0 &lt;= j &lt; arr2.length</code>，然后进行赋值运算 <code>arr1[i] = arr2[j]</code>。</p>
<p>如果无法让 <code>arr1</code> 严格递增，请返回 <code>-1</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
<strong>输出：</strong>1
<strong>解释：</strong>用 2 来替换 <code>5，之后</code> <code>arr1 = [1, 2, 3, 6, 7]</code>。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [4,3,1]
<strong>输出：</strong>2
<strong>解释：</strong>用 3 来替换 <code>5，然后</code>用 4 来替换 3<code>，得到</code> <code>arr1 = [1, 3, 4, 6, 7]</code>。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
<strong>输出：</strong>-1
<strong>解释：</strong>无法使 <code>arr1 严格递增</code>。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr1.length, arr2.length &lt;= 2000</code></li>
<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 10^9</code></li>
</ul>
<p> </p>
</div></div></div><br><br><hr><br>***************************************<div id="title">1192. Critical Connections in a Network</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>力扣数据中心有 <code>n</code> 台服务器，分别按从 <code>0</code> 到 <code>n-1</code> 的方式进行了编号。它们之间以 <strong>服务器到服务器</strong> 的形式相互连接组成了一个内部集群，连接是无向的。用  <code>connections</code> 表示集群网络，<code>connections[i] = [a, b]</code> 表示服务器 <code>a</code> 和 <code>b</code> 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。</p>
<p><strong>关键连接</strong><em> </em>是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。</p>
<p>请你以任意顺序返回该集群内的所有 <strong>关键连接</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png" style="height: 205px; width: 200px;"/></strong></p>
<pre><strong>输入：</strong>n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
<strong>输出：</strong>[[1,3]]
<strong>解释：</strong>[[3,1]] 也是正确的。</pre>
<p><strong>示例 2:</strong></p>
<pre><b>输入：</b>n = 2, connections = [[0,1]]
<b>输出：</b>[[0,1]]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
<li><code>n - 1 &lt;= connections.length &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>
<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
<li>不存在重复的连接</li>
</ul>
</div></div></div><br><br><hr><br>**************************************************<div id="title">1203. Sort Items by Groups Respecting Dependencies</div>
**************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有 <code>n</code> 个项目，每个项目或者不属于任何小组，或者属于 <code>m</code> 个小组之一。<code>group[i]</code> 表示第 <code>i</code> 个项目所属的小组，如果第 <code>i</code> 个项目不属于任何小组，则 <code>group[i]</code> 等于 <code>-1</code>。项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。</p>
<p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p>
<ul>
<li>同一小组的项目，排序后在列表中彼此相邻。</li>
<li>项目之间存在一定的依赖关系，我们用一个列表 <code>beforeItems</code> 来表示，其中 <code>beforeItems[i]</code> 表示在进行第 <code>i</code> 个项目前（位于第 <code>i</code> 个项目左侧）应该完成的所有项目。</li>
</ul>
<p>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 <strong>空列表 </strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/22/1359_ex1.png" style="height: 181px; width: 191px;"/></strong></p>
<pre><strong>输入：</strong>n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
<strong>输出：</strong>[6,3,4,1,5,2,0,7]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
<strong>输出：</strong>[]
<strong>解释：</strong>与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>
<li><code>group.length == beforeItems.length == n</code></li>
<li><code>-1 &lt;= group[i] &lt;= m - 1</code></li>
<li><code>0 &lt;= beforeItems[i].length &lt;= n - 1</code></li>
<li><code>0 &lt;= beforeItems[i][j] &lt;= n - 1</code></li>
<li><code>i != beforeItems[i][j]</code></li>
<li><code>beforeItems[i]</code> 不含重复元素</li>
</ul>
</div></div></div><br><br><hr><br>*********************<div id="title">1206. Design Skiplist</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>不使用任何库函数，设计一个 <strong>跳表</strong> 。</p>
<p><strong>跳表</strong> 是在 <code>O(log(n))</code> 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p>
<p>例如，一个跳表包含 <code>[30, 40, 50, 60, 70, 90]</code> ，然后增加 <code>80</code>、<code>45</code> 到跳表中，以下图的方式操作：</p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif"/><br/>
<small>Artyom Kalinin [CC BY-SA 3.0], via <a href="https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif" title="Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons">Wikimedia Commons</a></small></p>
<p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 <code>O(n)</code>。跳表的每一个操作的平均时间复杂度是 <code>O(log(n))</code>，空间复杂度是 <code>O(n)</code>。</p>
<p>了解更多 : <a href="https://en.wikipedia.org/wiki/Skip_list">https://en.wikipedia.org/wiki/Skip_list</a></p>
<p>在本题中，你的设计应该要包含这些函数：</p>
<ul>
<li><code>bool search(int target)</code> : 返回target是否存在于跳表中。</li>
<li><code>void add(int num)</code>: 插入一个元素到跳表。</li>
<li><code>bool erase(int num)</code>: 在跳表中删除一个值，如果 <code>num</code> 不存在，直接返回false. 如果存在多个 <code>num</code> ，删除其中任意一个即可。</li>
</ul>
<p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><b>输入</b>
["Skiplist", "add", "add", "add", "search", "add", "search", "erase", "erase", "search"]
[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]
<strong>输出</strong>
[null, null, null, null, false, null, true, false, true, false]

<strong>解释</strong>
Skiplist skiplist = new Skiplist();
skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0);   // 返回 false
skiplist.add(4);
skiplist.search(1);   // 返回 true
skiplist.erase(0);    // 返回 false，0 不在跳表中
skiplist.erase(1);    // 返回 true
skiplist.search(1);   // 返回 false，1 已被擦除
</pre>
<p> </p>
<p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt;= num, target &lt;= 2 * 10<sup>4</sup></code></li>
<li>调用<code>search</code>, <code>add</code>,  <code>erase</code>操作次数不大于 <code>5 * 10<sup>4</sup></code> </li>
</ul>
</div></div></div><br><br><hr><br>**************************************************<div id="title">1210. Minimum Moves to Reach Target with Rotations</div>
**************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你还记得那条风靡全球的贪吃蛇吗？</p>
<p>我们在一个 <code>n*n</code> 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（<code>(0, 0)</code> 和 <code>(0, 1)</code>）开始移动。我们用 <code>0</code> 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（<code>(n-1, n-2)</code> 和 <code>(n-1, n-1)</code>）。</p>
<p>每次移动，蛇可以这样走：</p>
<ul>
<li>如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。</li>
<li>如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。</li>
<li>如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（<code>(r, c)</code>、<code>(r, c+1)</code>）移动到 （<code>(r, c)</code>、<code>(r+1, c)</code>）。<br/>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-2.png" style="height: 134px; width: 300px;"/></li>
<li>如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（<code>(r, c)</code>、<code>(r+1, c)</code>）移动到（<code>(r, c)</code>、<code>(r, c+1)</code>）。<br/>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-1.png" style="height: 121px; width: 300px;"/></li>
</ul>
<p>返回蛇抵达目的地所需的最少移动次数。</p>
<p>如果无法到达目的地，请返回 <code>-1</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image.png" style="height: 439px; width: 400px;"/></strong></p>
<pre><strong>输入：</strong>grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
               [0,0,0,0,1,1],
               [0,0,1,0,1,0],
               [0,1,1,0,0,0],
               [0,1,1,0,0,0]]
<strong>输出：</strong>11
<strong>解释：
</strong>一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>grid = [[0,0,1,1,1,1],
               [0,0,0,0,1,1],
               [1,1,0,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,0]]
<strong>输出：</strong>9
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 100</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>
<li>蛇保证从空单元格开始出发。</li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">1220. Count Vowels Permutation</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数 <code>n</code>，请你帮忙统计一下我们可以按下述规则形成多少个长度为 <code>n</code> 的字符串：</p>
<ul>
<li>字符串中的每个字符都应当是小写元音字母（<code>'a'</code>, <code>'e'</code>, <code>'i'</code>, <code>'o'</code>, <code>'u'</code>）</li>
<li>每个元音 <code>'a'</code> 后面都只能跟着 <code>'e'</code></li>
<li>每个元音 <code>'e'</code> 后面只能跟着 <code>'a'</code> 或者是 <code>'i'</code></li>
<li>每个元音 <code>'i'</code> 后面 <strong>不能</strong> 再跟着另一个 <code>'i'</code></li>
<li>每个元音 <code>'o'</code> 后面只能跟着 <code>'i'</code> 或者是 <code>'u'</code></li>
<li>每个元音 <code>'u'</code> 后面只能跟着 <code>'a'</code></li>
</ul>
<p>由于答案可能会很大，所以请你返回 模 <code>10^9 + 7</code> 之后的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>5
<strong>解释：</strong>所有可能的字符串分别是："a", "e", "i" , "o" 和 "u"。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>10
<strong>解释：</strong>所有可能的字符串分别是："ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" 和 "ua"。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 5
<strong>输出：</strong>68</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 2 * 10^4</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">1223. Dice Roll Simulation</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p>
<p>不过我们在使用它时有个约束，就是使得投掷骰子时，<strong>连续</strong> 掷出数字 <code>i</code> 的次数不能超过 <code>rollMax[i]</code>（<code>i</code> 从 1 开始编号）。</p>
<p>现在，给你一个整数数组 <code>rollMax</code> 和一个整数 <code>n</code>，请你来计算掷 <code>n</code> 次骰子可得到的不同点数序列的数量。</p>
<p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 <strong>模 <code>10^9 + 7</code></strong> 之后的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 2, rollMax = [1,1,2,2,2,3]
<strong>输出：</strong>34
<strong>解释：</strong>我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2, rollMax = [1,1,1,1,1,1]
<strong>输出：</strong>30
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 3, rollMax = [1,1,1,2,2,3]
<strong>输出：</strong>181
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>rollMax.length == 6</code></li>
<li><code>1 &lt;= rollMax[i] &lt;= 15</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************<div id="title">1224. Maximum Equal Frequency</div>
*****************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个正整数数组 <code>nums</code>，请你帮忙从该数组中找出能满足下面要求的 <strong>最长</strong> 前缀，并返回该前缀的长度：</p>
<ul>
<li>从前缀中 <strong>恰好删除一个</strong> 元素后，剩下每个数字的出现次数都相同。</li>
</ul>
<p>如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [2,2,1,1,5,3,3,5]
<strong>输出：</strong>7
<strong>解释：</strong>对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4] = 5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]
<strong>输出：</strong>13
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">123. Best Time to Buy and Sell Stock III</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个数组，它的第<em> </em><code>i</code> 个元素是一支给定的股票在第 <code>i</code><em> </em>天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔 </strong>交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> </p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入：</strong>prices = [3,3,5,0,0,3,1,4]
<strong>输出：</strong>6
<strong>解释：</strong>在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>prices = [1,2,3,4,5]
<strong>输出：</strong>4
<strong>解释：</strong>在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>prices = [7,6,4,3,1] 
<strong>输出：</strong>0 
<strong>解释：</strong>在这个情况下, 没有交易完成, 所以最大利润为 0。</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>prices = [1]
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>
<li><code>0 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**************************************<div id="title">1235. Maximum Profit in Job Scheduling</div>
**************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你打算利用空闲时间来做兼职工作赚些零花钱。</p>
<p>这里有 <code>n</code> 份兼职工作，每份工作预计从 <code>startTime[i]</code> 开始到 <code>endTime[i]</code> 结束，报酬为 <code>profit[i]</code>。</p>
<p>给你一份兼职工作表，包含开始时间 <code>startTime</code>，结束时间 <code>endTime</code> 和预计报酬 <code>profit</code> 三个数组，请你计算并返回可以获得的最大报酬。</p>
<p>注意，时间上出现重叠的 2 份工作不能同时进行。</p>
<p>如果你选择的工作在时间 <code>X</code> 结束，那么你可以立刻进行在时间 <code>X</code> 开始的下一份工作。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample1_1584.png" style="width: 300px;"/></strong></p>
<pre><strong>输入：</strong>startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
<strong>输出：</strong>120
<strong>解释：
</strong>我们选出第 1 份和第 4 份工作， 
时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample22_1584.png" style="height: 112px; width: 600px;"/> </strong></p>
<pre><strong>输入：</strong>startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
<strong>输出：</strong>150
<strong>解释：
</strong>我们选择第 1，4，5 份工作。 
共获得报酬 150 = 20 + 70 + 60。
</pre>
<p><strong>示例 3：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample3_1584.png" style="height: 112px; width: 400px;"/></strong></p>
<pre><strong>输入：</strong>startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
<strong>输出：</strong>6
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= startTime.length == endTime.length == profit.length &lt;= 5 * 10^4</code></li>
<li><code>1 &lt;= startTime[i] &lt; endTime[i] &lt;= 10^9</code></li>
<li><code>1 &lt;= profit[i] &lt;= 10^4</code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">124. Binary Tree Maximum Path Sum</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径<strong> 至少包含一个 </strong>节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" style="width: 322px; height: 182px;"/>
<pre><strong>输入：</strong>root = [1,2,3]
<strong>输出：</strong>6
<strong>解释：</strong>最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg"/>
<pre><strong>输入：</strong>root = [-10,9,20,null,null,15,7]
<strong>输出：</strong>42
<strong>解释：</strong>最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 10<sup>4</sup>]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************************<div id="title">1240. Tiling a Rectangle with the Fewest Squares</div>
************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。</p>
<p>房子的客厅大小为 <code>n</code> x <code>m</code>，为保持极简的风格，需要使用尽可能少的 <strong>正方形</strong> 瓷砖来铺盖地面。</p>
<p>假设正方形瓷砖的规格不限，边长都是整数。</p>
<p>请你帮设计师计算一下，最少需要用到多少块方形瓷砖？</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_11_1592.png" style="height: 106px; width: 154px;"/></p>
<pre><strong>输入：</strong>n = 2, m = 3
<strong>输出：</strong>3
<code><strong>解释：</strong>3</code> 块地砖就可以铺满卧室。
<code>     2</code> 块 <code>1x1 地砖</code>
<code>     1</code> 块 <code>2x2 地砖</code></pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_22_1592.png" style="height: 126px; width: 224px;"/></p>
<pre><strong>输入：</strong>n = 5, m = 8
<strong>输出：</strong>5
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_33_1592.png" style="height: 189px; width: 224px;"/></p>
<pre><strong>输入：</strong>n = 11, m = 13
<strong>输出：</strong>6
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 13</code></li>
<li><code>1 &lt;= m &lt;= 13</code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1250. Check If It Is a Good Array</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个正整数数组 <code>nums</code>，你需要从中任选一些子集，然后将子集中每一个数乘以一个 <strong>任意整数</strong>，并求出他们的和。</p>
<p>假如该和结果为 <code>1</code>，那么原数组就是一个「<strong>好数组</strong>」，则返回 <code>True</code>；否则请返回 <code>False</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [12,5,7,23]
<strong>输出：</strong>true
<strong>解释：</strong>挑选数字 5 和 7。
5*3 + 7*(-2) = 1
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [29,6,10]
<strong>输出：</strong>true
<strong>解释：</strong>挑选数字 29, 6 和 10。
29*1 + 6*(-3) + 10*(-1) = 1
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [3,6]
<strong>输出：</strong>false
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************************<div id="title">1255. Maximum Score Words Formed by Letters</div>
*******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你将会得到一份单词表 <code>words</code>，一个字母表 <code>letters</code> （可能会有重复字母），以及每个字母对应的得分情况表 <code>score</code>。</p>
<p>请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 <code>letters</code> 里的字母拼写出的 <strong>任意</strong> 属于 <code>words</code> 单词子集中，分数最高的单词集合的得分。</p>
<p>单词拼写游戏的规则概述如下：</p>
<ul>
<li>玩家需要用字母表 <code>letters</code> 里的字母来拼写单词表 <code>words</code> 中的单词。</li>
<li>可以只使用字母表 <code>letters</code> 中的部分字母，但是每个字母最多被使用一次。</li>
<li>单词表 <code>words</code> 中每个单词只能计分（使用）一次。</li>
<li>根据字母得分情况表<code>score</code>，字母 <code>'a'</code>, <code>'b'</code>, <code>'c'</code>, ... , <code>'z'</code> 对应的得分分别为 <code>score[0]</code>, <code>score[1]</code>, ..., <code>score[25]</code>。</li>
<li>本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>words = ["dog","cat","dad","good"], letters = ["a","a","c","d","d","d","g","o","o"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
<strong>输出：</strong>23
<strong>解释：</strong>
字母得分为  a=1, c=9, d=5, g=3, o=2
使用给定的字母表 letters，我们可以拼写单词 "dad" (5+1+5)和 "good" (3+2+2+5)，得分为 23 。
而单词 "dad" 和 "dog" 只能得到 21 分。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>words = ["xxxz","ax","bx","cx"], letters = ["z","a","b","c","x","x","x"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
<strong>输出：</strong>27
<strong>解释：</strong>
字母得分为  a=4, b=4, c=4, x=5, z=10
使用给定的字母表 letters，我们可以组成单词 "ax" (4+5)， "bx" (4+5) 和 "cx" (4+5) ，总得分为 27 。
单词 "xxxz" 的得分仅为 25 。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>words = ["leetcode"], letters = ["l","e","t","c","o","d"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
<strong>输出：</strong>0
<strong>解释：</strong>
字母 "e" 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 14</code></li>
<li><code>1 &lt;= words[i].length &lt;= 15</code></li>
<li><code>1 &lt;= letters.length &lt;= 100</code></li>
<li><code>letters[i].length == 1</code></li>
<li><code>score.length == 26</code></li>
<li><code>0 &lt;= score[i] &lt;= 10</code></li>
<li><code>words[i]</code> 和 <code>letters[i]</code> 只包含小写的英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*******************<div id="title">126. Word Ladder II</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>按字典 <code>wordList</code> 完成从单词 <code>beginWord</code> 到单词 <code>endWord</code> 转化，一个表示此过程的 <strong>转换序列</strong> 是形式上像 <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> 这样的单词序列，并满足：</p>
<div class="original__bRMd">
<div>
<ul>
<li>每对相邻的单词之间仅有单个字母不同。</li>
<li>转换过程中的每个单词 <code>s<sub>i</sub></code>（<code>1 &lt;= i &lt;= k</code>）必须是字典 <code>wordList</code> 中的单词。注意，<code>beginWord</code> 不必是字典 <code>wordList</code> 中的单词。</li>
<li><code>s<sub>k</sub> == endWord</code></li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> ，以及一个字典 <code>wordList</code> 。请你找出并返回所有从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表<em> </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code> 的形式返回。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
<strong>输出：</strong>[["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
<strong>解释：</strong>存在 2 种最短的转换序列：
"hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog"
"hit" -&gt; "hot" -&gt; "lot" -&gt; "log" -&gt; "cog"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
<strong>输出：</strong>[]
<strong>解释：</strong>endWord "cog" 不在字典 wordList 中，所以不存在符合要求的转换序列。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>
<li><code>endWord.length == beginWord.length</code></li>
<li><code>1 &lt;= wordList.length &lt;= 500</code></li>
<li><code>wordList[i].length == beginWord.length</code></li>
<li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li>
<li><code>beginWord != endWord</code></li>
<li><code>wordList</code> 中的所有单词 <strong>互不相同</strong></li>
</ul>
</div>
</div>
</div></div></div><br><br><hr><br>**********************************************************<div id="title">1263. Minimum Moves to Move a Box to Their Target Location</div>
**********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。</p>
<p>游戏地图用大小为 <code>m x n</code> 的网格 <code>grid</code> 表示，其中每个元素可以是墙、地板或者是箱子。</p>
<p>现在你将作为玩家参与游戏，按规则将箱子 <code>'B'</code> 移动到目标位置 <code>'T'</code> ：</p>
<ul>
<li>玩家用字符 <code>'S'</code> 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。</li>
<li>地板用字符 <code>'.'</code> 表示，意味着可以自由行走。</li>
<li>墙用字符 <code>'#'</code> 表示，意味着障碍物，不能通行。 </li>
<li>箱子仅有一个，用字符 <code>'B'</code> 表示。相应地，网格上有一个目标位置 <code>'T'</code>。</li>
<li>玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。</li>
<li>玩家无法越过箱子。</li>
</ul>
<p>返回将箱子推到目标位置的最小 <strong>推动</strong> 次数，如果无法做到，请返回 <code>-1</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/sample_1_1620.png" style="height: 335px; width: 500px;"/></strong></p>
<pre><strong>输入：</strong>grid = [["#","#","#","#","#","#"],
             ["#","T","#","#","#","#"],
             ["#",".",".","B",".","#"],
             ["#",".","#","#",".","#"],
             ["#",".",".",".","S","#"],
             ["#","#","#","#","#","#"]]
<strong>输出：</strong>3
<strong>解释：</strong>我们只需要返回推箱子的次数。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>grid = [["#","#","#","#","#","#"],
             ["#","T","#","#","#","#"],
             ["#",".",".","B",".","#"],
             ["#","#","#","#",".","#"],
             ["#",".",".",".","S","#"],
             ["#","#","#","#","#","#"]]
<strong>输出：</strong>-1
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>grid = [["#","#","#","#","#","#"],
             ["#","T",".",".","#","#"],
             ["#",".","#","B",".","#"],
             ["#",".",".",".",".","#"],
             ["#",".",".",".","S","#"],
             ["#","#","#","#","#","#"]]
<strong>输出：</strong>5
<strong>解释：</strong>向下、向左、向左、向上再向上。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 20</code></li>
<li><code>grid</code> 仅包含字符 <code>'.'</code>, <code>'#'</code>,  <code>'S'</code> , <code>'T'</code>, 以及 <code>'B'</code>。</li>
<li><code>grid</code> 中 <code>'S'</code>, <code>'B'</code> 和 <code>'T'</code> 各只能出现一个。</li>
</ul>
</div></div></div><br><br><hr><br>***************************************************************<div id="title">1269. Number of Ways to Stay in the Same Place After Some Steps</div>
***************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>有一个长度为 <code>arrLen</code> 的数组，开始有一个指针在索引 <code>0</code> 处。</p>
<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>
<p>给你两个整数 <code>steps</code> 和 <code>arrLen</code> ，请你计算并返回：在恰好执行 <code>steps</code> 次操作以后，指针仍然指向索引 <code>0</code> 处的方案数。</p>
<p>由于答案可能会很大，请返回方案数 <strong>模</strong> <code>10^9 + 7</code> 后的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>steps = 3, arrLen = 2
<strong>输出：</strong>4
<strong>解释：</strong>3 步后，总共有 4 种不同的方法可以停在索引 0 处。
向右，向左，不动
不动，向右，向左
向右，不动，向左
不动，不动，不动
</pre>
<p><strong>示例  2：</strong></p>
<pre><strong>输入：</strong>steps = 2, arrLen = 4
<strong>输出：</strong>2
<strong>解释：</strong>2 步后，总共有 2 种不同的方法可以停在索引 0 处。
向右，向左
不动，不动
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>steps = 4, arrLen = 2
<strong>输出：</strong>8
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= steps &lt;= 500</code></li>
<li><code>1 &lt;= arrLen &lt;= 10<sup>6</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>****************<div id="title">127. Word Ladder</div>
****************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code><em> </em>和 <code>endWord</code> 的 <strong>转换序列 </strong>是一个按下述规格形成的序列 <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code>：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li> 对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>s<sub>i</sub></code> 都在 <code>wordList</code> 中。注意， <code>beginWord</code><em> </em>不需要在 <code>wordList</code> 中。</li>
<li><code>s<sub>k</sub> == endWord</code></li>
</ul>
<p>给你两个单词<em> </em><code>beginWord</code><em> </em>和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p>
 

<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
<strong>输出：</strong>5
<strong>解释：</strong>一个最短转换序列是 "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog", 返回它的长度 5。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
<strong>输出：</strong>0
<strong>解释：</strong>endWord "cog" 不在字典中，所以无法进行转换。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>
<li><code>endWord.length == beginWord.length</code></li>
<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>
<li><code>wordList[i].length == beginWord.length</code></li>
<li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li>
<li><code>beginWord != endWord</code></li>
<li><code>wordList</code> 中的所有字符串 <strong>互不相同</strong></li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1278. Palindrome Partitioning III</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个由小写字母组成的字符串 <code>s</code>，和一个整数 <code>k</code>。</p>
<p>请你按下面的要求分割字符串：</p>
<ul>
<li>首先，你可以将 <code>s</code> 中的部分字符修改为其他的小写英文字母。</li>
<li>接着，你需要把 <code>s</code> 分割成 <code>k</code> 个非空且不相交的子串，并且每个子串都是回文串。</li>
</ul>
<p>请返回以这种方式分割字符串所需修改的最少字符数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "abc", k = 2
<strong>输出：</strong>1
<strong>解释：</strong>你可以把字符串分割成 "ab" 和 "c"，并修改 "ab" 中的 1 个字符，将它变成回文串。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "aabbc", k = 3
<strong>输出：</strong>0
<strong>解释：</strong>你可以把字符串分割成 "aa"、"bb" 和 "c"，它们都是回文串。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "leetcode", k = 8
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 中只含有小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*********************************************************************<div id="title">1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</div>
*********************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m x n</code> 的二进制矩阵 <code>mat</code>。每一步，你可以选择一个单元格并将它反转（反转表示 <code>0</code> 变 <code>1</code> ，<code>1</code> 变 <code>0</code> ）。如果存在和它相邻的单元格，那么这些相邻的单元格也会被反转。相邻的两个单元格共享同一条边。</p>
<p>请你返回将矩阵 <code>mat</code> 转化为全零矩阵的<em>最少反转次数</em>，如果无法转化为全零矩阵，请返回 <code>-1</code> 。</p>
<p><strong>二进制矩阵</strong> 的每一个格子要么是 <code>0</code> 要么是 <code>1</code> 。</p>
<p><strong>全零矩阵</strong> 是所有格子都为 <code>0</code> 的矩阵。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/13/matrix.png"/></p>
<pre><strong>输入：</strong>mat = [[0,0],[0,1]]
<strong>输出：</strong>3
<strong>解释：</strong>一个可能的解是反转 (1, 0)，然后 (0, 1) ，最后是 (1, 1) 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>mat = [[0]]
<strong>输出：</strong>0
<strong>解释：</strong>给出的矩阵是全零矩阵，所以你不需要改变它。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>mat = [[1,0,0],[1,0,0]]
<strong>输出：</strong>-1
<strong>解释：</strong>该矩阵无法转变成全零矩阵
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[0].length</code></li>
<li><code>1 &lt;= m &lt;= 3</code></li>
<li><code>1 &lt;= n &lt;= 3</code></li>
<li><code>mat[i][j]</code> 是 0 或 1 。</li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1289. Minimum Falling Path Sum II</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>n x n</code> 整数矩阵 <code>arr</code> ，请你返回 <strong>非零偏移下降路径</strong> 数字和的最小值。</p>
<p><strong>非零偏移下降路径</strong> 定义为：从 <code>arr</code> 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2021/08/10/falling-grid.jpg" style="width: 244px; height: 245px;"/></p>
<pre><strong>输入：</strong>arr = [[1,2,3],[4,5,6],[7,8,9]]
<strong>输出：</strong>13
<strong>解释：</strong>
所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>grid = [[7]]
<strong>输出：</strong>7
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == grid.length == grid[i].length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>-99 &lt;= grid[i][j] &lt;= 99</code></li>
</ul>
</div></div></div><br><br><hr><br>********************************************************<div id="title">1293. Shortest Path in a Grid with Obstacles Elimination</div>
********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m * n</code> 的网格，其中每个单元格不是 <code>0</code>（空）就是 <code>1</code>（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。</p>
<p>如果您 <strong>最多</strong> 可以消除 <code>k</code> 个障碍物，请找出从左上角 <code>(0, 0)</code> 到右下角 <code>(m-1, n-1)</code> 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 <code>-1</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg"/></p>
<pre><strong>输入：</strong> grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
<strong>输出：</strong>6
<strong>解释：
</strong>不消除任何障碍的最短路径是 10。
消除位置 (3,2) 处的障碍后，最短路径是 6 。该路径是 <code>(0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; <strong>(3,2)</strong> -&gt; (4,2)</code>.
</pre>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg"/></p>
<pre><strong>输入：</strong>grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1
<strong>输出：</strong>-1
<strong>解释：</strong>我们至少需要消除两个障碍才能找到这样的路径。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>grid.length == m</code></li>
<li><code>grid[0].length == n</code></li>
<li><code>1 &lt;= m, n &lt;= 40</code></li>
<li><code>1 &lt;= k &lt;= m*n</code></li>
<li><code>grid[i][j]</code> 是 <code>0</code> 或<strong> </strong><code>1</code></li>
<li><code>grid[0][0] == grid[m-1][n-1] == 0</code></li>
</ul>
</div></div></div><br><br><hr><br>********************************************<div id="title">1298. Maximum Candies You Can Get from Boxes</div>
********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你 <code>n</code> 个盒子，每个盒子的格式为 <code>[status, candies, keys, containedBoxes]</code> ，其中：</p>
<ul>
<li>状态字 <code>status[i]</code>：整数，如果 <code>box[i]</code> 是开的，那么是 <strong>1 </strong>，否则是 <strong>0 </strong>。</li>
<li>糖果数 <code>candies[i]</code>: 整数，表示 <code>box[i]</code> 中糖果的数目。</li>
<li>钥匙 <code>keys[i]</code>：数组，表示你打开 <code>box[i]</code> 后，可以得到一些盒子的钥匙，每个元素分别为该钥匙对应盒子的下标。</li>
<li>内含的盒子 <code>containedBoxes[i]</code>：整数，表示放在 <code>box[i]</code> 里的盒子所对应的下标。</li>
</ul>
<p>给你一个 <code>initialBoxes</code> 数组，表示你现在得到的盒子，你可以获得里面的糖果，也可以用盒子里的钥匙打开新的盒子，还可以继续探索从这个盒子里找到的其他盒子。</p>
<p>请你按照上述规则，返回可以获得糖果的 <strong>最大数目 </strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]
<strong>输出：</strong>16
<strong>解释：
</strong>一开始你有盒子 0 。你将获得它里面的 7 个糖果和盒子 1 和 2。
盒子 1 目前状态是关闭的，而且你还没有对应它的钥匙。所以你将会打开盒子 2 ，并得到里面的 4 个糖果和盒子 1 的钥匙。
在盒子 1 中，你会获得 5 个糖果和盒子 3 ，但是你没法获得盒子 3 的钥匙所以盒子 3 会保持关闭状态。
你总共可以获得的糖果数目 = 7 + 4 + 5 = 16 个。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]
<strong>输出：</strong>6
<strong>解释：
</strong>你一开始拥有盒子 0 。打开它你可以找到盒子 1,2,3,4,5 和它们对应的钥匙。
打开这些盒子，你将获得所有盒子的糖果，所以总糖果数为 6 个。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>status = [1,1,1], candies = [100,1,100], keys = [[],[0,2],[]], containedBoxes = [[],[],[]], initialBoxes = [1]
<strong>输出：</strong>1
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>status = [1], candies = [100], keys = [[]], containedBoxes = [[]], initialBoxes = []
<strong>输出：</strong>0
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>status = [1,1,1], candies = [2,3,2], keys = [[],[],[]], containedBoxes = [[],[],[]], initialBoxes = [2,1,0]
<strong>输出：</strong>7
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= status.length &lt;= 1000</code></li>
<li><code>status.length == candies.length == keys.length == containedBoxes.length == n</code></li>
<li><code>status[i]</code> 要么是 <code>0</code> 要么是 <code>1</code> 。</li>
<li><code>1 &lt;= candies[i] &lt;= 1000</code></li>
<li><code>0 &lt;= keys[i].length &lt;= status.length</code></li>
<li><code>0 &lt;= keys[i][j] &lt; status.length</code></li>
<li><code>keys[i]</code> 中的值都是互不相同的。</li>
<li><code>0 &lt;= containedBoxes[i].length &lt;= status.length</code></li>
<li><code>0 &lt;= containedBoxes[i][j] &lt; status.length</code></li>
<li><code>containedBoxes[i]</code> 中的值都是互不相同的。</li>
<li>每个盒子最多被一个盒子包含。</li>
<li><code>0 &lt;= initialBoxes.length &lt;= status.length</code></li>
<li><code>0 &lt;= initialBoxes[i] &lt; status.length</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************<div id="title">1301. Number of Paths with Max Score</div>
************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个正方形字符数组 <code>board</code> ，你从数组最右下方的字符 <code>'S'</code> 出发。</p>
<p>你的目标是到达数组最左上角的字符 <code>'E'</code> ，数组剩余的部分为数字字符 <code>1, 2, ..., 9</code> 或者障碍 <code>'X'</code>。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。</p>
<p>一条路径的 「得分」 定义为：路径上所有数字的和。</p>
<p>请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对 <strong><code>10^9 + 7</code></strong> <strong>取余</strong>。</p>
<p>如果没有任何路径可以到达终点，请返回 <code>[0, 0]</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>board = ["E23","2X2","12S"]
<strong>输出：</strong>[7,1]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>board = ["E12","1X1","21S"]
<strong>输出：</strong>[4,2]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>board = ["E11","XXX","11S"]
<strong>输出：</strong>[0,0]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= board.length == board[i].length &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">1307. Verbal Arithmetic Puzzle</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个方程，左边用 <code>words</code> 表示，右边用 <code>result</code> 表示。</p>
<p>你需要根据以下规则检查方程是否可解：</p>
<ul>
<li>每个字符都会被解码成一位数字（0 - 9）。</li>
<li>每对不同的字符必须映射到不同的数字。</li>
<li>每个 <code>words[i]</code> 和 <code>result</code> 都会被解码成一个没有前导零的数字。</li>
<li>左侧数字之和（<code>words</code>）等于右侧数字（<code>result</code>）。 </li>
</ul>
<p>如果方程可解，返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>words = ["SEND","MORE"], result = "MONEY"
<strong>输出：</strong>true
<strong>解释：</strong>映射 'S'-&gt; 9, 'E'-&gt;5, 'N'-&gt;6, 'D'-&gt;7, 'M'-&gt;1, 'O'-&gt;0, 'R'-&gt;8, 'Y'-&gt;'2'
所以 "SEND" + "MORE" = "MONEY" ,  9567 + 1085 = 10652</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>words = ["SIX","SEVEN","SEVEN"], result = "TWENTY"
<strong>输出：</strong>true
<strong>解释：</strong>映射 'S'-&gt; 6, 'I'-&gt;5, 'X'-&gt;0, 'E'-&gt;8, 'V'-&gt;7, 'N'-&gt;2, 'T'-&gt;1, 'W'-&gt;'3', 'Y'-&gt;4
所以 "SIX" + "SEVEN" + "SEVEN" = "TWENTY" ,  650 + 68782 + 68782 = 138214</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>words = ["THIS","IS","TOO"], result = "FUNNY"
<strong>输出：</strong>true
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>words = ["LEET","CODE"], result = "POINT"
<strong>输出：</strong>false
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= words.length &lt;= 5</code></li>
<li><code>1 &lt;= words[i].length, results.length &lt;= 7</code></li>
<li><code>words[i], result</code> 只含有大写英文字母</li>
<li>表达式中使用的不同字符数最大为 10</li>
</ul>
</div></div></div><br><br><hr><br>*********************************************************<div id="title">1312. Minimum Insertion Steps to Make a String Palindrome</div>
*********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。</p>
<p>请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。</p>
<p>「回文串」是正读和反读都相同的字符串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "zzazz"
<strong>输出：</strong>0
<strong>解释：</strong>字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "mbadm"
<strong>输出：</strong>2
<strong>解释：</strong>字符串可变为 "mbdadbm" 或者 "mdbabdm" 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "leetcode"
<strong>输出：</strong>5
<strong>解释：</strong>插入 5 个字符后字符串变为 "leetcodocteel" 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 中所有字符都是小写字母。</li>
</ul>
</div></div></div><br><br><hr><br>******************************<div id="title">1316. Distinct Echo Substrings</div>
******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>text</code> ，请你返回满足下述条件的 <strong>不同</strong> 非空子字符串的数目：</p>
<ul>
<li>可以写成某个字符串与其自身相连接的形式（即，可以写为 <code>a + a</code>，其中 <code>a</code> 是某个字符串）。</li>
</ul>
<p>例如，<code>abcabc</code> 就是 <code>abc</code> 和它自身连接形成的。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>text = "abcabcabc"
<strong>输出：</strong>3
<strong>解释：</strong>3 个子字符串分别为 "abcabc"，"bcabca" 和 "cabcab" 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>text = "leetcodeleetcode"
<strong>输出：</strong>2
<strong>解释：</strong>2 个子字符串为 "ee" 和 "leetcodeleetcode" 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text.length &lt;= 2000</code></li>
<li><code>text</code> 只包含小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">132. Palindrome Partitioning II</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>
<div class="original__bRMd">
<div>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "aab"
<strong>输出：</strong>1
<strong>解释：</strong>只需一次分割就可将 <em>s </em>分割成 ["aa","b"] 这样两个回文子串。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "a"
<strong>输出：</strong>0
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "ab"
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
</div>
</div>
</div></div></div><br><br><hr><br>*******************************************************<div id="title">1320. Minimum Distance to Type a Word Using Two Fingers</div>
*******************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/leetcode_keyboard.png"/></p>
<p>二指输入法定制键盘在 <strong>X-Y</strong> 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处。</p>
<ul>
<li>例如字母 <strong>A</strong> 位于坐标 <strong>(0,0)</strong>，字母 <strong>B</strong> 位于坐标 <strong>(0,1)</strong>，字母 <strong>P</strong> 位于坐标 <strong>(2,3)</strong> 且字母 <strong>Z</strong> 位于坐标 <strong>(4,1)</strong>。</li>
</ul>
<p>给你一个待输入字符串 <code>word</code>，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。</p>
<p>坐标<code> <strong>(x<sub>1</sub>,y<sub>1</sub>)</strong> </code>和 <code><strong>(x<sub>2</sub>,y<sub>2</sub>)</strong></code> 之间的 <strong>距离</strong> 是 <code><strong>|x<sub>1</sub> - x<sub>2</sub>| + |y<sub>1</sub> - y<sub>2</sub>|</strong></code>。 </p>
<p><strong>注意</strong>，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>word = "CAKE"
<strong>输出：</strong>3
<strong>解释： 
</strong>使用两根手指输入 "CAKE" 的最佳方案之一是： 
手指 1 在字母 'C' 上 -&gt; 移动距离 = 0 
手指 1 在字母 'A' 上 -&gt; 移动距离 = 从字母 'C' 到字母 'A' 的距离 = 2 
手指 2 在字母 'K' 上 -&gt; 移动距离 = 0 
手指 2 在字母 'E' 上 -&gt; 移动距离 = 从字母 'K' 到字母 'E' 的距离  = 1 
总距离 = 3
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>word = "HAPPY"
<strong>输出：</strong>6
<strong>解释： </strong>
使用两根手指输入 "HAPPY" 的最佳方案之一是：
手指 1 在字母 'H' 上 -&gt; 移动距离 = 0
手指 1 在字母 'A' 上 -&gt; 移动距离 = 从字母 'H' 到字母 'A' 的距离 = 2
手指 2 在字母 'P' 上 -&gt; 移动距离 = 0
手指 2 在字母 'P' 上 -&gt; 移动距离 = 从字母 'P' 到字母 'P' 的距离 = 0
手指 1 在字母 'Y' 上 -&gt; 移动距离 = 从字母 'A' 到字母 'Y' 的距离 = 4
总距离 = 6
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= word.length &lt;= 300</code></li>
<li>每个 <code>word[i]</code> 都是一个大写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>******************************************************<div id="title">1326. Minimum Number of Taps to Open to Water a Garden</div>
******************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在 x 轴上有一个一维的花园。花园长度为 <code>n</code>，从点 <code>0</code> 开始，到点 <code>n</code> 结束。</p>
<p>花园里总共有 <code>n + 1</code> 个水龙头，分别位于 <code>[0, 1, ..., n]</code> 。</p>
<p>给你一个整数 <code>n</code> 和一个长度为 <code>n + 1</code> 的整数数组 <code>ranges</code> ，其中 <code>ranges[i]</code> （下标从 0 开始）表示：如果打开点 <code>i</code> 处的水龙头，可以灌溉的区域为 <code>[i -  ranges[i], i + ranges[i]]</code> 。</p>
<p>请你返回可以灌溉整个花园的 <strong>最少水龙头数目</strong> 。如果花园始终存在无法灌溉到的地方，请你返回 <strong>-1</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/19/1685_example_1.png"/></p>
<pre><strong>输入：</strong>n = 5, ranges = [3,4,1,1,0,0]
<strong>输出：</strong>1
<strong>解释：
</strong>点 0 处的水龙头可以灌溉区间 [-3,3]
点 1 处的水龙头可以灌溉区间 [-3,5]
点 2 处的水龙头可以灌溉区间 [1,3]
点 3 处的水龙头可以灌溉区间 [2,4]
点 4 处的水龙头可以灌溉区间 [4,4]
点 5 处的水龙头可以灌溉区间 [5,5]
只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 3, ranges = [0,0,0,0]
<strong>输出：</strong>-1
<strong>解释：</strong>即使打开所有水龙头，你也无法灌溉整个花园。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>
<li><code>ranges.length == n + 1</code></li>
<li><code>0 &lt;= ranges[i] &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************************<div id="title">1330. Reverse Subarray To Maximize Array Value</div>
**********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 。「数组值」定义为所有满足 <code>0 &lt;= i &lt; nums.length-1</code> 的 <code>|nums[i]-nums[i+1]|</code> 的和。</p>
<p>你可以选择给定数组的任意子数组，并将该子数组翻转。但你只能执行这个操作 <strong>一次</strong> 。</p>
<p>请你找到可行的最大 <strong>数组值 </strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [2,3,1,5,4]
<strong>输出：</strong>10
<strong>解释：</strong>通过翻转子数组 [3,1,5] ，数组变成 [2,5,1,3,4] ，数组值为 10 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [2,4,9,24,2,1,10]
<strong>输出：</strong>68
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3*10^4</code></li>
<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
</div></div></div><br><br><hr><br>******************************************<div id="title">1335. Minimum Difficulty of a Job Schedule</div>
******************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你需要制定一份 <code>d</code> 天的工作计划表。工作之间存在依赖，要想执行第 <code>i</code> 项工作，你必须完成全部 <code>j</code> 项工作（ <code>0 &lt;= j &lt; i</code>）。</p>
<p>你每天 <strong>至少</strong> 需要完成一项任务。工作计划的总难度是这 <code>d</code> 天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。</p>
<p>给你一个整数数组 <code>jobDifficulty</code> 和一个整数 <code>d</code>，分别代表工作难度和需要计划的天数。第 <code>i</code> 项工作的难度是 <code>jobDifficulty[i]</code>。</p>
<p>返回整个工作计划的 <strong>最小难度</strong> 。如果无法制定工作计划，则返回 <strong>-1 </strong>。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/untitled.png" style="height: 304px; width: 365px;"/></p>
<pre><strong>输入：</strong>jobDifficulty = [6,5,4,3,2,1], d = 2
<strong>输出：</strong>7
<strong>解释：</strong>第一天，您可以完成前 5 项工作，总难度 = 6.
第二天，您可以完成最后一项工作，总难度 = 1.
计划表的难度 = 6 + 1 = 7 
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>jobDifficulty = [9,9,9], d = 4
<strong>输出：</strong>-1
<strong>解释：</strong>就算你每天完成一项工作，仍然有一天是空闲的，你无法制定一份能够满足既定工作时间的计划表。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>jobDifficulty = [1,1,1], d = 3
<strong>输出：</strong>3
<strong>解释：</strong>工作计划为每天一项工作，总难度为 3 。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>jobDifficulty = [7,1,7,1,7,1], d = 3
<strong>输出：</strong>15
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>jobDifficulty = [11,111,22,222,33,333,44,444], d = 6
<strong>输出：</strong>843
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= jobDifficulty.length &lt;= 300</code></li>
<li><code>0 &lt;= jobDifficulty[i] &lt;= 1000</code></li>
<li><code>1 &lt;= d &lt;= 10</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************<div id="title">1340. Jump Game V</div>
*****************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>d</code> 。每一步你可以从下标 <code>i</code> 跳到：</p>
<ul>
<li><code>i + x</code> ，其中 <code>i + x &lt; arr.length</code> 且 <code>0 &lt; x &lt;= d</code> 。</li>
<li><code>i - x</code> ，其中 <code>i - x &gt;= 0</code> 且 <code>0 &lt; x &lt;= d</code> 。</li>
</ul>
<p>除此以外，你从下标 <code>i</code> 跳到下标 <code>j</code> 需要满足：<code>arr[i] &gt; arr[j]</code> 且 <code>arr[i] &gt; arr[k]</code> ，其中下标 <code>k</code> 是所有 <code>i</code> 到 <code>j</code> 之间的数字（更正式的，<code>min(i, j) &lt; k &lt; max(i, j)</code>）。</p>
<p>你可以选择数组的任意下标开始跳跃。请你返回你 <strong>最多</strong> 可以访问多少个下标。</p>
<p>请注意，任何时刻你都不能跳到数组的外面。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/meta-chart.jpeg" style="height: 419px; width: 633px;"/></p>
<pre><strong>输入：</strong>arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2
<strong>输出：</strong>4
<strong>解释：</strong>你可以从下标 10 出发，然后如上图依次经过 10 --&gt; 8 --&gt; 6 --&gt; 7 。
注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 &gt; 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 &gt; 9 。
类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>arr = [3,3,3,3,3], d = 3
<strong>输出：</strong>1
<strong>解释：</strong>你可以从任意下标处开始且你永远无法跳到任何其他坐标。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>arr = [7,6,5,4,3,2,1], d = 1
<strong>输出：</strong>7
<strong>解释：</strong>从下标 0 处开始，你可以按照数值从大到小，访问所有的下标。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>arr = [7,1,7,1,7,1], d = 2
<strong>输出：</strong>2
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>arr = [66], d = 1
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 1000</code></li>
<li><code>1 &lt;= arr[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= d &lt;= arr.length</code></li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">1345. Jump Game IV</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>arr</code> ，你一开始在数组的第一个元素处（下标为 0）。</p>
<p>每一步，你可以从下标 <code>i</code> 跳到下标 <code>i + 1</code> 、<code>i - 1</code> 或者 <code>j</code> ：</p>
<ul>
<li><code>i + 1</code> 需满足：<code>i + 1 &lt; arr.length</code></li>
<li><code>i - 1</code> 需满足：<code>i - 1 &gt;= 0</code></li>
<li><code>j</code> 需满足：<code>arr[i] == arr[j]</code> 且 <code>i != j</code></li>
</ul>
<p>请你返回到达数组最后一个元素的下标处所需的 <strong>最少操作次数</strong> 。</p>
<p>注意：任何时候你都不能跳到数组外面。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>arr = [100,-23,-23,404,100,23,23,23,3,404]
<strong>输出：</strong>3
<strong>解释：</strong>那你需要跳跃 3 次，下标依次为 0 --&gt; 4 --&gt; 3 --&gt; 9 。下标 9 为数组的最后一个元素的下标。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>arr = [7]
<strong>输出：</strong>0
<strong>解释：</strong>一开始就在最后一个元素处，所以你不需要跳跃。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>arr = [7,6,9,6,9,6,9,7]
<strong>输出：</strong>1
<strong>解释：</strong>你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>-10<sup>8</sup> &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>**********************************<div id="title">1349. Maximum Students Taking Exam</div>
**********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m * n</code> 的矩阵 <code>seats</code> 表示教室中的座位分布。如果座位是坏的（不可用），就用 <code>'#'</code> 表示；否则，用 <code>'.'</code> 表示。</p>
<p>学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。</p>
<p>学生必须坐在状况良好的座位上。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/09/image.png" style="height: 197px; width: 339px;"/></p>
<pre><strong>输入：</strong>seats = [["#",".","#","#",".","#"],
              [".","#","#","#","#","."],
              ["#",".","#","#",".","#"]]
<strong>输出：</strong>4
<strong>解释：</strong>教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。 
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>seats = [[".","#"],
              ["#","#"],
              ["#","."],
              ["#","#"],
              [".","#"]]
<strong>输出：</strong>3
<strong>解释：</strong>让所有学生坐在可用的座位上。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>seats = [["#",".","<strong>.</strong>",".","#"],
              ["<strong>.</strong>","#","<strong>.</strong>","#","<strong>.</strong>"],
              ["<strong>.</strong>",".","#",".","<strong>.</strong>"],
              ["<strong>.</strong>","#","<strong>.</strong>","#","<strong>.</strong>"],
              ["#",".","<strong>.</strong>",".","#"]]
<strong>输出：</strong>10
<strong>解释：</strong>让学生坐在第 1、3 和 5 列的可用座位上。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>seats</code> 只包含字符 <code>'.' 和</code><code>'#'</code></li>
<li><code>m == seats.length</code></li>
<li><code>n == seats[i].length</code></li>
<li><code>1 &lt;= m &lt;= 8</code></li>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
</div></div></div><br><br><hr><br>**********<div id="title">135. Candy</div>
**********<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>ratings = [1,0,2]
<strong>输出：</strong>5
<strong>解释：</strong>你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>ratings = [1,2,2]
<strong>输出：</strong>4
<strong>解释：</strong>你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == ratings.length</code></li>
<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>
<li><code>0 &lt;= ratings[i] &lt;= 2 * 10<sup>4</sup></code></li>
</ul>
</div></div></div><br><br><hr><br>***********************************************<div id="title">1354. Construct Target Array With Multiple Sums</div>
***********************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>target</code> 。一开始，你有一个数组 <code>A</code> ，它的所有元素均为 1 ，你可以执行以下操作：</p>
<ul>
<li>令 <code>x</code> 为你数组里所有元素的和</li>
<li>选择满足 <code>0 &lt;= i &lt; target.size</code> 的任意下标 <code>i</code> ，并让 <code>A</code> 数组里下标为 <code>i</code> 处的值为 <code>x</code> 。</li>
<li>你可以重复该过程任意次</li>
</ul>
<p>如果能从 <code>A</code> 开始构造出目标数组 <code>target</code> ，请你返回 True ，否则返回 False 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>target = [9,3,5]
<strong>输出：</strong>true
<strong>解释：</strong>从 [1, 1, 1] 开始
[1, 1, 1], 和为 3 ，选择下标 1
[1, 3, 1], 和为 5， 选择下标 2
[1, 3, 5], 和为 9， 选择下标 0
[9, 3, 5] 完成
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>target = [1,1,1,2]
<strong>输出：</strong>false
<strong>解释：</strong>不可能从 [1,1,1,1] 出发构造目标数组。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>target = [8,5]
<strong>输出：</strong>true
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>N == target.length</code></li>
<li><code>1 &lt;= target.length &lt;= 5 * 10^4</code></li>
<li><code>1 &lt;= target[i] &lt;= 10^9</code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************************<div id="title">1359. Count All Valid Pickup and Delivery Options</div>
*************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你 <code>n</code> 笔订单，每笔订单都需要快递服务。</p>
<p>请你统计所有有效的 收件/配送 序列的数目，确保第 <code>i</code> 个物品的配送服务 <code>delivery(i)</code> 总是在其收件服务 <code>pickup(i)</code> 之后。</p>
<p>由于答案可能很大，请返回答案对 <code>10^9 + 7</code> 取余的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>1
<strong>解释：</strong>只有一种序列 (P1, D1)，物品 1 的配送服务（D1）在物品 1 的收件服务（P1）后。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>6
<strong>解释：</strong>所有可能的序列包括：
(P1,P2,D1,D2)，(P1,P2,D2,D1)，(P1,D1,P2,D2)，(P2,P1,D1,D2)，(P2,P1,D2,D1) 和 (P2,D2,P1,D1)。
(P1,D2,P2,D1) 是一个无效的序列，因为物品 2 的收件服务（P2）不应在物品 2 的配送服务（D2）之后。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>90
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 500</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************************<div id="title">1363. Largest Multiple of Three</div>
*******************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>digits</code>，你可以通过按任意顺序连接其中某些数字来形成 <strong>3</strong> 的倍数，请你返回所能得到的最大的 3 的倍数。</p>
<p>由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。</p>
<p>如果无法得到答案，请返回一个空字符串。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>digits = [8,1,9]
<strong>输出：</strong>"981"
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>digits = [8,6,7,1,0]
<strong>输出：</strong>"8760"
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>digits = [1]
<strong>输出：</strong>""
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>digits = [0,0,0,0,0,0]
<strong>输出：</strong>"0"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= digits.length &lt;= 10^4</code></li>
<li><code>0 &lt;= digits[i] &lt;= 9</code></li>
<li>返回的结果不应包含不必要的前导零。</li>
</ul>
</div></div></div><br><br><hr><br>************************************************************<div id="title">1368. Minimum Cost to Make at Least One Valid Path in a Grid</div>
************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 m x n 的网格图 <code>grid</code> 。 <code>grid</code> 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 <code>grid[i][j]</code> 中的数字可能为以下几种情况：</p>
<ul>
<li><strong>1</strong> ，下一步往右走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i][j + 1]</code></li>
<li><strong>2</strong> ，下一步往左走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i][j - 1]</code></li>
<li><strong>3</strong> ，下一步往下走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i + 1][j]</code></li>
<li><strong>4</strong> ，下一步往上走，也就是你会从 <code>grid[i][j]</code> 走到 <code>grid[i - 1][j]</code></li>
</ul>
<p>注意网格图中可能会有 <strong>无效数字</strong> ，因为它们可能指向 <code>grid</code> 以外的区域。</p>
<p>一开始，你会从最左上角的格子 <code>(0,0)</code> 出发。我们定义一条 <strong>有效路径</strong> 为从格子 <code>(0,0)</code> 出发，每一步都顺着数字对应方向走，最终在最右下角的格子 <code>(m - 1, n - 1)</code> 结束的路径。有效路径 <strong>不需要是最短路径</strong> 。</p>
<p>你可以花费 <code>cost = 1</code> 的代价修改一个格子中的数字，但每个格子中的数字 <strong>只能修改一次</strong> 。</p>
<p>请你返回让网格图至少有一条有效路径的最小代价。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid1.png" style="height: 528px; width: 542px;"/></p>
<pre><strong>输入：</strong>grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
<strong>输出：</strong>3
<strong>解释：</strong>你将从点 (0, 0) 出发。
到达 (3, 3) 的路径为： (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) 花费代价 cost = 1 使方向向下 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) 花费代价 cost = 1 使方向向下 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) 花费代价 cost = 1 使方向向下 --&gt; (3, 3)
总花费为 cost = 3.
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid2.png" style="height: 408px; width: 419px;"/></p>
<pre><strong>输入：</strong>grid = [[1,1,3],[3,2,2],[1,1,4]]
<strong>输出：</strong>0
<strong>解释：</strong>不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。
</pre>
<p><strong>示例 3：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid3.png" style="height: 302px; width: 314px;"/></p>
<pre><strong>输入：</strong>grid = [[1,2],[4,3]]
<strong>输出：</strong>1
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>grid = [[2,2,2],[2,2,2]]
<strong>输出：</strong>3
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>grid = [[4]]
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************<div id="title">1373. Maximum Sum BST in Binary Tree</div>
************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一棵以 <code>root</code> 为根的 <strong>二叉树</strong> ，请你返回 <strong>任意</strong> 二叉搜索子树的最大键值和。</p>
<p>二叉搜索树的定义如下：</p>
<ul>
<li>任意节点的左子树中的键值都 <strong>小于</strong> 此节点的键值。</li>
<li>任意节点的右子树中的键值都 <strong>大于</strong> 此节点的键值。</li>
<li>任意节点的左子树和右子树都是二叉搜索树。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_1_1709.png" style="height: 250px; width: 320px;"/></p>
<pre><strong>输入：</strong>root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
<strong>输出：</strong>20
<strong>解释：</strong>键值为 3 的子树是和最大的二叉搜索树。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_2_1709.png" style="height: 180px; width: 134px;"/></p>
<pre><strong>输入：</strong>root = [4,3,null,1,2]
<strong>输出：</strong>2
<strong>解释：</strong>键值为 2 的单节点子树是和最大的二叉搜索树。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>root = [-4,-2,-5]
<strong>输出：</strong>0
<strong>解释：</strong>所有节点键值都为负数，和最大的二叉搜索树为空。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>root = [2,1,3]
<strong>输出：</strong>6
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>root = [5,4,8,3,null,6,3]
<strong>输出：</strong>7
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li>每棵树有 <code>1</code> 到 <code>40000</code> 个节点。</li>
<li>每个节点的键值在 <code>[-4 * 10^4 , 4 * 10^4]</code> 之间。</li>
</ul>
</div></div></div><br><br><hr><br>***********************************<div id="title">1377. Frog Position After T Seconds</div>
***********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 <code>n</code>。青蛙从 <strong>顶点 1</strong> 开始起跳。规则如下：</p>
<ul>
<li>在一秒内，青蛙从它所在的当前顶点跳到另一个 <strong>未访问</strong> 过的顶点（如果它们直接相连）。</li>
<li>青蛙无法跳回已经访问过的顶点。</li>
<li>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</li>
<li>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</li>
</ul>
<p>无向树的边用数组 <code>edges</code> 描述，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> 意味着存在一条直接连通 <code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code> 两个顶点的边。</p>
<p>返回青蛙在 <em><code>t</code></em> 秒后位于目标顶点 <em><code>target</code> </em>上的概率。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/12/21/frog1.jpg"/></p>
<pre><strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4
<strong>输出：</strong>0.16666666666666666 
<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，第 <strong>1 秒</strong> 有 1/3 的概率跳到顶点 2 ，然后第 <strong>2 秒</strong> 有 1/2 的概率跳到顶点 4，因此青蛙在 2 秒后位于顶点 4 的概率是 1/3 * 1/2 = 1/6 = 0.16666666666666666 。 
</pre>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/12/21/frog2.jpg"/></p>
<pre><strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7
<strong>输出：</strong>0.3333333333333333
<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，有 1/3 = 0.3333333333333333 的概率能够 <strong>1 秒</strong> 后跳到顶点 7 。 
</pre>
<p> </p>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
<li><code>1 &lt;= t &lt;= 50</code></li>
<li><code>1 &lt;= target &lt;= n</code></li>
</ul>
</div></div></div><br><br><hr><br>***********************************<div id="title">1383. Maximum Performance of a Team</div>
***********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>公司有编号为 <code>1</code> 到 <code>n</code> 的 <code>n</code> 个工程师，给你两个数组 <code>speed</code> 和 <code>efficiency</code> ，其中 <code>speed[i]</code> 和 <code>efficiency[i]</code> 分别代表第 <code>i</code> 位工程师的速度和效率。请你返回由最多 <code>k</code> 个工程师组成的 <strong>​​​​​​最大团队表现值</strong> ，由于答案可能很大，请你返回结果对 <code>10^9 + 7</code> 取余后的结果。</p>
<p><strong>团队表现值</strong> 的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
<strong>输出：</strong>60
<strong>解释：</strong>
我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
<strong>输出：</strong>68
<strong>解释：
</strong>此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
<strong>输出：</strong>72
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>speed.length == n</code></li>
<li><code>efficiency.length == n</code></li>
<li><code>1 &lt;= speed[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= efficiency[i] &lt;= 10^8</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">1388. Pizza With 3n Slices</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：</p>
<ul>
<li>你挑选 <strong>任意</strong> 一块披萨。</li>
<li>Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。</li>
<li>Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。</li>
<li>重复上述过程直到没有披萨剩下。</li>
</ul>
<p>每一块披萨的大小按顺时针方向由循环数组 <code>slices</code> 表示。</p>
<p>请你返回你可以获得的披萨大小总和的最大值。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_3_1723.png" style="height: 240px; width: 475px;"/></p>
<pre><strong>输入：</strong>slices = [1,2,3,4,5,6]
<strong>输出：</strong>10
<strong>解释：</strong>选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_4_1723.png" style="height: 250px; width: 475px;"/></strong></p>
<pre><strong>输入：</strong>slices = [8,9,8,6,1,1]
<strong>输出：</strong>16
<strong>解释：</strong>两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= slices.length &lt;= 500</code></li>
<li><code>slices.length % 3 == 0</code></li>
<li><code>1 &lt;= slices[i] &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>**************************<div id="title">1392. Longest Happy Prefix</div>
**************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p><strong>「快乐前缀」</strong> 是在原字符串中既是 <strong>非空</strong> 前缀也是后缀（不包括原字符串自身）的字符串。</p>
<p>给你一个字符串 <code>s</code>，请你返回它的 <strong>最长快乐前缀</strong>。如果不存在满足题意的前缀，则返回一个空字符串 <code>""</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "level"
<strong>输出：</strong>"l"
<strong>解释：</strong>不包括 s 自己，一共有 4 个前缀（"l", "le", "lev", "leve"）和 4 个后缀（"l", "el", "vel", "evel"）。最长的既是前缀也是后缀的字符串是 "l" 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "ababab"
<strong>输出：</strong>"abab"
<strong>解释：</strong>"abab" 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
<li><code>s</code> 只含有小写英文字母</li>
</ul>
</div></div></div><br><br><hr><br>***************************<div id="title">1397. Find All Good Strings</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个长度为 <code>n</code> 的字符串 <code>s1</code> 和 <code>s2</code> ，以及一个字符串 <code>evil</code> 。请你返回 <strong>好字符串 </strong>的数目。</p>
<p><strong>好字符串</strong> 的定义为：它的长度为 <code>n</code> ，字典序大于等于 <code>s1</code> ，字典序小于等于 <code>s2</code> ，且不包含 <code>evil</code> 为子字符串。</p>
<p>由于答案可能很大，请你返回答案对 10^9 + 7 取余的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 2, s1 = "aa", s2 = "da", evil = "b"
<strong>输出：</strong>51 
<strong>解释：</strong>总共有 25 个以 'a' 开头的好字符串："aa"，"ac"，"ad"，...，"az"。还有 25 个以 'c' 开头的好字符串："ca"，"cc"，"cd"，...，"cz"。最后，还有一个以 'd' 开头的好字符串："da"。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 8, s1 = "leetcode", s2 = "leetgoes", evil = "leet"
<strong>输出：</strong>0 
<strong>解释：</strong>所有字典序大于等于 s1 且小于等于 s2 的字符串都以 evil 字符串 "leet" 开头。所以没有好字符串。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 2, s1 = "gx", s2 = "gz", evil = "x"
<strong>输出：</strong>2
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>s1.length == n</code></li>
<li><code>s2.length == n</code></li>
<li><code>s1 &lt;= s2</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= evil.length &lt;= 50</code></li>
<li>所有字符串都只包含小写英文字母。</li>
</ul>
</div></div></div><br><br><hr><br>******************<div id="title">140. Word Break II</div>
******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串 <code>s</code> 和一个字符串字典 <code>wordDict</code> ，在字符串 <code>s</code> 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。<strong>以任意顺序</strong> 返回所有这些可能的句子。</p>
<p><strong>注意：</strong>词典中的同一个单词可能在分段中被重复使用多次。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入:</strong>s = "<code>catsanddog</code>", wordDict = <code>["cat","cats","and","sand","dog"]</code>
<strong>输出:</strong><code>["cats and dog","cat sand dog"]</code>
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入:</strong>s = "pineapplepenapple", wordDict = ["apple","pen","applepen","pine","pineapple"]
<strong>输出:</strong>["pine apple pen apple","pineapple pen apple","pine applepen apple"]
<strong>解释:</strong> 注意你可以重复使用字典中的单词。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入:</strong>s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
<strong>输出:</strong>[]
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<p></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>
<li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li>
<li><code>wordDict</code> 中所有字符串都 <strong>不同</strong></li>
</ul>
</div></div></div><br><br><hr><br>*********************<div id="title">1402. Reducing Dishes</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一个厨师收集了他 <code>n</code> 道菜的满意程度 <code>satisfaction</code> ，这个厨师做出每道菜的时间都是 1 单位时间。</p>
<p>一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是 <code>time[i]</code>*<code>satisfaction[i]</code> 。</p>
<p>请你返回做完所有菜 「喜爱时间」总和的最大值为多少。</p>
<p>你可以按 <strong>任意</strong> 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>satisfaction = [-1,-8,0,5,-9]
<strong>输出：</strong>14
<strong>解释：</strong>去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>satisfaction = [4,3,2]
<strong>输出：</strong>20
<strong>解释：</strong>按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 = 20)
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>satisfaction = [-1,-4,-5]
<strong>输出：</strong>0
<strong>解释：</strong>大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == satisfaction.length</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>-1000 &lt;= satisfaction[i] &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>********************<div id="title">1406. Stone Game III</div>
********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 <code>stoneValue</code> 给出。</p>
<p>Alice 和 Bob 轮流取石子，<strong>Alice</strong> 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 <strong>1、2 或 3 堆石子</strong> 。比赛一直持续到所有石头都被拿走。</p>
<p>每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 <strong>0</strong> 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。</p>
<p>假设 Alice 和 Bob 都采取 <strong>最优策略</strong> 。如果 Alice 赢了就返回 <em>"Alice"</em> <em>，</em>Bob 赢了就返回<em> "Bob"，</em>平局（分数相同）返回 <em>"Tie"</em> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>values = [1,2,3,7]
<strong>输出：</strong>"Bob"
<strong>解释：</strong>Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>values = [1,2,3,-9]
<strong>输出：</strong>"Alice"
<strong>解释：</strong>Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。
如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。
如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。
注意，他们都应该采取 <strong>最优策略 </strong>，所以在这里 Alice 将选择能够使她获胜的方案。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>values = [1,2,3,6]
<strong>输出：</strong>"Tie"
<strong>解释：</strong>Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>values = [1,2,3,-1,-2,-3,7]
<strong>输出：</strong>"Alice"
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>values = [-1,-2,-3]
<strong>输出：</strong>"Tie"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= values.length &lt;= 50000</code></li>
<li><code>-1000 &lt;= values[i] &lt;= 1000</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">1411. Number of Ways to Paint N × 3 Grid</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>你有一个 <code>n x 3</code> 的网格图 <code>grid</code> ，你需要用 <strong>红，黄，绿</strong> 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。</p>
<p>给你网格图的行数 <code>n</code> 。</p>
<p>请你返回给 <code>grid</code> 涂色的方案数。由于答案可能会非常大，请你返回答案对 <code>10^9 + 7</code> 取余的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>12
<strong>解释：</strong>总共有 12 种可行的方法：
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/12/e1.png" style="height: 289px; width: 450px;"/>
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>54
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>246
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>n = 7
<strong>输出：</strong>106494
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>n = 5000
<strong>输出：</strong>30228214
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == grid.length</code></li>
<li><code>grid[i].length == 3</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
</ul>
</div></div></div><br><br><hr><br>***********************<div id="title">1416. Restore The Array</div>
***********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 <code>[1, k]</code> 之间，且数组中的数字都没有前导 0 。</p>
<p>给你字符串 <code>s</code> 和整数 <code>k</code> 。可能会有多种不同的数组恢复结果。</p>
<p>按照上述程序，请你返回所有可能输出字符串 <code>s</code> 的数组方案数。</p>
<p>由于数组方案数可能会很大，请你返回它对 <code>10^9 + 7</code> <strong>取余</strong> 后的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>s = "1000", k = 10000
<strong>输出：</strong>1
<strong>解释：</strong>唯一一种可能的数组方案是 [1000]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>s = "1000", k = 10
<strong>输出：</strong>0
<strong>解释：</strong>不存在任何数组方案满足所有整数都 &gt;= 1 且 &lt;= 10 同时输出结果为 s 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>s = "1317", k = 2000
<strong>输出：</strong>8
<strong>解释：</strong>可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>s = "2020", k = 30
<strong>输出：</strong>1
<strong>解释：</strong>唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 &gt; 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>s = "1234567890", k = 90
<strong>输出：</strong>34
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code>.</li>
<li><code>s</code> 只包含数字且不包含前导 0 。</li>
<li><code>1 &lt;= k &lt;= 10^9</code>.</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************************************<div id="title">1420. Build Array Where You Can Find The Maximum Exactly K Comparisons</div>
**********************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你三个整数 <code>n</code>、<code>m</code> 和 <code>k</code> 。下图描述的算法用于找出正整数数组中最大的元素。</p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/19/e.png" style="height: 372px; width: 424px;"/></p>
<p>请你生成一个具有下述属性的数组 <code>arr</code> ：</p>
<ul>
<li><code>arr</code> 中有 <code>n</code> 个整数。</li>
<li><code>1 &lt;= arr[i] &lt;= m</code> 其中 <code>(0 &lt;= i &lt; n)</code> 。</li>
<li>将上面提到的算法应用于 <code>arr</code> ，<code>search_cost</code> 的值等于 <code>k</code> 。</li>
</ul>
<p>返回上述条件下生成数组 <code>arr</code> 的 <strong>方法数</strong> ，由于答案可能会很大，所以 <strong>必须</strong> 对 <code>10^9 + 7</code> 取余。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 2, m = 3, k = 1
<strong>输出：</strong>6
<strong>解释：</strong>可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 5, m = 2, k = 3
<strong>输出：</strong>0
<strong>解释：</strong>没有数组可以满足上述条件
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 9, m = 1, k = 1
<strong>输出：</strong>1
<strong>解释：</strong>可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>n = 50, m = 100, k = 25
<strong>输出：</strong>34549172
<strong>解释：</strong>不要忘了对 1000000007 取余
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>n = 37, m = 17, k = 7
<strong>输出：</strong>418930126
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>1 &lt;= m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= n</code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1425. Constrained Subsequence Sum</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <strong>非空</strong> 子序列元素和的最大值，子序列需要满足：子序列中每两个 <strong>相邻</strong> 的整数 <code>nums[i]</code> 和 <code>nums[j]</code> ，它们在原数组中的下标 <code>i</code> 和 <code>j</code> 满足 <code>i &lt; j</code> 且 <code>j - i &lt;= k</code> 。</p>
<p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [10,2,-10,5,20], k = 2
<strong>输出：</strong>37
<strong>解释：</strong>子序列为 [10, 2, 5, 20] 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [-1,-2,-3], k = 1
<strong>输出：</strong>-1
<strong>解释：</strong>子序列必须是非空的，所以我们选择最大的数字。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums = [10,-2,-10,-5,20], k = 2
<strong>输出：</strong>23
<strong>解释：</strong>子序列为 [10, -2, -5, 20] 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
</div></div></div><br><br><hr><br>*********************************************************<div id="title">1434. Number of Ways to Wear Different Hats to Each Other</div>
*********************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>总共有 <code>n</code> 个人和 <code>40</code> 种不同的帽子，帽子编号从 <code>1</code> 到 <code>40</code> 。</p>
<p>给你一个整数列表的列表 <code>hats</code> ，其中 <code>hats[i]</code> 是第 <code>i</code> 个人所有喜欢帽子的列表。</p>
<p>请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数。</p>
<p>由于答案可能很大，请返回它对 <code>10^9 + 7</code> 取余后的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>hats = [[3,4],[4,5],[5]]
<strong>输出：</strong>1
<strong>解释：</strong>给定条件下只有一种方法选择帽子。
第一个人选择帽子 3，第二个人选择帽子 4，最后一个人选择帽子 5。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>hats = [[3,5,1],[3,5]]
<strong>输出：</strong>4
<strong>解释：</strong>总共有 4 种安排帽子的方法：
(3,5)，(5,3)，(1,3) 和 (1,5)
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
<strong>输出：</strong>24
<strong>解释：</strong>每个人都可以从编号为 1 到 4 的帽子中选。
(1,2,3,4) 4 个帽子的排列方案数为 24 。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]
<strong>输出：</strong>111
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == hats.length</code></li>
<li><code>1 &lt;= n &lt;= 10</code></li>
<li><code>1 &lt;= hats[i].length &lt;= 40</code></li>
<li><code>1 &lt;= hats[i][j] &lt;= 40</code></li>
<li><code>hats[i]</code> 包含一个数字互不相同的整数列表。</li>
</ul>
</div></div></div><br><br><hr><br>************************************************************<div id="title">1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows</div>
************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>m * n</code> 的矩阵 <code>mat</code>，以及一个整数 <code>k</code> ，矩阵中的每一行都以非递减的顺序排列。</p>
<p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 <strong>最小</strong> 数组和。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>mat = [[1,3,11],[2,4,6]], k = 5
<strong>输出：</strong>7
<strong>解释：</strong>从每一行中选出一个元素，前 k 个和最小的数组分别是：
[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。  </pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>mat = [[1,3,11],[2,4,6]], k = 9
<strong>输出：</strong>17
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
<strong>输出：</strong>9
<strong>解释：</strong>从每一行中选出一个元素，前 k 个和最小的数组分别是：
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>mat = [[1,1,10],[2,2,9]], k = 7
<strong>输出：</strong>12
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat.length[i]</code></li>
<li><code>1 &lt;= m, n &lt;= 40</code></li>
<li><code>1 &lt;= k &lt;= min(200, n ^ m)</code></li>
<li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li>
<li><code>mat[i]</code> 是一个非递减数组</li>
</ul>
</div></div></div><br><br><hr><br>***************************************<div id="title">1444. Number of Ways of Cutting a Pizza</div>
***************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>rows x cols</code> 大小的矩形披萨和一个整数 <code>k</code> ，矩形包含两种字符： <code>'A'</code> （表示苹果）和 <code>'.'</code> （表示空白格子）。你需要切披萨 <code>k-1</code> 次，得到 <code>k</code> 块披萨并送给别人。</p>
<p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p>
<p>请你返回确保每一块披萨包含 <strong>至少</strong> 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/ways_to_cut_apple_1.png" style="height: 378px; width: 500px;"/></strong></p>
<pre><strong>输入：</strong>pizza = ["A..","AAA","..."], k = 3
<strong>输出：</strong>3 
<strong>解释：</strong>上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>pizza = ["A..","AA.","..."], k = 3
<strong>输出：</strong>1
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>pizza = ["A..","A..","..."], k = 1
<strong>输出：</strong>1
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= rows, cols &lt;= 50</code></li>
<li><code>rows == pizza.length</code></li>
<li><code>cols == pizza[i].length</code></li>
<li><code>1 &lt;= k &lt;= 10</code></li>
<li><code>pizza</code> 只包含字符 <code>'A'</code> 和 <code>'.'</code> 。</li>
</ul>
</div></div></div><br><br><hr><br>************************************************************<div id="title">1449. Form Largest Integer With Digits That Add up to Target</div>
************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code> 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p>
<ul>
<li>给当前结果添加一个数位（<code>i + 1</code>）的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。</li>
<li>总成本必须恰好等于 <code>target</code> 。</li>
<li>添加的数位中没有数字 0 。</li>
</ul>
<p>由于答案可能会很大，请你以字符串形式返回。</p>
<p>如果按照上述要求无法得到任何整数，请你返回 "0" 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>cost = [4,3,2,5,6,7,2,5,5], target = 9
<strong>输出：</strong>"7772"
<strong>解释：</strong>添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 "7772" 的代价为 2*3+ 3*1 = 9 。 "977" 也是满足要求的数字，但 "7772" 是较大的数字。
<strong> 数字     成本</strong>
  1  -&gt;   4
  2  -&gt;   3
  3  -&gt;   2
  4  -&gt;   5
  5  -&gt;   6
  6  -&gt;   7
  7  -&gt;   2
  8  -&gt;   5
  9  -&gt;   5
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>cost = [7,6,5,5,5,6,8,7,8], target = 12
<strong>输出：</strong>"85"
<strong>解释：</strong>添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。"85" 的成本为 7 + 5 = 12 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>cost = [2,4,6,2,4,6,4,4,4], target = 5
<strong>输出：</strong>"0"
<strong>解释：</strong>总成本是 target 的条件下，无法生成任何整数。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>cost = [6,10,15,40,40,40,40,40,40], target = 47
<strong>输出：</strong>"32211"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>cost.length == 9</code></li>
<li><code>1 &lt;= cost[i] &lt;= 5000</code></li>
<li><code>1 &lt;= target &lt;= 5000</code></li>
</ul>
</div></div></div><br><br><hr><br>************************************************************<div id="title">1453. Maximum Number of Darts Inside of a Circular Dartboard</div>
************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>墙壁上挂着一个圆形的飞镖靶。现在请你蒙着眼睛向靶上投掷飞镖。</p>
<p>投掷到墙上的飞镖用二维平面上的点坐标数组表示。飞镖靶的半径为 <code>r</code> 。</p>
<p>请返回能够落在 <strong>任意</strong> 半径为 <code>r</code> 的圆形靶内或靶上的最大飞镖数。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/sample_1_1806.png" style="height: 159px; width: 186px;"/></p>
<pre><strong>输入：</strong>points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2
<strong>输出：</strong>4
<strong>解释：</strong>如果圆形的飞镖靶的圆心为 (0,0) ，半径为 2 ，所有的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 4 。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/sample_2_1806.png" style="height: 183px; width: 224px;"/></strong></p>
<pre><strong>输入：</strong>points = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5
<strong>输出：</strong>5
<strong>解释：</strong>如果圆形的飞镖靶的圆心为 (0,4) ，半径为 5 ，则除了 (7,8) 之外的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 5 。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>points = [[-2,0],[2,0],[0,2],[0,-2]], r = 1
<strong>输出：</strong>1
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>points = [[1,2],[3,5],[1,-1],[2,3],[4,1],[1,3]], r = 2
<strong>输出：</strong>4
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= points.length &lt;= 100</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-10^4 &lt;= points[i][0], points[i][1] &lt;= 10^4</code></li>
<li><code>1 &lt;= r &lt;= 5000</code></li>
</ul>
</div></div></div><br><br><hr><br>*****************************************<div id="title">1458. Max Dot Product of Two Subsequences</div>
*****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你两个数组 <code>nums1</code> 和 <code>nums2</code> 。</p>
<p>请你返回 <code>nums1</code> 和 <code>nums2</code> 中两个长度相同的 <strong>非空</strong> 子序列的最大点积。</p>
<p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，<code>[2,3,5]</code> 是 <code>[1,2,3,4,5]</code> 的一个子序列而 <code>[1,5,3]</code> 不是。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums1 = [2,1,-2,5], nums2 = [3,0,-6]
<strong>输出：</strong>18
<strong>解释：</strong>从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。
它们的点积为 (2*3 + (-2)*(-6)) = 18 。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums1 = [3,-2], nums2 = [2,-6,7]
<strong>输出：</strong>21
<strong>解释：</strong>从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。
它们的点积为 (3*7) = 21 。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>nums1 = [-1,-1], nums2 = [1,1]
<strong>输出：</strong>-1
<strong>解释：</strong>从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。
它们的点积为 -1 。</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>
<li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>
</ul>
<p> </p>
<p><strong>点积：</strong></p>
<pre>定义 <code><strong>a</strong> = [<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>,…, <em>a</em><sub><em>n</em></sub>]</code> 和<strong> <code>b</code></strong><code> = [<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>,…, <em>b</em><sub><em>n</em></sub>]</code> 的点积为：

<img alt="\mathbf{a}\cdot \mathbf{b} = \sum_{i=1}^n a_ib_i = a_1b_1 + a_2b_2 + \cdots + a_nb_n" class="tex" src="https://pic.leetcode-cn.com/1666164309-PBJMQp-image.png"/>

这里的 <strong>Σ</strong> 指示总和符号。
</pre>
</div></div></div><br><br><hr><br>**********************<div id="title">1463. Cherry Pickup II</div>
**********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>rows x cols</code> 的矩阵 <code>grid</code> 来表示一块樱桃地。 <code>grid</code> 中每个格子的数字表示你能获得的樱桃数目。</p>
<p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 <code>(0,0)</code> 出发，机器人 2 从右上角格子 <code>(0, cols-1)</code> 出发。</p>
<p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p>
<ul>
<li>从格子 <code>(i,j)</code> 出发，机器人可以移动到格子 <code>(i+1, j-1)</code>，<code>(i+1, j)</code> 或者 <code>(i+1, j+1)</code> 。</li>
<li>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。</li>
<li>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。</li>
<li>两个机器人在任意时刻都不能移动到 <code>grid</code> 外面。</li>
<li>两个机器人最后都要到达 <code>grid</code> 最底下一行。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1802.png" style="height: 182px; width: 139px;"/></strong></p>
<pre><strong>输入：</strong>grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
<strong>输出：</strong>24
<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。
机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。
机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。
樱桃总数为： 12 + 12 = 24 。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1802.png" style="height: 257px; width: 284px;"/></strong></p>
<pre><strong>输入：</strong>grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
<strong>输出：</strong>28
<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。
机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。
机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。
樱桃总数为： 17 + 11 = 28 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]
<strong>输出：</strong>22
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>grid = [[1,1],[1,1]]
<strong>输出：</strong>4
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>rows == grid.length</code></li>
<li><code>cols == grid[i].length</code></li>
<li><code>2 &lt;= rows, cols &lt;= 70</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 100 </code></li>
</ul>
</div></div></div><br><br><hr><br>*************************************************************************<div id="title">1467. Probability of a Two Boxes Having The Same Number of Distinct Balls</div>
*************************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>桌面上有 <code>2n</code> 个颜色不完全相同的球，球上的颜色共有 <code>k</code> 种。给你一个大小为 <code>k</code> 的整数数组 <code>balls</code> ，其中 <code>balls[i]</code> 是颜色为 <code>i</code> 的球的数量。</p>
<p>所有的球都已经 <strong>随机打乱顺序</strong> ，前 <code>n</code> 个球放入第一个盒子，后 <code>n</code> 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。</p>
<p><strong>注意：</strong>这两个盒子是不同的。例如，两个球颜色分别为 <code>a</code> 和 <code>b</code>，盒子分别为 <code>[]</code> 和 <code>()</code>，那么 <code>[a] (b)</code> 和 <code>[b] (a)</code> 这两种分配方式是不同的（请认真阅读示例的解释部分）。</p>
<p>请返回「两个盒子中球的颜色数相同」的情况的概率。答案与真实值误差在 <code>10^-5</code> 以内，则被视为正确答案</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>balls = [1,1]
<strong>输出：</strong>1.00000
<strong>解释：</strong>球平均分配的方式只有两种：
- 颜色为 1 的球放入第一个盒子，颜色为 2 的球放入第二个盒子
- 颜色为 2 的球放入第一个盒子，颜色为 1 的球放入第二个盒子
这两种分配，两个盒子中球的颜色数都相同。所以概率为 2/2 = 1 。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>balls = [2,1,1]
<strong>输出：</strong>0.66667
<strong>解释：</strong>球的列表为 [1, 1, 2, 3]
随机打乱，得到 12 种等概率的不同打乱方案，每种方案概率为 1/12 ：
[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]
然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。
这 12 种可能的随机打乱方式中的 8 种满足「两个盒子中球的颜色数相同」。
概率 = 8/12 = 0.66667
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>balls = [1,2,1,2]
<strong>输出：</strong>0.60000
<strong>解释：</strong>球的列表为 [1, 2, 2, 3, 4, 4]。要想显示所有 180 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 108 种情况是比较容易的。
概率 = 108 / 180 = 0.6 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= balls.length &lt;= 8</code></li>
<li><code>1 &lt;= balls[i] &lt;= 6</code></li>
<li><code>sum(balls)</code> 是偶数</li>
</ul>
</div></div></div><br><br><hr><br>*********************<div id="title">1473. Paint House III</div>
*********************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>在一个小城市里，有 <code>m</code> 个房子排成一排，你需要给每个房子涂上 <code>n</code> 种颜色之一（颜色编号为 <code>1</code> 到 <code>n</code> ）。有的房子去年夏天已经涂过颜色了，所以这些房子不可以被重新涂色。</p>
<p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 <code>houses = [1,2,2,3,3,2,1,1]</code> ，它包含 5 个街区 <code> [{1}, {2,2}, {3,3}, {2}, {1,1}]</code> 。）</p>
<p>给你一个数组 <code>houses</code> ，一个 <code>m * n</code> 的矩阵 <code>cost</code> 和一个整数 <code>target</code> ，其中：</p>
<ul>
<li><code>houses[i]</code>：是第 <code>i</code> 个房子的颜色，<strong>0</strong> 表示这个房子还没有被涂色。</li>
<li><code>cost[i][j]</code>：是将第 <code>i</code> 个房子涂成颜色 <code>j+1</code> 的花费。</li>
</ul>
<p>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 <code>target</code> 个街区。如果没有可用的涂色方案，请返回 <strong>-1</strong> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
<strong>输出：</strong>9
<strong>解释：</strong>房子涂色方案为 [1,2,2,1,1]
此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。
涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
<strong>输出：</strong>11
<strong>解释：</strong>有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]
此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。
给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5
<strong>输出：</strong>5
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
<strong>输出：</strong>-1
<strong>解释：</strong>房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == houses.length == cost.length</code></li>
<li><code>n == cost[i].length</code></li>
<li><code>1 &lt;= m &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= target &lt;= m</code></li>
<li><code>0 &lt;= houses[i] &lt;= n</code></li>
<li><code>1 &lt;= cost[i][j] &lt;= 10^4</code></li>
</ul>
</div></div></div><br><br><hr><br>************************<div id="title">1478. Allocate Mailboxes</div>
************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个房屋数组<code>houses</code> 和一个整数 <code>k</code> ，其中 <code>houses[i]</code> 是第 <code>i</code> 栋房子在一条街上的位置，现需要在这条街上安排 <code>k</code> 个邮筒。</p>
<p>请你返回每栋房子与离它最近的邮筒之间的距离的 <strong>最小 </strong>总和。</p>
<p>答案保证在 32 位有符号整数范围以内。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/13/sample_11_1816.png" style="height: 154px; width: 454px;"/></p>
<pre><strong>输入：</strong>houses = [1,4,8,10,20], k = 3
<strong>输出：</strong>5
<strong>解释：</strong>将邮筒分别安放在位置 3， 9 和 20 处。
每个房子到最近邮筒的距离和为 |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/13/sample_2_1816.png" style="height: 154px; width: 433px;"/></strong></p>
<pre><strong>输入：</strong>houses = [2,3,5,12,18], k = 2
<strong>输出：</strong>9
<strong>解释：</strong>将邮筒分别安放在位置 3 和 14 处。
每个房子到最近邮筒距离和为 |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>houses = [7,4,6,1], k = 1
<strong>输出：</strong>8
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>houses = [3,6,14,10], k = 4
<strong>输出：</strong>0
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == houses.length</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= houses[i] &lt;= 10^4</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
<li>数组 <code>houses</code> 中的整数互不相同。</li>
</ul>
</div></div></div><br><br><hr><br>*********************************<div id="title">1483. Kth Ancestor of a Tree Node</div>
*********************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一棵树，树上有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n-1</code> 编号。树以父节点数组的形式给出，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点。树的根节点是编号为 <code>0</code> 的节点。</p>
<p>树节点的第 <em><code>k</code> </em>个祖先节点是从该节点到根节点路径上的第 <code>k</code> 个节点。</p>
<p>实现 <code>TreeAncestor</code> 类：</p>
<ul>
<li><code>TreeAncestor（int n， int[] parent）</code> 对树和父数组中的节点数初始化对象。</li>
<li><code>getKthAncestor</code><code>(int node, int k)</code> 返回节点 <code>node</code> 的第 <code>k</code> 个祖先节点。如果不存在这样的祖先节点，返回 <code>-1</code> 。</li>
</ul>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/14/1528_ex1.png"/></strong></p>
<pre><strong>输入：</strong>
["TreeAncestor","getKthAncestor","getKthAncestor","getKthAncestor"]
[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]

<strong>输出：</strong>
[null,1,0,-1]

<strong>解释：</strong>
TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);

treeAncestor.getKthAncestor(3, 1);  // 返回 1 ，它是 3 的父节点
treeAncestor.getKthAncestor(5, 2);  // 返回 0 ，它是 5 的祖父节点
treeAncestor.getKthAncestor(6, 3);  // 返回 -1 因为不存在满足要求的祖先节点
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
<li><code>parent[0] == -1</code> 表示编号为 <code>0</code> 的节点是根节点。</li>
<li>对于所有的 <code>0 &lt; i &lt; n</code> ，<code>0 &lt;= parent[i] &lt; n</code> 总成立</li>
<li><code>0 &lt;= node &lt; n</code></li>
<li>至多查询 <code>5 * 10<sup>4</sup></code> 次</li>
</ul>
</div></div></div><br><br><hr><br>**********************************************************************<div id="title">1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree</div>
**********************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个 <code>n</code> 个点的带权无向连通图，节点编号为 <code>0</code> 到 <code>n-1</code> ，同时还有一个数组 <code>edges</code> ，其中 <code>edges[i] = [from</code><code><sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> 表示在 <code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code> 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p>
<p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p>
<p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex1.png" style="height: 262px; width: 259px;"/></p>
<pre><strong>输入：</strong>n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
<strong>输出：</strong>[[0,1],[2,3,4,5]]
<strong>解释：</strong>上图描述了给定图。
下图是所有的最小生成树。
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/msts.png" style="height: 553px; width: 540px;"/>
注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。
边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。
</pre>
<p><strong>示例 2 ：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex2.png" style="height: 253px; width: 247px;"/></p>
<pre><strong>输入：</strong>n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
<strong>输出：</strong>[[],[0,1,2,3]]
<strong>解释：</strong>可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li>
<li><code>edges[i].length == 3</code></li>
<li><code>0 &lt;= from<sub>i</sub> &lt; to<sub>i</sub> &lt; n</code></li>
<li><code>1 &lt;= weight<sub>i</sub> &lt;= 1000</code></li>
<li>所有 <code>(from<sub>i</sub>, to<sub>i</sub>)</code> 数对都是互不相同的。</li>
</ul>
</div></div></div><br><br><hr><br>*************************<div id="title">149. Max Points on a Line</div>
*************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg" style="width: 300px; height: 294px;"/>
<pre><strong>输入：</strong>points = [[1,1],[2,2],[3,3]]
<strong>输出：</strong>3
</pre>
<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg" style="width: 300px; height: 294px;"/>
<pre><strong>输入：</strong>points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
<strong>输出：</strong>4
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= points.length &lt;= 300</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
<li><code>points</code> 中的所有点 <strong>互不相同</strong></li>
</ul>
</div></div></div><br><br><hr><br>*************************<div id="title">1494. Parallel Courses II</div>
*************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个整数 <code>n</code> 表示某所大学里课程的数目，编号为 <code>1</code> 到 <code>n</code> ，数组 <code>relations</code> 中， <code>relations[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>  表示一个先修课的关系，也就是课程 <code>x<sub>i</sub></code> 必须在课程 <code>y<sub>i</sub></code><sub> </sub>之前上。同时你还有一个整数 <code>k</code> 。</p>
<p>在一个学期中，你 <strong>最多</strong> 可以同时上 <code>k</code> 门课，前提是这些课的先修课在之前的学期里已经上过了。</p>
<p>请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_1.png" style="height: 164px; width: 300px;"/></strong></p>
<pre><strong>输入：</strong>n = 4, relations = [[2,1],[3,1],[1,4]], k = 2
<strong>输出：</strong>3 
<strong>解释：</strong>上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。
</pre>
<p><strong>示例 2：</strong></p>
<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_2.png" style="height: 234px; width: 300px;"/></strong></p>
<pre><strong>输入：</strong>n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2
<strong>输出：</strong>4 
<strong>解释：</strong>上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 11, relations = [], k = 2
<strong>输出：</strong>6
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 15</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
<li><code>0 &lt;= relations.length &lt;= n * (n-1) / 2</code></li>
<li><code>relations[i].length == 2</code></li>
<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n</code></li>
<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
<li>所有先修关系都是不同的，也就是说 <code>relations[i] != relations[j]</code> 。</li>
<li>题目输入的图是个有向无环图。</li>
</ul>
</div></div></div><br><br><hr><br>***************************<div id="title">1499. Max Value of Equation</div>
***************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个数组 <code>points</code> 和一个整数 <code>k</code> 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，并且在 <code>1 &lt;= i &lt; j &lt;= points.length</code> 的前提下， <code>x<sub>i</sub> &lt; x<sub>j</sub></code> 总成立。</p>
<p>请你找出<em> </em><code>y<sub>i</sub> + y<sub>j</sub> + |x<sub>i</sub> - x<sub>j</sub>|</code> 的 <strong>最大值</strong>，其中 <code>|x<sub>i</sub> - x<sub>j</sub>| &lt;= k</code> 且 <code>1 &lt;= i &lt; j &lt;= points.length</code>。</p>
<p>题目测试数据保证至少存在一对能够满足 <code>|x<sub>i</sub> - x<sub>j</sub>| &lt;= k</code> 的点。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>points = [[1,3],[2,0],[5,10],[6,-10]], k = 1
<strong>输出：</strong>4
<strong>解释：</strong>前两个点满足 |x<sub>i</sub> - x<sub>j</sub>| &lt;= 1 ，代入方程计算，则得到值 3 + 0 + |1 - 2| = 4 。第三个和第四个点也满足条件，得到值 10 + -10 + |5 - 6| = 1 。
没有其他满足条件的点，所以返回 4 和 1 中最大的那个。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>points = [[0,0],[3,0],[9,2]], k = 3
<strong>输出：</strong>3
<strong>解释：</strong>只有前两个点满足 |x<sub>i</sub> - x<sub>j</sub>| &lt;= 3 ，代入方程后得到值 0 + 0 + |0 - 3| = 3 。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= points.length &lt;= 10^5</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-10^8 &lt;= points[i][0], points[i][1] &lt;= 10^8</code></li>
<li><code>0 &lt;= k &lt;= 2 * 10^8</code></li>
<li>对于所有的<code>1 &lt;= i &lt; j &lt;= points.length</code> ，<code>points[i][0] &lt; points[j][0]</code> 都成立。也就是说，<code>x<sub>i</sub></code> 是严格递增的。</li>
</ul>
</div></div></div><br><br><hr><br>***********************************************************************<div id="title">1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits</div>
***********************************************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>给你一个字符串 <code>num</code> 和一个整数 <code>k</code> 。其中，<code>num</code> 表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 <strong>数位</strong> 。</p>
<p>你可以交换这个整数相邻数位的数字 <strong>最多</strong> <code>k</code> 次。</p>
<p>请你返回你能得到的最小整数，并以字符串形式返回。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode.com/uploads/2020/06/17/q4_1.jpg" style="height:40px; width:500px"/></p>
<pre><strong>输入：</strong>num = "4321", k = 4
<strong>输出：</strong>"1342"
<strong>解释：</strong>4321 通过 4 次交换相邻数位得到最小整数的步骤如上图所示。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>num = "100", k = 1
<strong>输出：</strong>"010"
<strong>解释：</strong>输出可以包含前导 0 ，但输入保证不会有前导 0 。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>num = "36789", k = 1000
<strong>输出：</strong>"36789"
<strong>解释：</strong>不需要做任何交换。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>num = "22", k = 22
<strong>输出：</strong>"22"
</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>num = "9438957234785635408", k = 23
<strong>输出：</strong>"0345989723478563548"
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num.length &lt;= 30000</code></li>
<li><code>num</code> 只包含 <strong>数字</strong> 且不含有<strong> 前导 0 </strong>。</li>
<li><code>1 &lt;= k &lt;= 10^9</code></li>
</ul>
</div></div></div><br><br><hr><br>*******************<div id="title">1510. Stone Game IV</div>
*******************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。</p>
<p>一开始，有 <code>n</code> 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 <strong>任意</strong> 非零 <strong>平方数</strong> 个石子。</p>
<p>如果石子堆里没有石子了，则无法操作的玩家输掉游戏。</p>
<p>给你正整数 <code>n</code> ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>true
<strong>解释：</strong>Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>false
<strong>解释：</strong>Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -&gt; 1 -&gt; 0）。</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>n = 4
<strong>输出：</strong>true
<strong>解释：</strong>n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -&gt; 0）。
</pre>
<p><strong>示例 4：</strong></p>
<pre><strong>输入：</strong>n = 7
<strong>输出：</strong>false
<strong>解释：</strong>当 Bob 采取最优策略时，Alice 无法赢得比赛。
如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0）。
如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 6 -&gt; 2 -&gt; 1 -&gt; 0）。</pre>
<p><strong>示例 5：</strong></p>
<pre><strong>输入：</strong>n = 17
<strong>输出：</strong>false
<strong>解释：</strong>如果 Bob 采取最优策略，Alice 无法赢得胜利。
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
</ul>
</div></div></div><br><br><hr><br>****************************************<div id="title">1515. Best Position for a Service Centre</div>
****************************************<div class="css-1rngd9y-ZoomWrapper e13l6k8o9"><div class="content__1Y2H"><div class="notranslate"><p>一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 <strong>到所有客户的欧几里得距离的总和最小</strong> 。</p>
<p>给你一个数组 <code>positions</code> ，其中 <code>positions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示第 <code>i</code> 个客户在二维地图上的位置，返回到所有客户的 <strong>欧几里得距离的最小总和 。</strong></p>
<p>换句话说，请你为服务中心选址，该位置的坐标 <code>[x<sub>centre</sub>, y<sub>centre</sub>]</code> 需要使下面的公式取到最小值：</p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_edited.jpg"/></p>
<p>与真实值误差在 <code>10<sup>-5</sup></code>之内的答案将被视作正确答案。</p>
<p> </p>
<p><strong>示例 1：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e1.jpg"/></p>
<pre><strong>输入：</strong>positions = [[0,1],[1,0],[1,2],[2,1]]
<strong>输出：</strong>4.00000
<strong>解释：</strong>如图所示，你可以选 [x<sub>centre</sub>, y<sub>centre</sub>] = [1, 1] 作为新中心的位置，这样一来到每个客户的距离就都是 1，所有距离之和为 4 ，这也是可以找到的最小值。
</pre>
<p><strong>示例 2：</strong></p>
<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e3.jpg"/></p>
<pre><strong>输入：</strong>positions = [[1,1],[3,3]]
<strong>输出：</strong>2.82843
<strong>解释：</strong>欧几里得距离可能的最小总和为 sqrt(2) + sqrt(2) = 2.82843
</pre>
<p> </p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= positions.length &lt;= 50</code></li>
<li><code>positions[i].length == 2</code></li>
<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>
</ul>
</div></div></div><br><br><hr><br>